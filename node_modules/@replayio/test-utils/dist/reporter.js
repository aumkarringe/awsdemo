"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReporterError = void 0;
const replay_1 = require("@replayio/replay");
const metadata_1 = require("@replayio/replay/metadata");
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const fs_1 = require("fs");
const strict_1 = __importDefault(require("node:assert/strict"));
const path_1 = require("path");
const uuid_1 = require("uuid");
const logging_1 = require("./logging");
const metadata_2 = require("./metadata");
const metrics_1 = require("./metrics");
const testId_1 = require("./testId");
function last(arr) {
    return arr[arr.length - 1];
}
const debug = (0, debug_1.default)("replay:test-utils:reporter");
function getErrorMessage(e) {
    return e && typeof e === "object" && "message" in e ? e.message : "Unknown Error";
}
function logPendingWorkErrors(errors) {
    return errors.map(e => `   - ${e.error.message}`);
}
function getTestResult(recording) {
    const test = recording.metadata.test;
    return !test ? "unknown" : test.result;
}
function getTestResultEmoji(recording) {
    const result = getTestResult(recording);
    switch (result) {
        case "unknown":
            return "﹖";
        case "failed":
        case "timedOut":
            return "❌";
        case "passed":
            return "✅";
        case "skipped":
            return "🤷";
    }
}
const resultOrder = ["failed", "timedOut", "passed", "skipped", "unknown"];
function sortRecordingsByResult(recordings) {
    return [...recordings].sort((a, b) => {
        return (resultOrder.indexOf(getTestResult(a)) - resultOrder.indexOf(getTestResult(b)) ||
            (a.metadata.title || "").localeCompare(b.metadata.title || ""));
    });
}
function parseRuntime(runtime) {
    return ["chromium", "gecko", "node"].find(r => runtime?.includes(r));
}
function throwGraphqlErrors(operation, errors) {
    errors.forEach((e) => debug("Error from GraphQL operation %s: %o", operation, e));
    throw new Error(`GraphQL request for ${operation} failed (${errors.map(getErrorMessage).join(", ")})`);
}
function isNonNullable(arg) {
    return arg !== null && arg !== undefined;
}
class ReporterError extends Error {
    code;
    detail;
    constructor(code, message, detail = null) {
        super();
        this.name = "ReporterError";
        this.code = code;
        this.message = message;
        this.detail = !detail || typeof detail === "string" ? detail : JSON.stringify(detail);
    }
    valueOf() {
        return {
            code: this.code,
            name: this.name,
            message: this.message,
            detail: this.detail,
        };
    }
}
exports.ReporterError = ReporterError;
function getFallbackRunTitle() {
    // for CI runs we don't want to set an explicit title
    // dashboard is meant to use the commit/PR information retrieved on CI
    if (process.env.CI) {
        return;
    }
    let gitChild;
    try {
        gitChild = (0, child_process_1.spawnSync)("git", ["rev-parse", "--abbrev-ref", "HEAD"]);
    }
    catch {
        return;
    }
    if (gitChild.status !== 0) {
        return;
    }
    return `(local) ${gitChild.stdout.toString().trim()} branch`;
}
class ReplayReporter {
    _baseId = metadata_1.source.getTestRunIdFromEnvironment(process.env) || (0, uuid_1.v4)();
    _testRunShardId = null;
    _baseMetadata = null;
    _schemaVersion;
    _runTitle;
    _runner;
    _errors = [];
    _apiKey;
    _pendingWork = [];
    _upload = false;
    _filter;
    _minimizeUploads = false;
    _uploadableResults = new Map();
    _testRunShardIdPromise = null;
    _uploadStatusThreshold = "none";
    _uploadedRecordings = new Set();
    constructor(runner, schemaVersion, config) {
        this._runner = runner;
        this._schemaVersion = schemaVersion;
        if (config) {
            const { metadataKey, ...rest } = config;
            this._parseConfig(rest, metadataKey);
        }
    }
    setTestRunnerVersion(version) {
        this._runner = {
            ...this._runner,
            version: version,
        };
    }
    setApiKey(apiKey) {
        this._apiKey = apiKey;
    }
    _getResultFromResultCounts(resultCounts) {
        const { failed, passed, skipped, timedOut } = resultCounts;
        if (failed > 0) {
            return "failed";
        }
        else if (timedOut > 0) {
            return "timedOut";
        }
        else if (passed > 0) {
            return "passed";
        }
        else if (skipped > 0) {
            return "skipped";
        }
        else {
            return "unknown";
        }
    }
    _summarizeResults(tests) {
        let approximateDuration = 0;
        let resultCounts = {
            failed: 0,
            passed: 0,
            skipped: 0,
            timedOut: 0,
            unknown: 0,
        };
        const testsById = {};
        tests.forEach(test => {
            if (!testsById[test.id] || test.attempt > testsById[test.id].attempt) {
                testsById[test.id] = test;
            }
        });
        Object.values(testsById).forEach(t => {
            approximateDuration += t.approximateDuration || 0;
            switch (t.result) {
                case "failed":
                    resultCounts.failed++;
                    break;
                case "passed":
                    resultCounts.passed++;
                    break;
                case "skipped":
                    resultCounts.skipped++;
                    break;
                case "timedOut":
                    resultCounts.timedOut++;
                    break;
                default:
                    resultCounts.unknown++;
            }
        });
        return { approximateDuration, resultCounts };
    }
    _parseConfig(config = {}, metadataKey) {
        this._apiKey = config.apiKey || process.env.REPLAY_API_KEY || process.env.RECORD_REPLAY_API_KEY;
        this._upload = "upload" in config ? !!config.upload : !!process.env.REPLAY_UPLOAD;
        if (this._upload && !this._apiKey) {
            throw new Error(`\`@replayio/${this._runner.name}/reporter\` requires an API key to upload recordings. Either pass a value to the apiKey plugin configuration or set the REPLAY_API_KEY environment variable`);
        }
        if (this._upload) {
            if (typeof config.upload === "object") {
                this._minimizeUploads = !!config.upload.minimizeUploads;
                this._uploadStatusThreshold = config.upload.statusThreshold ?? "all";
            }
            else {
                this._uploadStatusThreshold = "all";
            }
        }
        // always favor environment variables over config so the config can be
        // overwritten at runtime
        this._runTitle =
            process.env.REPLAY_METADATA_TEST_RUN_TITLE ||
                process.env.RECORD_REPLAY_TEST_RUN_TITLE ||
                process.env.RECORD_REPLAY_METADATA_TEST_RUN_TITLE ||
                config.runTitle ||
                getFallbackRunTitle();
        this._filter = config.filter;
        // RECORD_REPLAY_METADATA is our "standard" metadata environment variable.
        // We suppress it for the browser process so we can use
        // RECORD_REPLAY_METADATA_FILE but can still use the metadata here which
        // runs in the test runner process. However, test runners may have a
        // convention for reporter-specific environment configuration which should
        // supersede this.
        if (metadataKey && process.env[metadataKey] && process.env.RECORD_REPLAY_METADATA) {
            console.warn(`Cannot set metadata via both RECORD_REPLAY_METADATA and ${metadataKey}. Using ${metadataKey}.`);
        }
        const baseMetadata = (metadataKey && process.env[metadataKey]) ||
            process.env.RECORD_REPLAY_METADATA ||
            config.metadata ||
            null;
        if (baseMetadata) {
            // Since we support either a string in an environment variable or an
            // object in the cfg, we need to parse out the string value. Technically,
            // you could use a string in the config file too but that'd be unexpected.
            // Nonetheless, it'll be handled correctly here if you're into that sort
            // of thing.
            if (typeof baseMetadata === "string") {
                try {
                    this._baseMetadata = JSON.parse(baseMetadata);
                }
                catch {
                    console.warn("Failed to parse Replay metadata");
                }
            }
            else {
                this._baseMetadata = baseMetadata;
            }
        }
    }
    addError(err) {
        if (err.name === "ReporterError") {
            this._errors.push(err);
        }
        else {
            this._errors.push(new ReporterError(-1, "Unexpected error", err));
        }
    }
    setDiagnosticMetadata(metadata) {
        this._baseMetadata = {
            ...this._baseMetadata,
            "x-replay-diagnostics": metadata,
        };
    }
    onTestSuiteBegin(config, metadataKey) {
        if (config || metadataKey) {
            this._parseConfig(config, metadataKey);
        }
        debug("onTestSuiteBegin: Reporter Configuration: %o", {
            baseId: this._baseId,
            runTitle: this._runTitle,
            runner: this._runner,
            baseMetadata: this._baseMetadata,
            upload: this._upload,
            hasApiKey: !!this._apiKey,
            hasFilter: !!this._filter,
        });
        if (!this._apiKey) {
            debug("Skipping starting test run: API key not set");
            return;
        }
        if (this._testRunShardIdPromise) {
            return;
        }
        this._testRunShardIdPromise = this._startTestRunShard();
        this._pendingWork.push(this._testRunShardIdPromise);
    }
    async _startTestRunShard() {
        let metadata = {};
        try {
            metadata = await metadata_1.source.init();
        }
        catch (e) {
            debug("Failed to initialize source metadata to create test run shard: %s", e instanceof Error ? e.message : e);
        }
        const { REPLAY_METADATA_TEST_RUN_MODE, RECORD_REPLAY_METADATA_TEST_RUN_MODE } = process.env;
        const testRun = {
            runnerName: this._runner.name,
            runnerVersion: this._runner.version,
            repository: metadata.source?.repository ?? null,
            title: this._runTitle ?? null,
            mode: REPLAY_METADATA_TEST_RUN_MODE ?? RECORD_REPLAY_METADATA_TEST_RUN_MODE ?? null,
            branch: metadata.source?.branch ?? null,
            pullRequestId: metadata.source?.merge?.id ?? null,
            pullRequestTitle: metadata.source?.merge?.title ?? null,
            commitId: metadata.source?.commit?.id ?? null,
            commitTitle: metadata.source?.commit?.title ?? null,
            commitUser: metadata.source?.commit?.user ?? null,
            triggerUrl: metadata.source?.trigger?.url ?? null,
            triggerUser: metadata.source?.trigger?.user ?? null,
            triggerReason: metadata.source?.trigger?.workflow ?? null,
        };
        debug("Creating test run shard for user-key %s", this._baseId);
        try {
            return (0, replay_1.exponentialBackoffRetry)(async () => {
                const resp = await (0, replay_1.query)("CreateTestRunShard", `
          mutation CreateTestRunShard($clientKey: String!, $testRun: TestRunShardInput!) {
            startTestRunShard(input: {
              clientKey: $clientKey,
              testRun: $testRun
            }) {
              success
              testRunShardId
            }
          }
        `, {
                    clientKey: this._baseId,
                    testRun,
                }, this._apiKey);
                if (resp.errors) {
                    throwGraphqlErrors("CreateTestRunShard", resp.errors);
                }
                const testRunShardId = resp.data.startTestRunShard.testRunShardId;
                if (!testRunShardId) {
                    return {
                        type: "test-run",
                        error: new Error("Unexpected error retrieving test run shard id"),
                    };
                }
                debug("Created test run shard %s for user key %s", testRunShardId, this._baseId);
                this._testRunShardId = testRunShardId;
                return {
                    type: "test-run",
                    id: testRunShardId,
                    phase: "start",
                };
            });
        }
        catch (e) {
            debug("start test run error: %s", e);
            return {
                type: "test-run",
                error: new Error(`Unexpected error starting test run shard: ${getErrorMessage(e)}`),
            };
        }
    }
    async _addTestsToShard(tests) {
        let testRunShardId = this._testRunShardId;
        if (!testRunShardId) {
            await this._testRunShardIdPromise;
            testRunShardId = this._testRunShardId;
            if (!testRunShardId) {
                return {
                    type: "test-run-tests",
                    error: new Error("Unable to add tests to test run: ID not set"),
                };
            }
        }
        debug("Adding %d tests to shard %s", tests.length, testRunShardId);
        try {
            await (0, replay_1.exponentialBackoffRetry)(async () => {
                const resp = await (0, replay_1.query)("AddTestsToShard", `
          mutation AddTestsToShard($testRunShardId: String!, $tests: [TestRunTestInputType!]!) {
            addTestsToShard(input: {
              testRunShardId: $testRunShardId,
              tests: $tests
            }) {
              success
            }
          }
        `, {
                    testRunShardId,
                    tests,
                }, this._apiKey);
                if (resp.errors) {
                    throwGraphqlErrors("AddTestsToShard", resp.errors);
                }
            });
            debug("Successfully added tests to shard %s", testRunShardId);
            return {
                type: "test-run-tests",
            };
        }
        catch (e) {
            debug("Add tests to run error: %s", e);
            return {
                type: "test-run-tests",
                error: new Error(`Unexpected error adding tests to run: ${getErrorMessage(e)}`),
            };
        }
    }
    async _completeTestRunShard() {
        let testRunShardId = this._testRunShardId;
        if (!testRunShardId) {
            await this._testRunShardIdPromise;
            testRunShardId = this._testRunShardId;
            if (!testRunShardId) {
                return {
                    type: "test-run",
                    error: new Error("Unable to complete test run: ID not set"),
                };
            }
        }
        debug("Marking test run shard %s complete", testRunShardId);
        try {
            await (0, replay_1.exponentialBackoffRetry)(async () => {
                const resp = await (0, replay_1.query)("CompleteTestRunShard", `
        mutation CompleteTestRunShard($testRunShardId: String!) {
          completeTestRunShard(input: {
            testRunShardId: $testRunShardId
          }) {
            success
          }
        }
      `, {
                    testRunShardId,
                }, this._apiKey);
                if (resp.errors) {
                    throwGraphqlErrors("CompleteTestRunShard", resp.errors);
                }
            });
            debug("Successfully marked test run shard %s complete", testRunShardId);
            return {
                type: "test-run",
                id: testRunShardId,
                phase: "complete",
            };
        }
        catch (e) {
            debug("complete test run shard error: %s", e);
            return {
                type: "test-run",
                error: new Error(`Unexpected error completing test run shard: ${getErrorMessage(e)}`),
            };
        }
    }
    onTestBegin(testExecutionId, metadataFilePath = (0, metadata_2.getMetadataFilePath)("REPLAY_TEST", 0)) {
        debug("onTestBegin: %o", testExecutionId);
        this._errors = [];
        const metadata = {
            ...(this._baseMetadata || {}),
            "x-replay-test": {
                id: testExecutionId ? `${this._baseId}-${testExecutionId}` : this._baseId,
            },
        };
        debug("onTestBegin: Writing metadata to %s: %o", metadataFilePath, metadata);
        try {
            (0, fs_1.mkdirSync)((0, path_1.dirname)(metadataFilePath), { recursive: true });
            (0, fs_1.writeFileSync)(metadataFilePath, JSON.stringify(metadata, undefined, 2), {});
        }
        catch (e) {
            (0, logging_1.warn)("Failed to initialize Replay metadata", e);
        }
    }
    onTestEnd({ tests, specFile, replayTitle, extraMetadata, runnerGroupKey, }) {
        debug("onTestEnd: %s", specFile);
        // if we bailed building test metadata because of a crash or because no
        // tests ran, we can bail here too
        if (tests.length === 0) {
            debug("onTestEnd: No tests found");
            return;
        }
        this._pendingWork.push(this._enqueuePostTestWork(tests, specFile, runnerGroupKey, replayTitle, extraMetadata));
    }
    async _uploadRecording(recording) {
        // Cypress retries are on the same recordings, we only want to upload a single recording once
        if (this._uploadedRecordings.has(recording.id)) {
            debug("Recording %s was already scheduled to be uploaded", recording.id);
            return;
        }
        this._uploadedRecordings.add(recording.id);
        debug("Starting upload of %s", recording.id);
        try {
            await (0, replay_1.uploadRecording)(recording.id, {
                apiKey: this._apiKey,
                // Per TT-941, we want to throw on any error so it can be caught below
                // and reported back to the user rather than just returning null
                strict: true,
                // uploads are enqueued in this reporter asap
                // but the extra assets should be removed after all of them are uploaded
                removeAssets: false,
            });
            debug("Successfully uploaded %s", recording.id);
            const recordings = (0, replay_1.listAllRecordings)({ filter: r => r.id === recording.id, all: true });
            return {
                type: "upload",
                recording: recordings[0],
            };
        }
        catch (e) {
            debug("upload error: %s", e);
            return {
                type: "upload",
                recording,
                error: new Error(getErrorMessage(e)),
            };
        }
    }
    getRecordingsForTest(tests) {
        const filter = `function($v) { $v.metadata.\`x-replay-test\`.id in ${JSON.stringify([
            ...tests.map(test => `${this._baseId}-${test.executionId}`),
            this._baseId,
        ])} and $not($exists($v.metadata.test)) }`;
        const recordings = (0, replay_1.listAllRecordings)({
            all: false,
            filter,
        });
        debug("Found %d recs with filter %s", recordings.length, filter);
        return recordings;
    }
    _buildTestMetadata(tests, specFile) {
        const test = tests[0];
        const { approximateDuration, resultCounts } = this._summarizeResults(tests);
        const result = this._getResultFromResultCounts(resultCounts);
        const source = {
            path: specFile,
            title: test.source.title,
        };
        const metadata = {
            approximateDuration,
            source,
            result,
            resultCounts,
            run: {
                id: this._baseId,
                title: this._runTitle,
            },
            tests,
            environment: {
                errors: this._errors.map(e => e.valueOf()),
                pluginVersion: this._runner.plugin,
                testRunner: {
                    name: this._runner.name,
                    version: this._runner.version || "unknown",
                },
            },
            schemaVersion: this._schemaVersion,
        };
        return metadata;
    }
    async _setRecordingMetadata(recordings, testRun, replayTitle, extraMetadata) {
        debug("setRecordingMetadata: Adding test metadata to %o", recordings.map(r => r.id));
        debug("setRecordingMetadata: Includes %s errors", this._errors.length);
        const validatedTestMetadata = metadata_1.test.init({
            ...testRun,
            schemaVersion: this._schemaVersion,
        });
        let mergedMetadata = {
            title: replayTitle || testRun.source.title,
            ...extraMetadata,
            ...validatedTestMetadata,
        };
        try {
            const validatedSourceMetadata = await metadata_1.source.init();
            mergedMetadata = {
                ...mergedMetadata,
                ...validatedSourceMetadata,
            };
        }
        catch (e) {
            debug("Failed to generate source metadata: %s", e instanceof Error ? e.message : e);
        }
        recordings.forEach(rec => (0, metadata_1.add)(rec.id, mergedMetadata));
        // Re-fetch recordings so we have the most recent metadata
        const allRecordings = (0, replay_1.listAllRecordings)({ all: true });
        return allRecordings.filter(recordingWithMetadata => recordings.some(r => r.id === recordingWithMetadata.id));
    }
    async _enqueuePostTestWork(tests, specFile, runnerGroupKey, replayTitle, extraMetadata) {
        try {
            const runnerGroupId = runnerGroupKey ? (0, testId_1.generateOpaqueId)(runnerGroupKey) : null;
            const recordings = this.getRecordingsForTest(tests);
            const recordingIds = recordings.map(r => r.id);
            const testInputs = tests.map(t => {
                const testId = (0, testId_1.buildTestId)(specFile, t);
                if (!testId) {
                    throw new Error("Failed to generate test id for test");
                }
                return {
                    testId,
                    runnerGroupId: runnerGroupId,
                    index: t.id,
                    attempt: t.attempt,
                    scope: t.source.scope,
                    title: t.source.title,
                    sourcePath: specFile,
                    result: t.result,
                    error: t.error ? t.error.message : null,
                    duration: t.approximateDuration,
                    recordingIds,
                };
            });
            if (this._apiKey) {
                this._pendingWork.push(this._addTestsToShard(testInputs));
            }
            else {
                debug("Skipping adding tests to test run: API key not set");
            }
            const testRun = this._buildTestMetadata(tests, specFile);
            if (recordings.length > 0) {
                const recordingsWithMetadata = await this._setRecordingMetadata(recordings, testRun, replayTitle, extraMetadata);
                this._storeUploadableTestResults(tests.map(test => {
                    return {
                        executionGroupId: test.executionGroupId,
                        attempt: test.attempt,
                        maxAttempts: test.maxAttempts,
                        recordings: recordingsWithMetadata,
                        result: test.result,
                        testId: (0, testId_1.buildTestId)(specFile, test),
                    };
                }));
            }
            const firstRecording = recordings[0];
            (0, metrics_1.pingTestMetrics)(firstRecording?.id, this._baseId, {
                id: testRun.source.path + "#" + testRun.source.title,
                source: testRun.source,
                approximateDuration: testRun.approximateDuration,
                recorded: firstRecording !== undefined,
                runtime: parseRuntime(firstRecording?.runtime),
                runner: this._runner.name,
                result: testRun.result,
            }, this._apiKey);
            return {
                type: "post-test",
                recordings,
                testRun,
            };
        }
        catch (e) {
            debug("post-test error: %s", e);
            return {
                type: "post-test",
                error: new Error(`Error setting metadata and uploading replays: ${getErrorMessage(e)}`),
            };
        }
    }
    _storeUploadableTestResults(results) {
        if (this._uploadStatusThreshold === "none") {
            return;
        }
        for (const result of results) {
            if (result.result === "skipped") {
                continue;
            }
            let uploadableResults = this._uploadableResults.get(result.testId);
            if (!uploadableResults) {
                uploadableResults = {
                    executions: {},
                    aggregateStatus: undefined,
                    didUploadStatuses: {
                        passed: false,
                        failed: false,
                    },
                };
                this._uploadableResults.set(result.testId, uploadableResults);
            }
            let executions = uploadableResults.executions[result.executionGroupId];
            if (!executions) {
                executions = [];
                uploadableResults.executions[result.executionGroupId] = executions;
            }
            executions.push(result);
            if (result.result === "passed" || result.attempt >= result.maxAttempts) {
                this._enqueueUploads(uploadableResults, result.executionGroupId);
            }
        }
    }
    _enqueueUploads(result, executionGroupId) {
        if (this._uploadStatusThreshold === "none") {
            return;
        }
        const executions = result.executions[executionGroupId];
        const latestExecution = last(executions);
        (0, strict_1.default)(!!latestExecution, "Expected at least one execution in the list");
        let toUpload = [];
        const aggregateStatus = this._assignAggregateStatus(result, executions);
        switch (aggregateStatus) {
            case "failed": {
                if (!this._minimizeUploads) {
                    result.didUploadStatuses.failed = true;
                    toUpload.push(...executions);
                    break;
                }
                if (result.didUploadStatuses.failed) {
                    break;
                }
                result.didUploadStatuses.failed = true;
                toUpload.push(latestExecution);
                break;
            }
            case "flaky": {
                if (this._uploadStatusThreshold === "failed") {
                    break;
                }
                if (!this._minimizeUploads) {
                    result.didUploadStatuses.failed ||= executions.some(r => r.result !== "passed");
                    result.didUploadStatuses.passed ||= executions.some(r => r.result === "passed");
                    // currently previously completed execution groups that could be entirely passed or failed are not retroactively uploaded here
                    toUpload.push(...executions);
                    // fallthrough so we don't miss the other status when the flake was detected across different execution groups
                }
                if (!result.didUploadStatuses.failed) {
                    const failedExecution = Object.values(result.executions)
                        .flatMap(e => e)
                        .find(r => r.result !== "passed");
                    if (failedExecution) {
                        result.didUploadStatuses.failed = true;
                        toUpload.push(failedExecution);
                    }
                }
                if (!result.didUploadStatuses.passed) {
                    const passedExecution = Object.values(result.executions)
                        .flatMap(e => e)
                        .find(r => r.result === "passed");
                    if (passedExecution) {
                        result.didUploadStatuses.failed = true;
                        toUpload.push(passedExecution);
                    }
                }
                break;
            }
            case "passed": {
                if (this._uploadStatusThreshold !== "all") {
                    break;
                }
                if (!this._minimizeUploads) {
                    result.didUploadStatuses.passed = true;
                    toUpload.push(...executions);
                    break;
                }
                if (result.didUploadStatuses.passed) {
                    break;
                }
                result.didUploadStatuses.passed = true;
                toUpload.push(latestExecution);
                break;
            }
        }
        this._pendingWork.push(...toUpload
            .flatMap(result => result.recordings)
            .filter(r => (this._filter ? this._filter(r) : true))
            .map(r => this._uploadRecording(r)));
    }
    _assignAggregateStatus(result, newExecutions) {
        if (!result.aggregateStatus) {
            const latestExecution = last(newExecutions);
            (0, strict_1.default)(latestExecution, "Expected at least one execution in the list");
            result.aggregateStatus =
                latestExecution.result !== "passed"
                    ? "failed"
                    : newExecutions.length > 1
                        ? "flaky"
                        : "passed";
            return result.aggregateStatus;
        }
        switch (result.aggregateStatus) {
            case "passed":
                if (newExecutions.some(r => r.result !== "passed")) {
                    result.aggregateStatus = "flaky";
                }
                return result.aggregateStatus;
            case "failed":
                if (newExecutions.some(r => r.result === "passed")) {
                    result.aggregateStatus = "flaky";
                }
                return result.aggregateStatus;
            case "flaky":
                return result.aggregateStatus;
        }
    }
    async onEnd() {
        debug("onEnd");
        const output = [];
        let completedWork = [];
        if (this._pendingWork.length) {
            (0, logging_1.log)("🕑 Completing some outstanding work ...");
        }
        while (this._pendingWork.length) {
            const pendingWork = this._pendingWork;
            debug("Outstanding tasks: %d", pendingWork.length);
            this._pendingWork = [];
            completedWork.push(...(await Promise.allSettled(pendingWork)));
        }
        if (this._apiKey) {
            const postSettledWork = await Promise.allSettled([this._completeTestRunShard()]);
            completedWork.push(...postSettledWork);
        }
        else {
            debug("Skipping completing test run: API Key not set");
        }
        const failures = completedWork.filter((r) => r.status === "rejected");
        if (failures.length > 0) {
            output.push("Encountered unexpected errors while processing replays");
            failures.forEach(f => output.push(`  ${f.reason}`));
        }
        const results = completedWork
            .filter((r) => r.status === "fulfilled" && !!r.value)
            .map(r => r.value);
        const errors = {
            "post-test": [],
            "test-run": [],
            "test-run-tests": [],
            upload: [],
        };
        let uploads = [];
        for (const r of results) {
            if ("error" in r) {
                errors[r.type].push(r);
            }
            else {
                if (r.type === "upload") {
                    uploads.push(r.recording);
                }
            }
        }
        if (errors["post-test"].length > 0) {
            output.push(`\n❌ We encountered some unexpected errors processing your recordings`);
            output.push(...logPendingWorkErrors(errors["post-test"]));
        }
        if (errors["test-run-tests"].length > 0 || errors["test-run"].length > 0) {
            output.push("\n❌ We encountered some unexpected errors creating your tests on replay.io");
            output.push(...logPendingWorkErrors(errors["test-run-tests"]));
            output.push(...logPendingWorkErrors(errors["test-run"]));
        }
        if (errors["upload"].length > 0) {
            output.push(`\n❌ Failed to upload ${errors["upload"].length} recordings:\n`);
            errors["upload"].forEach(err => {
                if ("recording" in err) {
                    const r = err.recording;
                    output.push(`   ${r.metadata.title || "Unknown"}`);
                    output.push(`      ${getErrorMessage(err.error)}\n`);
                }
            });
        }
        if (uploads.length > 0) {
            const recordingIds = uploads.map(u => u.recordingId).filter(isNonNullable);
            for (const recordingId of recordingIds) {
                (0, replay_1.removeRecording)(recordingId);
            }
            const uploaded = uploads.filter(u => u.status === "uploaded");
            const crashed = uploads.filter(u => u.status === "crashUploaded");
            if (uploaded.length > 0) {
                output.push(`\n🚀 Successfully uploaded ${uploads.length} recordings:\n`);
                const sortedUploads = sortRecordingsByResult(uploads);
                sortedUploads.forEach(r => {
                    output.push(`   ${getTestResultEmoji(r)} ${r.metadata.title || "Unknown"}`);
                    output.push(`      ${process.env.REPLAY_VIEW_HOST || "https://app.replay.io"}/recording/${r.id}\n`);
                });
            }
            if (crashed.length > 0) {
                output.push(`\n❗️ ${crashed.length} crash reports were generated for tests that crashed while recording.\n`);
                output.push(`  The Replay team has been notified.`);
            }
        }
        (0, logging_1.log)(output.join("\n"));
        return results;
    }
}
exports.default = ReplayReporter;
//# sourceMappingURL=reporter.js.map