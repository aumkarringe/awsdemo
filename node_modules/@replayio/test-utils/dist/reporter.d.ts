import { RecordingEntry } from "@replayio/replay";
import type { TestMetadataV1, TestMetadataV2 } from "@replayio/replay/metadata/test";
import { UnstructuredMetadata } from "@replayio/replay";
export type UploadStatusThreshold = "all" | "failed-and-flaky" | "failed";
export type UploadOption = boolean | {
    /**
     * Minimize the number of recordings uploaded for a test attempt (within a shard).
     * e.g. Only one recording would be uploaded for a failing test attempt, regardless of retries.
     * e.g. Two recordings would be uploaded for a flaky test attempt (the passing test and one of the failures).
     */
    minimizeUploads?: boolean;
    statusThreshold?: UploadStatusThreshold;
};
export interface ReplayReporterConfig<TRecordingMetadata extends UnstructuredMetadata = UnstructuredMetadata> {
    runTitle?: string;
    metadata?: Record<string, any> | string;
    metadataKey?: string;
    upload?: UploadOption;
    apiKey?: string;
    /** @deprecated Use `upload.minimizeUploads` and `upload.statusThreshold` instead */
    filter?: (r: RecordingEntry<TRecordingMetadata>) => boolean;
}
export interface TestRunner {
    name: string;
    version: string | undefined;
    plugin: string;
}
type UserActionEvent = TestMetadataV2.UserActionEvent;
type Test = TestMetadataV2.Test;
type TestResult = TestMetadataV2.TestResult;
type TestError = TestMetadataV2.TestError;
type TestRun = TestMetadataV2.TestRun;
type PendingWorkType = "test-run" | "test-run-tests" | "post-test" | "upload";
export type PendingWorkError<K extends PendingWorkType, TErrorData = {}> = TErrorData & {
    type: K;
    error: Error;
};
export type PendingUploadError = Extract<UploadPendingWork, {
    error: {};
}>;
type PendingWorkEntry<TType extends PendingWorkType, TSuccessData = {}, TErrorData = {}> = PendingWorkError<TType, TErrorData> | (TSuccessData & {
    type: TType;
    error?: never;
});
type TestRunPendingWork = PendingWorkEntry<"test-run", {
    id: string;
    phase: "start" | "complete";
}>;
type TestRunTestsPendingWork = PendingWorkEntry<"test-run-tests">;
type UploadPendingWork = PendingWorkEntry<"upload", {
    recording: RecordingEntry;
}, {
    recording: RecordingEntry;
}>;
type PostTestPendingWork = PendingWorkEntry<"post-test", {
    recordings: RecordingEntry[];
    testRun: TestRun;
}>;
type PendingWork = TestRunPendingWork | TestRunTestsPendingWork | UploadPendingWork | PostTestPendingWork;
export declare class ReporterError extends Error {
    code: number;
    detail: any;
    constructor(code: number, message: string, detail?: any);
    valueOf(): {
        code: number;
        name: string;
        message: string;
        detail: any;
    };
}
declare class ReplayReporter<TRecordingMetadata extends UnstructuredMetadata = UnstructuredMetadata> {
    private _baseId;
    private _testRunShardId;
    private _baseMetadata;
    private _schemaVersion;
    private _runTitle?;
    private _runner;
    private _errors;
    private _apiKey?;
    private _pendingWork;
    private _upload;
    private _filter?;
    private _minimizeUploads;
    private _uploadableResults;
    private _testRunShardIdPromise;
    private _uploadStatusThreshold;
    private _uploadedRecordings;
    constructor(runner: TestRunner, schemaVersion: string, config?: ReplayReporterConfig<TRecordingMetadata>);
    setTestRunnerVersion(version: TestRunner["version"]): void;
    setApiKey(apiKey: string): void;
    private _getResultFromResultCounts;
    private _summarizeResults;
    private _parseConfig;
    addError(err: Error | ReporterError): void;
    setDiagnosticMetadata(metadata: Record<string, unknown>): void;
    onTestSuiteBegin(config?: ReplayReporterConfig<TRecordingMetadata>, metadataKey?: string): void;
    private _startTestRunShard;
    private _addTestsToShard;
    private _completeTestRunShard;
    onTestBegin(testExecutionId?: string, metadataFilePath?: string): void;
    onTestEnd({ tests, specFile, replayTitle, extraMetadata, runnerGroupKey, }: {
        tests: Test[];
        specFile: string;
        replayTitle?: string;
        extraMetadata?: Record<string, unknown>;
        runnerGroupKey?: string;
    }): void;
    private _uploadRecording;
    getRecordingsForTest(tests: {
        executionId: string;
    }[]): import("@replayio/replay").ExternalRecordingEntry[];
    private _buildTestMetadata;
    private _setRecordingMetadata;
    private _enqueuePostTestWork;
    private _storeUploadableTestResults;
    private _enqueueUploads;
    private _assignAggregateStatus;
    onEnd(): Promise<PendingWork[]>;
}
export default ReplayReporter;
export type { Test, TestError, TestMetadataV1, TestMetadataV2, TestResult, UserActionEvent };
//# sourceMappingURL=reporter.d.ts.map