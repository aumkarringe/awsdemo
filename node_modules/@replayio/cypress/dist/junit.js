"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateJUnitReports = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const txml_1 = require("txml");
const fs_2 = require("fs");
const test_utils_1 = require("@replayio/test-utils");
const debug = (0, debug_1.default)("replay:cypress:junit");
// #region Filesystem Ops
const gFileCache = new Map();
function readXmlFile(path) {
    if (gFileCache.has(path)) {
        return gFileCache.get(path);
    }
    try {
        debug("Reading %s", path);
        const contents = (0, fs_2.readFileSync)(path, "utf-8");
        debug("Read %d bytes from %s", contents.length, path);
        const dom = (0, txml_1.xml)(contents, { setPos: false, noChildNodes: ["?xml"] });
        gFileCache.set(path, dom);
        return dom;
    }
    catch (e) {
        (0, test_utils_1.warn)("[junit] Failed to read and parse reporter file", e);
    }
}
function writeOutputFile(dom, outputFile) {
    try {
        const updatedContents = dom
            .filter(isNode)
            .map(n => {
            let str = (0, txml_1.stringify)([n]);
            if (n.tagName.startsWith("?")) {
                // replace ></?xml> with ?>
                str = str.replace(new RegExp(`></\\${n.tagName}>`), "?>");
            }
            return str;
        })
            .join("\n");
        (0, fs_2.writeFileSync)(outputFile, updatedContents, "utf-8");
    }
    catch (e) {
        (0, test_utils_1.warn)("[junit] Failed to update reporter file", e);
    }
}
// #endregion
// #region XML Utilities
function findDescendentsByTagName(node, tagName, matches = []) {
    node.children.filter(isNode).forEach(c => {
        if (c.tagName === tagName) {
            matches.push(c);
        }
        findDescendentsByTagName(c, tagName, matches);
    });
    return matches;
}
function isNode(n) {
    return !!n && typeof n !== "string";
}
function getTestSuitesNode(dom) {
    return dom.filter(isNode).find(n => n.tagName === "testsuites");
}
function getRootSuite(dom) {
    const ts = getTestSuitesNode(dom);
    return ts?.children.filter(isNode).find(ts => ts.attributes.name === "Root Suite");
}
// #endregion
// #region Replay mutations
function addReplayLinkProperty(node, replayUrls) {
    try {
        let properties = node.children.filter(isNode).find(c => c.tagName === "properties");
        if (!properties) {
            properties = {
                tagName: "properties",
                attributes: {},
                children: [],
            };
            node.children.push(properties);
        }
        properties.children.push(...replayUrls.map(replayUrl => ({
            tagName: "property",
            attributes: {
                name: "Replay URL",
                value: replayUrl,
            },
            children: [],
        })));
    }
    catch (e) {
        debug("Failed to add replay url to properties: %s", e);
    }
}
function escapeForXml(content) {
    return content.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;");
}
function appendReplayUrlsToFailureNodes(node, replayUrls) {
    try {
        const failures = findDescendentsByTagName(node, "failure");
        debug("Found %d failures to append replay URLs", failures.length);
        failures.forEach(failure => {
            if (typeof failure.children[0] !== "string") {
                debug("<failure> contained a node instead of an error message");
                return;
            }
            const output = `${failure.children[0]}\n\nView in Replay\n${replayUrls
                .map(url => ` * ${url}`)
                .join("\n")}`;
            failure.children[0] = escapeForXml(output);
        });
    }
    catch (e) {
        debug("Failed to add replay url to failure output: %s", e);
    }
}
// #endregion
function findOutputFileForSpec(specRelativePath, xmlFiles) {
    for (const outputFile of xmlFiles) {
        const dom = readXmlFile(outputFile);
        if (!dom) {
            continue;
        }
        const testSuites = getTestSuitesNode(dom);
        const rootSuite = getRootSuite(dom);
        if (!rootSuite || !testSuites) {
            debug("Failed to find root suite in reporter xml");
            debug(JSON.stringify(dom, undefined, 2));
            continue;
        }
        if ("file" in rootSuite.attributes && rootSuite.attributes.file === specRelativePath) {
            return { xmlFile: outputFile, dom };
        }
    }
    return { xmlFile: undefined, dom: undefined };
}
function getPotentialReporterFiles(projectBase, mochaFile) {
    const reporterOutputBase = path_1.default.dirname(path_1.default.join(projectBase, mochaFile || "./test-results.xml"));
    const allFiles = fs_1.default.readdirSync(reporterOutputBase);
    const xmlFiles = allFiles
        .filter(f => f.endsWith(".xml"))
        .map(xmlFile => path_1.default.join(reporterOutputBase, xmlFile));
    return xmlFiles;
}
function updateJUnitReports(specRelativePath, recordings, projectBase, mochaFile) {
    try {
        debug("Updating JUnit reporter output %o", {
            specRelativePath,
            recordings: recordings.map(r => r.id),
            projectBase,
            mochaFile,
        });
        if (mochaFile && typeof mochaFile !== "string") {
            (0, test_utils_1.warn)("Unsupported reporterOptions configuration", new Error("Expected string for mocha file but received " + typeof mochaFile));
            return;
        }
        const xmlFiles = getPotentialReporterFiles(projectBase, mochaFile);
        const { xmlFile, dom } = findOutputFileForSpec(specRelativePath, xmlFiles);
        if (!dom) {
            throw new Error(`Failed to find JUnit reporter output file`);
        }
        debug("Found matching root suite node for %s", specRelativePath);
        const testSuites = getTestSuitesNode(dom);
        const rootSuite = getRootSuite(dom);
        if (!rootSuite || !testSuites) {
            // We've already found these in findOutputFileForSpec but confirming here to
            // keep TS happy
            throw new Error(`Failed to find root suite or test suites nodes`);
        }
        const replayUrls = recordings.map(r => `https://app.replay.io/recording/${r.id}`);
        addReplayLinkProperty(rootSuite, replayUrls);
        appendReplayUrlsToFailureNodes(testSuites, replayUrls);
        writeOutputFile(dom, xmlFile);
    }
    catch (e) {
        (0, test_utils_1.warn)(`[junit] Unexpected reporter error  for ${specRelativePath}`, e);
    }
}
exports.updateJUnitReports = updateJUnitReports;
//# sourceMappingURL=junit.js.map