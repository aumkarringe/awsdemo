"use strict";
/// <reference types="cypress" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortSteps = exports.groupStepsByTest = exports.getTestsFromResults = exports.mapStateToResult = void 0;
const test_utils_1 = require("@replayio/test-utils");
const debug_1 = __importDefault(require("debug"));
const constants_1 = require("./constants");
const error_1 = require("./error");
const debug = (0, debug_1.default)("replay:cypress:plugin:reporter:steps");
function mapStateToResult(state) {
    switch (state) {
        case "failed":
        case "passed":
            return state;
        case "pending":
            return "skipped";
    }
    return "unknown";
}
exports.mapStateToResult = mapStateToResult;
function toEventOrder(event) {
    return ["test:start", "step:enqueue", "step:start", "step:end", "test:end"].indexOf(event.event);
}
function shouldSkipStep(step, skippedSteps) {
    const skipDebug = debug.extend("skip");
    const lastArg = step.command?.args?.[step.command.args.length - 1];
    let reason;
    if (lastArg != null && typeof lastArg === "object" && lastArg.log === false) {
        reason = "Command logging disabled";
    }
    else if (skippedSteps.includes(step.command?.id)) {
        reason = "Prior step event already skipped";
    }
    else if (skippedSteps.includes(step.command?.groupId)) {
        reason = "Parent skipped";
    }
    if (reason) {
        skipDebug("Test step %s skipped: %s", step.command?.id || "", reason);
        return true;
    }
    return false;
}
function simplifyArgs(args) {
    return args?.filter(a => !!a && typeof a !== "object").map(a => String(a)) || [];
}
function getTestsFromResults(spec, resultTests, testStartSteps) {
    const startEvents = sortSteps(testStartSteps);
    function getStartTestStep(result) {
        const startEventIndex = startEvents.findIndex(e => e.test.every((t, i) => t === result.title[i]) && e.test.length === result.title.length);
        if (startEventIndex !== -1) {
            const startEvent = startEvents.splice(startEventIndex, 1)[0];
            return startEvent;
        }
    }
    const tests = resultTests.flatMap((result, id) => {
        const scope = [...result.title];
        const title = scope.pop();
        const lastAttemptIndex = result.attempts.length - 1;
        return result.attempts.map((a, attemptIndex) => {
            const startTestStep = getStartTestStep(result);
            const attempt = attemptIndex + 1;
            return {
                id: startTestStep?.testId ?? attemptIndex,
                executionGroupId: "single",
                executionId: [spec.relative, attempt, ...scope, title].join("-"),
                // those properties don't exist since Cypress 13: https://github.com/cypress-io/cypress/pull/27230
                // TODO: remove it in PRO-640
                approximateDuration: a.duration || a.wallClockDuration || 0,
                attempt,
                maxAttempts: startTestStep?.maxAttempts ?? 1,
                source: {
                    title,
                    scope,
                },
                result: mapStateToResult(a.state),
                events: {
                    beforeAll: [],
                    afterAll: [],
                    beforeEach: [],
                    afterEach: [],
                    main: [],
                },
                // attempt.error is available here:
                // https://github.com/cypress-io/cypress/blob/61156808413be8b99264026323ce3abfb22c4c26/packages/server/lib/modes/results.ts#L20
                // but it's lost when creating a public test result:
                // https://github.com/cypress-io/cypress/blob/61156808413be8b99264026323ce3abfb22c4c26/packages/server/lib/modes/results.ts#L111
                // `.displayError` represents the error reported by the last attempt
                // for all of the previous attempts we rely on the search for the last errored step in `groupStepsByTest`
                // if an error is found there, it will be set on the test, the information set here is not overriden though
                error: attemptIndex === lastAttemptIndex && result.displayError
                    ? {
                        name: "DisplayError",
                        message: result.displayError,
                    }
                    : null,
            };
        });
    });
    debug("Found %d tests", tests.length);
    debug("%O", tests.map(t => t.source.title));
    return tests;
}
exports.getTestsFromResults = getTestsFromResults;
function sortSteps(steps) {
    // The steps can come in out of order but are sortable by timestamp
    return [...steps].sort((a, b) => a.index - b.index);
}
exports.sortSteps = sortSteps;
function isTestForStep(test, step) {
    return test.id === step.testId && test.attempt === step.attempt;
}
function groupStepsByTest(tests, steps) {
    const hooks = {
        afterAll: [],
        beforeAll: [],
    };
    const stepStack = [];
    const skippedStepIds = [];
    // steps are grouped by `chainerId` and then assigned a parent here by
    // tracking the most recent groupId
    let activeGroup;
    let currentTest;
    for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        const testForStep = tests.find(t => isTestForStep(t, step));
        if (currentTest !== testForStep) {
            activeGroup = undefined;
        }
        currentTest = testForStep;
        debug("Processing %s event: %o", step.event, step);
        try {
            switch (step.event) {
                case "step:enqueue":
                    // ignore for now ...
                    break;
                case "step:start":
                    let parentId;
                    if (shouldSkipStep(step, skippedStepIds)) {
                        if (step.command?.id) {
                            skippedStepIds.push(step.command.id);
                        }
                        if (step.command?.groupId) {
                            skippedStepIds.push(step.command.groupId);
                        }
                        break;
                    }
                    if (activeGroup && activeGroup.groupId === step.command?.groupId) {
                        parentId = activeGroup.parentId;
                    }
                    else if (step.command?.groupId) {
                        activeGroup = { groupId: step.command.groupId, parentId: step.command.id };
                    }
                    // Simplify args to avoid sending large objects in metadata that we
                    // won't render in the UI anyway
                    const args = simplifyArgs(step.command?.args);
                    const testStep = {
                        data: {
                            id: step.command.id,
                            parentId: parentId || null,
                            category: step.category || "other",
                            command: {
                                name: step.command.name,
                                arguments: args,
                            },
                            scope: step.test.slice(0, -1),
                            error: null,
                        },
                    };
                    stepStack.push({ event: step, step: testStep });
                    // accumulate beforeAll/afterAll commands so they can be distributed
                    // to all tests later
                    if (step.hook && (step.hook === "beforeAll" || step.hook === "afterAll")) {
                        hooks[step.hook].push(testStep);
                        continue;
                    }
                    (0, error_1.assertCurrentTest)(currentTest, step);
                    currentTest.events[step.hook || "main"].push(testStep);
                    break;
                case "step:end":
                    const isAssert = step.command.name === "assert";
                    const lastStep = stepStack.find(a => a.step.data.id === step.command.id &&
                        a.event.test.toString() === step.test.toString());
                    if (!lastStep && skippedStepIds.includes(step.command?.id)) {
                        // ignore step:ends for skipped steps
                        break;
                    }
                    // TODO [ryanjduffy]: Skipping handling after each events for now
                    if (step.test[0] === constants_1.AFTER_EACH_HOOK) {
                        debug("After each hooks are not currently supported");
                        continue;
                    }
                    (0, error_1.assertMatchingStep)(step, lastStep?.event);
                    // asserts can change the args if the message changes
                    if (isAssert && step.command) {
                        lastStep.step.data.command.arguments = simplifyArgs(step.command.args);
                    }
                    // Always set the error so that a successful retry will clear a previous error
                    const currentTestStep = lastStep.step;
                    currentTestStep.data.error = step.error || null;
                    break;
                case "test:end":
                    (0, error_1.assertCurrentTest)(currentTest, step);
                    break;
            }
        }
        catch (e) {
            if ((0, error_1.isStepAssertionError)(e)) {
                throw new test_utils_1.ReporterError(e.code, e.message, e.step);
            }
            else {
                throw new test_utils_1.ReporterError(error_1.Errors.UnexpectedError, "Unexpected step processing error", e);
            }
        }
    }
    // Distribute beforeAll/afterAll hook commands to each test
    const hookNames = Object.keys(hooks);
    hookNames.forEach(hookName => {
        const hookActions = hooks[hookName];
        hookActions.forEach(action => {
            tests.forEach(test => {
                if (action.data.scope.every((scope, i) => scope === test.source.scope[i])) {
                    test.events[hookName].push(action);
                }
            });
        });
    });
    tests.forEach(test => {
        // If a test fails in the beforeAll hook phase, Cypress will mark the first
        // test as failed and the rest as unknown. For consistency, try to detect this
        // first case and set it to unknown as well.
        if (test.result === "failed" && test.events.main.length === 0) {
            if (!steps.some(s => s.event === "test:start" && isTestForStep(test, s))) {
                test.result = "unknown";
            }
        }
        // Cypress doesn't always bubble up step errors to the test so if a test
        // failed and it is missing an error, we find the last error and set that on
        // the test
        if (test.result === "failed" && test.error == null) {
            const phases = [
                "afterAll",
                "afterEach",
                "main",
                "beforeEach",
                "beforeAll",
            ];
            for (const phase of phases) {
                const stepWithError = test.events[phase].findLast(step => !!step.data.error);
                if (stepWithError) {
                    test.error = stepWithError.data.error;
                    break;
                }
            }
        }
    });
    return tests;
}
exports.groupStepsByTest = groupStepsByTest;
//# sourceMappingURL=steps.js.map