"use strict";
/// <reference types="cypress" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMetadataFilePath = exports.onAfterRun = exports.onAfterSpec = exports.onBeforeSpec = exports.onBeforeBrowserLaunch = exports.onBeforeRun = exports.wrapOn = exports.plugin = exports.getCypressReporter = void 0;
const semver_1 = __importDefault(require("semver"));
const replay_1 = require("@replayio/replay");
const test_utils_1 = require("@replayio/test-utils");
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const chalk_1 = __importDefault(require("chalk"));
const constants_1 = require("./constants");
const reporter_1 = __importStar(require("./reporter"));
Object.defineProperty(exports, "getMetadataFilePath", { enumerable: true, get: function () { return reporter_1.getMetadataFilePath; } });
const features_1 = require("./features");
const junit_1 = require("./junit");
const server_1 = require("./server");
const debug = (0, debug_1.default)("replay:cypress:plugin");
const debugTask = debug.extend("task");
const debugEvents = debug.extend("events");
let cypressReporter;
let missingSteps = false;
function assertReporter(reporter) {
    if (!reporter) {
        throw new Error("Plugin method called without initializing @replayio/cypress plugin");
    }
}
function loudWarning(...lines) {
    const terminalWidth = process.stdout.columns || 80;
    const packageName = "@replayio/cypress";
    const startHeaderWidth = Math.floor((terminalWidth - packageName.length) / 2 - 1);
    const endHeaderWidth = terminalWidth - startHeaderWidth - packageName.length - 2;
    console.warn("\n%s %s %s\n", "".padEnd(startHeaderWidth, "="), chalk_1.default.magentaBright(packageName), "".padEnd(endHeaderWidth, "="));
    lines.forEach(l => console.warn(l));
    console.warn("\n%s\n", "".padEnd(terminalWidth, "="));
}
function getAuthKey(config) {
    return (
    // migrating away from `RECORD_REPLAY_` to `REPLAY_`
    config.env?.REPLAY_API_KEY ||
        config.env?.RECORD_REPLAY_API_KEY ||
        process.env.REPLAY_API_KEY ||
        process.env.RECORD_REPLAY_API_KEY);
}
function updateReporters(relativePath, recordings, config) {
    const { reporter, reporterOptions } = config;
    debug("updateReporter: %o", { reporter, reporterOptions });
    if (reporter !== "junit") {
        return;
    }
    const projectBase = path_1.default.dirname(config.configFile);
    if (recordings.length === 0) {
        return;
    }
    (0, junit_1.updateJUnitReports)(relativePath, recordings, projectBase, reporterOptions?.mochaFile);
}
async function onBeforeRun(details) {
    assertReporter(cypressReporter);
    const authKey = getAuthKey(details.config);
    if (authKey) {
        await cypressReporter.authenticate(authKey);
    }
}
exports.onBeforeRun = onBeforeRun;
function onBeforeBrowserLaunch(browser, launchOptions) {
    debugEvents("Handling before:browser:launch");
    assertReporter(cypressReporter);
    cypressReporter.onLaunchBrowser(browser.family);
    debugEvents("Browser launching: %o", { family: browser.family });
    const config = cypressReporter.config;
    if (browser.name !== "electron" && config.version && semver_1.default.gte(config.version, "10.9.0")) {
        const noRecord = !!process.env.RECORD_REPLAY_NO_RECORD;
        const env = {
            ...launchOptions.env,
            RECORD_REPLAY_DRIVER: noRecord && browser.family === "chromium" ? __filename : undefined,
            RECORD_ALL_CONTENT: noRecord ? undefined : "1",
            RECORD_REPLAY_METADATA_FILE: (0, test_utils_1.initMetadataFile)((0, reporter_1.getMetadataFilePath)()),
            RECORD_REPLAY_ENABLE_ASSERTS: process.env.RECORD_REPLAY_ENABLE_ASSERTS,
            ...cypressReporter.getExtraEnv(),
        };
        debugEvents("Adding environment variables to browser: %o", env);
        launchOptions.env = env;
    }
    return launchOptions;
}
exports.onBeforeBrowserLaunch = onBeforeBrowserLaunch;
async function onAfterRun() {
    assertReporter(cypressReporter);
    const utilsPendingWork = await cypressReporter.onEnd();
    utilsPendingWork.forEach(entry => {
        if (entry.type === "post-test" && !("error" in entry)) {
            const { testRun: { tests, source: { path }, }, recordings, } = entry;
            const completedTests = tests.filter(t => ["passed", "failed", "timedOut"].includes(t.result));
            if (cypressReporter) {
                updateReporters(path, recordings, cypressReporter.config);
            }
            if (completedTests.length > 0 &&
                tests.flatMap(t => Object.values(t.events).flat()).length === 0) {
                missingSteps = true;
            }
        }
    });
    if (missingSteps) {
        loudWarning("Your tests completed but our plugin did not receive any command events.", "", `Did you remember to include ${chalk_1.default.magentaBright("@replayio/cypress/support")} in your support file?`);
    }
}
exports.onAfterRun = onAfterRun;
function onBeforeSpec(spec) {
    debugEvents("Handling before:spec %s", spec.relative);
    assertReporter(cypressReporter);
    cypressReporter.onBeforeSpec(spec);
}
exports.onBeforeSpec = onBeforeSpec;
function onAfterSpec(spec, result) {
    debugEvents("Handling after:spec %s", spec.relative);
    assertReporter(cypressReporter);
    return cypressReporter.onAfterSpec(spec, result);
}
exports.onAfterSpec = onAfterSpec;
function onReplayTask(value) {
    debugTask("Handling task: %o", value);
    assertReporter(cypressReporter);
    const reporter = cypressReporter;
    if (!Array.isArray(value))
        return;
    value.forEach(v => {
        if ((0, reporter_1.isStepEvent)(v)) {
            debugTask("Forwarding event to reporter: %o", v);
            reporter.addStep(v);
        }
        else {
            debugTask("Unexpected payload: %o", v);
        }
    });
    return true;
}
const cypressOnWrapper = (base) => {
    const handlers = {};
    const singleHandlerEvents = {
        "after:screenshot": false,
        "file:preprocessor": false,
        "dev-server:start": false,
    };
    const makeHandlerDispatcher = (e) => async (...args) => {
        if (e === "before:browser:launch") {
            let [browser, launchOptions] = args;
            for (const currentHandler of handlers[e]) {
                launchOptions = (await currentHandler(browser, launchOptions)) ?? launchOptions;
            }
            return launchOptions;
        }
        else {
            for (const currentHandler of handlers[e]) {
                await currentHandler(...args);
            }
        }
    };
    return (e, h) => {
        if (e === "task") {
            base(e, h);
            return;
        }
        if (Object.keys(singleHandlerEvents).includes(e)) {
            const key = e;
            if (singleHandlerEvents[key] === true) {
                throw new Error(`Only 1 handler allowed for ${e}`);
            }
            singleHandlerEvents[key] = true;
            base(e, h);
            return;
        }
        handlers[e] = handlers[e] || [];
        handlers[e].push(h);
        if (handlers[e].length === 1) {
            base(e, makeHandlerDispatcher(e));
        }
    };
};
exports.wrapOn = cypressOnWrapper;
const plugin = (on, config, options = {}) => {
    cypressReporter = new reporter_1.default(config, options);
    const portPromise = (0, server_1.createServer)().then(({ server: wss, port }) => {
        wss.on("connection", function connection(ws) {
            debug("Connection established");
            ws.on("close", () => {
                debug("WebSocket closed");
            });
            ws.on("error", e => {
                (0, test_utils_1.warn)("WebSocket error", e);
            });
            ws.on("message", function message(data) {
                try {
                    const payload = data.toString("utf-8");
                    const obj = JSON.parse(payload);
                    onReplayTask(obj.events);
                }
                catch (e) {
                    (0, test_utils_1.warn)("Error parsing message from test", e);
                }
            });
        });
        return port;
    });
    if (!cypressReporter.isFeatureEnabled(features_1.PluginFeature.Metrics)) {
        process.env.RECORD_REPLAY_TEST_METRICS = "0";
    }
    if (cypressReporter.isFeatureEnabled(features_1.PluginFeature.Plugin) ||
        cypressReporter.isFeatureEnabled(features_1.PluginFeature.Metrics)) {
        on("after:spec", onAfterSpec);
    }
    if (cypressReporter.isFeatureEnabled(features_1.PluginFeature.Plugin) ||
        cypressReporter.isFeatureEnabled(features_1.PluginFeature.Support)) {
        on("task", {
            [constants_1.CONNECT_TASK_NAME]: async (value) => {
                debug("Test client connecting to websocket server");
                const port = await portPromise;
                debug("Returning port %d", port);
                return { port };
            },
        });
    }
    if (cypressReporter.isFeatureEnabled(features_1.PluginFeature.Plugin)) {
        on("before:run", onBeforeRun);
        on("before:browser:launch", onBeforeBrowserLaunch);
        on("before:spec", onBeforeSpec);
        on("after:run", onAfterRun);
        // make sure we have a config object with the keys we need to mutate
        config = config || {};
        config.env = config.env || {};
        config.browsers = config.browsers || [];
        if (config.isTextTerminal) {
            config.env.NO_COMMAND_LOG =
                process.env.CYPRESS_NO_COMMAND_LOG ?? config.env.NO_COMMAND_LOG ?? 1;
            debug("Command log enabled? %s", config.env.NO_COMMAND_LOG);
        }
        const chromiumPath = (0, replay_1.getPlaywrightBrowserPath)("chromium");
        if (chromiumPath) {
            debug("Adding chromium to cypress at %s", chromiumPath);
            config.browsers = config.browsers.concat({
                name: "replay-chromium",
                channel: "stable",
                family: "chromium",
                displayName: "Replay",
                version: "108.0",
                path: chromiumPath,
                majorVersion: 108,
                isHeaded: true,
                isHeadless: false,
            });
        }
        else {
            debug("Replay Chromium not supported on this platform", chromiumPath);
        }
    }
    return config;
};
exports.plugin = plugin;
function getCypressReporter() {
    return cypressReporter;
}
exports.getCypressReporter = getCypressReporter;
exports.default = plugin;
//# sourceMappingURL=index.js.map