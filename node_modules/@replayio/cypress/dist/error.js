"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertMatchingStep = exports.assertCurrentTest = exports.isStepAssertionError = exports.StepAssertionError = exports.Errors = void 0;
var Errors;
(function (Errors) {
    Errors[Errors["UnexpectedError"] = -1] = "UnexpectedError";
    Errors[Errors["NoTestResults"] = 101] = "NoTestResults";
    Errors[Errors["MismatchedStep"] = 201] = "MismatchedStep";
    Errors[Errors["TestMissing"] = 202] = "TestMissing";
})(Errors || (exports.Errors = Errors = {}));
class StepAssertionError extends Error {
    name = "StepAssertionError";
    message;
    step;
    code;
    constructor(step, code, message) {
        super();
        this.step = step;
        this.code = code;
        this.message = message;
    }
}
exports.StepAssertionError = StepAssertionError;
function isStepAssertionError(e) {
    return e instanceof Error && e.name === "StepAssertionError";
}
exports.isStepAssertionError = isStepAssertionError;
function assertCurrentTest(currentTest, step) {
    if (!currentTest) {
        throw new StepAssertionError(step, Errors.TestMissing, "currentTest does not exist");
    }
}
exports.assertCurrentTest = assertCurrentTest;
function assertMatchingStep(currentStep, previousStep) {
    if (!currentStep ||
        !previousStep ||
        !currentStep.command ||
        !previousStep.command ||
        currentStep.command.id !== previousStep.command.id) {
        throw new StepAssertionError(currentStep, Errors.MismatchedStep, "Mismatched step event");
    }
}
exports.assertMatchingStep = assertMatchingStep;
//# sourceMappingURL=error.js.map