"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isStepEvent = exports.getMetadataFilePath = void 0;
/// <reference types="cypress" />
const test_utils_1 = require("@replayio/test-utils");
const debug_1 = __importDefault(require("debug"));
const error_1 = require("./error");
const fixture_1 = require("./fixture");
const steps_1 = require("./steps");
const features_1 = require("./features");
const debug = (0, debug_1.default)("replay:cypress:reporter");
const MAX_WAIT = 20_000;
function isStepEvent(value) {
    if (value &&
        typeof value === "object" &&
        "event" in value &&
        typeof value.event === "string" &&
        ["step:enqueue", "step:start", "step:end", "test:start", "test:end"].includes(value.event)) {
        return true;
    }
    return false;
}
exports.isStepEvent = isStepEvent;
class CypressReporter {
    config;
    options;
    reporter;
    startTime;
    steps = [];
    selectedBrowser;
    errors = [];
    featureOptions;
    _extraEnv = {};
    constructor(config, options) {
        (0, fixture_1.initFixtureFile)();
        this.config = config;
        this.options = options;
        this.reporter = new test_utils_1.ReplayReporter({
            name: "cypress",
            version: config.version,
            plugin: require("@replayio/cypress/package.json").version,
        }, "2.2.0", { ...this.options, metadataKey: "CYPRESS_REPLAY_METADATA" });
        this.featureOptions = process.env.CYPRESS_REPLAY_PLUGIN_FEATURES;
        debug("Features: %o", (0, features_1.getFeatures)(this.featureOptions));
    }
    isFeatureEnabled(feature) {
        return (0, features_1.isFeatureEnabled)(this.featureOptions, feature);
    }
    async authenticate(apiKey) {
        this.reporter.setApiKey(apiKey);
        const { env } = await (0, test_utils_1.fetchWorkspaceConfig)(apiKey);
        debug("Set extra env: %o", env);
        this._extraEnv = env;
        this.reporter.setDiagnosticMetadata(env);
    }
    onLaunchBrowser(browser) {
        this.setSelectedBrowser(browser);
        this.reporter.onTestSuiteBegin();
        // Cypress around 10.9 launches the browser before `before:spec` is called
        // causing us to fail to create the metadata file and link the replay to the
        // current test
        const metadataPath = getMetadataFilePath();
        this.reporter.onTestBegin(undefined, metadataPath);
    }
    onBeforeSpec(spec) {
        const startTime = Date.now();
        (0, fixture_1.appendToFixtureFile)("spec:start", { spec, startTime });
        this.clearSteps();
        this.reporter.onTestBegin(undefined, getMetadataFilePath());
    }
    async waitForStableStepCount() {
        let currentCount = this.getStepCount();
        const startTime = Date.now();
        while (Date.now() < startTime + MAX_WAIT) {
            debug("Waiting for stable step count: %d", currentCount);
            const previousCount = currentCount;
            await new Promise(resolve => setTimeout(resolve, 250));
            currentCount = this.getStepCount();
            if (previousCount === currentCount) {
                debug("Step count stable at %d after %s ms", Date.now() - startTime);
                break;
            }
        }
    }
    async onAfterSpec(spec, result) {
        (0, fixture_1.appendToFixtureFile)("spec:end", { spec, result });
        await this.waitForStableStepCount();
        const tests = this.getTestResults(spec, result);
        this.reporter.onTestEnd({
            tests,
            replayTitle: spec.relative,
            specFile: spec.relative,
            runnerGroupKey: spec.relative,
        });
    }
    onEnd() {
        return this.reporter.onEnd();
    }
    getExtraEnv() {
        return this._extraEnv;
    }
    setSelectedBrowser(browser) {
        this.selectedBrowser = browser;
    }
    clearSteps() {
        this.steps = [];
    }
    addStep(step) {
        (0, fixture_1.appendToFixtureFile)("task", step);
        this.steps.push(step);
    }
    getStepCount() {
        return this.steps.length;
    }
    getTestResults(spec, result) {
        const placeholderTest = {
            id: 0,
            executionGroupId: "single",
            executionId: [spec.relative, 1].join("-"),
            approximateDuration: 0,
            source: {
                title: spec.relative,
                scope: [],
            },
            result: "unknown",
            attempt: 1,
            maxAttempts: 1,
            events: {
                afterAll: [],
                afterEach: [],
                beforeAll: [],
                beforeEach: [],
                main: [],
            },
            error: null,
        };
        if (
        // If the browser crashes, no tests are run and tests will be null
        !result.tests ||
            // If the spec doesn't have any tests, we should bail
            result.tests.length === 0) {
            const msg = "No test results found for spec " + spec.relative;
            debug(msg);
            this.reporter.addError(new test_utils_1.ReporterError(error_1.Errors.NoTestResults, msg, spec.relative));
            return [
                // return an placeholder test because cypress will still launch a
                // browser for a file that matches the spec format but doesn't contain
                // any tests.
                placeholderTest,
            ];
        }
        let testsWithoutSteps = (0, steps_1.getTestsFromResults)(spec, result.tests, this.steps.filter(s => s.event === "test:start"));
        let testsWithSteps = [];
        try {
            const sortedSteps = (0, steps_1.sortSteps)(this.steps);
            testsWithSteps = (0, steps_1.groupStepsByTest)(testsWithoutSteps, sortedSteps);
        }
        catch (e) {
            console.warn("Failed to build test step metadata for this replay");
            console.warn(e);
            this.reporter.addError(e);
            // return tests without steps otherwise the test-utils reporter will bail
            // and we'll lose the error altogether.
            return testsWithoutSteps;
        }
        return testsWithSteps;
    }
}
function getMetadataFilePath(workerIndex = 0) {
    return (0, test_utils_1.getMetadataFilePath)("CYPRESS", workerIndex);
}
exports.getMetadataFilePath = getMetadataFilePath;
exports.default = CypressReporter;
//# sourceMappingURL=reporter.js.map