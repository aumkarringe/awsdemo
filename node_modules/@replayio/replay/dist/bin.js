"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sourcemap_upload_1 = require("@replayio/sourcemap-upload");
const commander_1 = require("commander");
const debug_1 = __importStar(require("./debug"));
const formatRecordings_1 = require("./cli/formatRecordings");
const main_1 = require("./main");
const utils_1 = require("./utils");
const auth_1 = require("./auth");
const launchdarkly_1 = require("./launchdarkly");
const debug = (0, debug_1.default)("replay:cli");
// Create command with global options
function commandWithGlobalOptions(cmdString) {
    return commander_1.program
        .command(cmdString)
        .option("--warn", "Terminate with a 0 exit code on error")
        .option("--directory <dir>", "Alternate recording directory")
        .option("--server <address>", "Alternate server to upload recordings to")
        .hook("preAction", (cmd) => __awaiter(this, void 0, void 0, function* () {
        try {
            yield (0, auth_1.initLDContextFromApiKey)(cmd.opts());
        }
        catch (e) {
            debug("LaunchDarkly profile is anonymous %o", e);
        }
    }));
}
// TODO(dmiller): `--json` should probably be a global option that applies to all commands.
commandWithGlobalOptions("ls")
    .description("List information about all recordings.")
    .option("-a, --all", "Include all recordings")
    .option("--json", "Output in JSON format")
    .option("--filter <filter string>", "String to filter recordings")
    .option("--include-crashes", "Always include crash reports")
    .action(commandListAllRecordings);
commandWithGlobalOptions("upload <id>")
    .description("Upload a recording to the remote server.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandUploadRecording);
commandWithGlobalOptions("launch [url]")
    .description("Launch the replay browser")
    .option("-b, --browser <browser>", "Browser to launch", "chromium")
    .option("--attach <true|false>", "Whether to attach to the browser process after launching", false)
    .allowUnknownOption()
    .action(commandLaunchBrowser);
commandWithGlobalOptions("record [url]")
    .description("Launch the replay browser and start recording")
    .option("-b, --browser <browser>", "Browser to launch", "chromium")
    .option("--browser-args <args>", "Browser arguments", "")
    .option("--attach <true|false>", "Whether to attach to the browser process after launching", false)
    .allowUnknownOption()
    .action(commandLaunchBrowserAndRecord);
commandWithGlobalOptions("process <id>")
    .description("Upload a recording to the remote server and process it.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandProcessRecording);
commandWithGlobalOptions("upload-all")
    .description("Upload all recordings to the remote server.")
    .option("--api-key <key>", "Authentication API Key")
    .option("--filter <filter string>", "String to filter recordings")
    .option("--batch-size <batchSize number>", "Number of recordings to upload in parallel (max 25)")
    .option("--include-crashes", "Always include crash reports")
    .action(commandUploadAllRecordings);
commandWithGlobalOptions("view <id>")
    .description("Load the devtools on a recording, uploading it if needed.")
    .option("--view-server <view-server>", "Alternate server to view recording from.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandViewRecording);
commandWithGlobalOptions("view-latest")
    .description("Load the devtools on the latest recording, uploading it if needed.")
    .option("--view-server <view-server>", "Alternate server to view recording from.")
    .option("--api-key <key>", "Authentication API Key")
    .action(commandViewLatestRecording);
commandWithGlobalOptions("rm <id>")
    .description("Remove a specific recording.")
    .action(commandRemoveRecording);
commandWithGlobalOptions("rm-all")
    .description("Remove all recordings.")
    .action(commandRemoveAllRecordings);
commandWithGlobalOptions("update-browsers")
    .description("Update your installed Replay runtimes. Optional argument: Comma-separated list of replay runtimes. Possible values: chromium,firefox.\n  Node not yet supported.")
    .arguments("[<browsers...>]")
    .action(commandUpdateBrowsers);
commandWithGlobalOptions("upload-sourcemaps")
    .requiredOption("-g, --group <name>", "The name to group this sourcemap into, e.g. A commit SHA or release version.")
    .option("--api-key <key>", "Authentication API Key")
    .option("--dry-run", "Perform all of the usual CLI logic, but the final sourcemap upload.")
    .option("-x, --extensions <exts>", "A comma-separated list of extensions to process. Defaults to '.js,.map'.", collectExtensions)
    .option("-i, --ignore <pattern>", "Ignore files that match this pattern", collectIgnorePatterns)
    .option("-q, --quiet", "Silence all stdout logging.")
    .option("-v, --verbose", "Output extra data to stdout when processing files.")
    .option("--batch-size <batchSize number>", "Number of sourcemaps to upload in parallel (max 25)")
    .option("--root <dirname>", "The base directory to use when computing relative paths")
    .arguments("<paths...>")
    .action((filepaths, opts) => commandUploadSourcemaps(filepaths, opts));
commandWithGlobalOptions("metadata")
    .option("--init [metadata]")
    .option("--keys <keys...>", "Metadata keys to initialize")
    .option("--filter <filter string>", "String to filter recordings")
    .action(commandMetadata);
commandWithGlobalOptions("login")
    .description("Log in interactively with your browser")
    .action(commandLogin);
commandWithGlobalOptions("version")
    .description("Returns the current version of the CLI")
    .option("--json", "Output in JSON format")
    .action(commandVersion);
function exitCommand(exitCode) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, launchdarkly_1.getLaunchDarkly)().close();
        process.exit(exitCode);
    });
}
commander_1.program.parseAsync().catch((err) => __awaiter(void 0, void 0, void 0, function* () {
    console.error(err);
    yield exitCommand(1);
}));
function collectExtensions(value) {
    return value.split(",");
}
function collectIgnorePatterns(value, previous = []) {
    return previous.concat([value]);
}
function commandListAllRecordings(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const recordings = (0, main_1.listAllRecordings)(Object.assign(Object.assign({}, opts), { verbose: true }));
            if (opts.json) {
                console.log((0, formatRecordings_1.formatAllRecordingsJson)(recordings));
            }
            else {
                console.log((0, formatRecordings_1.formatAllRecordingsHumanReadable)(recordings));
            }
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to list all recordings");
            (0, debug_1.printLogPath)();
            debug("removeRecording error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandUploadRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const recordingId = yield (0, main_1.uploadRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
            if (!recordingId) {
                (0, debug_1.printLogPath)();
            }
            yield exitCommand(recordingId || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to upload recording");
            (0, debug_1.printLogPath)();
            debug("uploadRecording error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandLaunchBrowser(url, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const browser = (0, utils_1.fuzzyBrowserName)(opts.browser) || "chromium";
            (0, utils_1.assertValidBrowserName)(browser);
            yield (0, main_1.launchBrowser)(browser, [url || "about:blank"], false, Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to launch browser");
            (0, debug_1.printLogPath)();
            debug("launchBrowser error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandLaunchBrowserAndRecord(url, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const browser = (0, utils_1.fuzzyBrowserName)(opts.browser) || "chromium";
            (0, utils_1.assertValidBrowserName)(browser);
            yield (0, main_1.launchBrowser)(browser, [url || "about:blank", opts.browserArgs], true, Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to launch browser");
            (0, debug_1.printLogPath)();
            debug("launchBrowser error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandProcessRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const recordingId = yield (0, main_1.processRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
            if (!recordingId) {
                (0, debug_1.printLogPath)();
            }
            yield exitCommand(recordingId || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to process recording");
            (0, debug_1.printLogPath)();
            debug("processRecording error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandUploadAllRecordings(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const uploadedAll = yield (0, main_1.uploadAllRecordings)(Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(uploadedAll || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to upload all recordings");
            (0, debug_1.printLogPath)();
            debug("uploadAllRecordings error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandViewRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const viewed = yield (0, main_1.viewRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(viewed || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to view recording");
            (0, debug_1.printLogPath)();
            debug("viewRecording error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandViewLatestRecording(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const viewed = yield (0, main_1.viewLatestRecording)(Object.assign(Object.assign({}, opts), { verbose: true }));
            if (!viewed) {
                (0, debug_1.printLogPath)();
            }
            yield exitCommand(viewed || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to view recording");
            (0, debug_1.printLogPath)();
            debug("viewLatestRecording error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandRemoveRecording(id, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            const removed = (0, main_1.removeRecording)(id, Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(removed || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to remove recording");
            (0, debug_1.printLogPath)();
            debug("removeRecording error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandRemoveAllRecordings(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            (0, main_1.removeAllRecordings)(Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to remove all recordings");
            (0, debug_1.printLogPath)();
            debug("removeAllRecordings error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandUpdateBrowsers(browsers, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            yield (0, main_1.updateBrowsers)(Object.assign(Object.assign({}, opts), { browsers: browsers === null || browsers === void 0 ? void 0 : browsers.split(",").map(utils_1.fuzzyBrowserName), verbose: true }));
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to updated browsers");
            (0, debug_1.printLogPath)();
            debug("updateBrowser error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandUploadSourcemaps(filepaths, cliOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        debug("Options", cliOpts);
        const { quiet, verbose, apiKey, batchSize, warn } = cliOpts, uploadOpts = __rest(cliOpts, ["quiet", "verbose", "apiKey", "batchSize", "warn"]);
        let log;
        if (!quiet) {
            if (verbose) {
                log = (_level, message) => {
                    console.log(message);
                };
            }
            else {
                log = (level, message) => {
                    if (level === "normal") {
                        console.log(message);
                    }
                };
            }
        }
        try {
            yield (0, sourcemap_upload_1.uploadSourceMaps)(Object.assign(Object.assign({ filepaths, key: apiKey }, uploadOpts), { concurrency: batchSize, log }));
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to upload source maps");
            debug("uploadSourceMaps error %o", e);
            yield exitCommand(warn ? 0 : 1);
        }
    });
}
function commandMetadata(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            debug("Options", opts);
            yield (0, main_1.updateMetadata)(Object.assign(Object.assign({}, opts), { verbose: true }));
            (0, debug_1.printLogPath)();
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to update recording metadata");
            debug("updateMetadata error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandLogin(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const ok = yield (0, auth_1.maybeAuthenticateUser)(Object.assign(Object.assign({}, opts), { verbose: true }));
            yield exitCommand(ok || opts.warn ? 0 : 1);
        }
        catch (e) {
            console.error("Failed to login");
            (0, debug_1.printLogPath)();
            debug("maybeAuthenticateUser error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
function commandVersion(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const versionInfo = yield (0, main_1.version)();
            if (opts.json) {
                console.log(JSON.stringify(versionInfo));
            }
            else {
                const { version, update, latest } = versionInfo;
                console.log(`\n@replayio/replay version ${version}`);
                if (update) {
                    console.log(`A newer version (${latest}) of the Replay CLI is available`);
                }
            }
            yield exitCommand(0);
        }
        catch (e) {
            console.error("Failed to get version information");
            (0, debug_1.printLogPath)();
            debug("commandVersion error %o", e);
            yield exitCommand(opts.warn ? 0 : 1);
        }
    });
}
//# sourceMappingURL=bin.js.map