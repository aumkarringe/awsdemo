"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.viewRecording = exports.viewLatestRecording = exports.version = exports.uploadRecording = exports.uploadAllRecordings = exports.updateMetadata = exports.updateBrowsers = exports.removeRecording = exports.removeAllRecordings = exports.query = exports.processRecording = exports.listAllRecordings = exports.launchBrowser = exports.getPuppeteerBrowserPath = exports.getPlaywrightBrowserPath = exports.getDirectory = exports.exponentialBackoffRetry = exports.ensurePuppeteerBrowsersInstalled = exports.ensurePlaywrightBrowsersInstalled = exports.addLocalRecordingMetadata = exports.filterRecordings = exports.updateStatus = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const query_registry_1 = require("query-registry");
const semver_1 = require("semver");
const debug_1 = __importDefault(require("./debug"));
const graphql_1 = require("./graphql");
Object.defineProperty(exports, "query", { enumerable: true, get: function () { return graphql_1.query; } });
const utils_1 = require("./utils");
// requiring v4 explicitly because it's the last version with commonjs support.
// Should be upgraded to the latest when converting this code to es modules.
const p_map_1 = __importDefault(require("p-map"));
const child_process_1 = require("child_process");
const jsonata_1 = __importDefault(require("jsonata"));
const metadata_1 = require("./metadata");
const auth_1 = require("./auth");
const client_1 = require("./client");
const install_1 = require("./install");
Object.defineProperty(exports, "ensurePlaywrightBrowsersInstalled", { enumerable: true, get: function () { return install_1.ensurePlaywrightBrowsersInstalled; } });
Object.defineProperty(exports, "ensurePuppeteerBrowsersInstalled", { enumerable: true, get: function () { return install_1.ensurePuppeteerBrowsersInstalled; } });
Object.defineProperty(exports, "getPlaywrightBrowserPath", { enumerable: true, get: function () { return install_1.getPlaywrightBrowserPath; } });
Object.defineProperty(exports, "getPuppeteerBrowserPath", { enumerable: true, get: function () { return install_1.getPuppeteerBrowserPath; } });
Object.defineProperty(exports, "updateBrowsers", { enumerable: true, get: function () { return install_1.updateBrowsers; } });
const recordingLog_1 = require("./recordingLog");
const upload_1 = require("./upload");
const utils_2 = require("./utils");
Object.defineProperty(exports, "exponentialBackoffRetry", { enumerable: true, get: function () { return utils_2.exponentialBackoffRetry; } });
Object.defineProperty(exports, "getDirectory", { enumerable: true, get: function () { return utils_2.getDirectory; } });
const launchdarkly_1 = require("./launchdarkly");
const debug = (0, debug_1.default)("replay:cli");
function updateStatus(recording, status) {
    // Once a recording enters an unusable or crashed status, don't change it
    // except to mark crashes as uploaded.
    if (recording.status == "unusable" ||
        recording.status == "crashUploaded" ||
        (recording.status == "crashed" && status != "crashUploaded")) {
        return;
    }
    recording.status = status;
}
exports.updateStatus = updateStatus;
function filterRecordings(recordings, filter, includeCrashes) {
    let filteredRecordings = recordings;
    debug("Recording log contains %d replays", recordings.length);
    if (filter && typeof filter === "string") {
        debug("Using filter: %s", filter);
        const exp = (0, jsonata_1.default)(`$filter($, ${filter})[]`);
        filteredRecordings = exp.evaluate(recordings) || [];
        debug("Filtering resulted in %d replays", filteredRecordings.length);
    }
    else if (typeof filter === "function") {
        debug("Using filter function");
        filteredRecordings = recordings.filter(filter);
        debug("Filtering resulted in %d replays", filteredRecordings.length);
    }
    if (includeCrashes) {
        recordings.forEach(r => {
            if (r.status === "crashed" && !filteredRecordings.includes(r)) {
                filteredRecordings.push(r);
            }
        });
    }
    return filteredRecordings;
}
exports.filterRecordings = filterRecordings;
// Convert a recording into a format for listing.
function listRecording(recording) {
    // Remove properties we only use internally.
    const { buildId, crashData } = recording, recordingWithoutInternalProperties = __rest(recording, ["buildId", "crashData"]);
    return recordingWithoutInternalProperties;
}
function listAllRecordings(opts = {}) {
    const recordings = (0, recordingLog_1.readRecordings)(opts.directory);
    if (opts.all) {
        return filterRecordings(recordings, opts.filter, opts.includeCrashes).map(listRecording);
    }
    const uploadableRecordings = recordings.filter(recording => ["onDisk", "startedWrite", "crashed"].includes(recording.status));
    return filterRecordings(uploadableRecordings, opts.filter, opts.includeCrashes).map(listRecording);
}
exports.listAllRecordings = listAllRecordings;
function uploadSkipReason(recording) {
    // Status values where there is something worth uploading.
    const canUploadStatus = ["onDisk", "startedWrite", "startedUpload", "crashed"];
    if (!canUploadStatus.includes(recording.status)) {
        return `wrong recording status ${recording.status}`;
    }
    if (!recording.path && recording.status != "crashed") {
        return "recording not saved to disk";
    }
    return null;
}
function getServer(opts) {
    return (opts.server ||
        process.env.RECORD_REPLAY_SERVER ||
        process.env.REPLAY_SERVER ||
        "wss://dispatch.replay.io");
}
function doUploadCrash(dir, server, recording, verbose, apiKey, agent) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = new upload_1.ReplayClient();
        (0, utils_2.maybeLog)(verbose, `Starting crash data upload for ${recording.id}...`);
        if (!(yield client.initConnection(server, apiKey, verbose, agent))) {
            (0, utils_2.maybeLog)(verbose, `Crash data upload failed: can't connect to server ${server}`);
            return null;
        }
        const crashData = recording.crashData || [];
        crashData.push({
            kind: "recordingMetadata",
            recordingId: recording.id,
        });
        yield Promise.all(crashData.map((data) => __awaiter(this, void 0, void 0, function* () {
            yield client.connectionReportCrash(data);
        })));
        (0, recordingLog_1.addRecordingEvent)(dir, "crashUploaded", recording.id, { server });
        (0, utils_2.maybeLog)(verbose, `Crash data upload finished.`);
        client.closeConnection();
    });
}
class RecordingUploadError extends Error {
    constructor(message, interiorError) {
        super(message);
        Object.defineProperty(this, "interiorError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = "RecordingUploadError";
        this.interiorError = interiorError;
        Object.setPrototypeOf(this, new.target.prototype); // Restore error prototype chain.
    }
}
function handleUploadingError(err, strict, verbose, interiorError) {
    (0, utils_2.maybeLog)(verbose, `Upload failed: ${err}`);
    if (interiorError) {
        debug(interiorError);
    }
    if (strict) {
        throw new RecordingUploadError(err, interiorError);
    }
}
function validateMetadata(client, metadata, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        return metadata ? yield client.buildRecordingMetadata(metadata, { verbose }) : null;
    });
}
function setMetadata(client, recordingId, metadata, strict, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        if (metadata) {
            try {
                yield (0, utils_2.exponentialBackoffRetry)(() => client.setRecordingMetadata(recordingId, metadata), e => {
                    debug("Failed to set recording metadata. Will be retried:  %j", e);
                });
            }
            catch (e) {
                handleUploadingError(`Failed to set recording metadata ${e}`, strict, verbose, e);
            }
        }
    });
}
const MIN_MULTIPART_UPLOAD_SIZE = 5 * 1024 * 1024;
function multipartUploadRecording(server, client, dir, recording, metadata, size, strict, verbose, agentOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const requestPartChunkSize = parseInt(process.env.REPLAY_MULTIPART_UPLOAD_CHUNK || "", 10) || undefined;
        const { recordingId, uploadId, partLinks, chunkSize } = yield client.connectionBeginRecordingMultipartUpload(recording.id, recording.buildId, size, requestPartChunkSize);
        yield setMetadata(client, recordingId, metadata, strict, verbose);
        (0, recordingLog_1.addRecordingEvent)(dir, "uploadStarted", recording.id, {
            server,
            recordingId,
        });
        const eTags = yield client.uploadRecordingInParts(recording.path, partLinks, chunkSize, agentOptions);
        yield client.connectionEndRecordingMultipartUpload(recording.id, uploadId, eTags);
        return recordingId;
    });
}
function directUploadRecording(server, client, dir, recording, metadata, size, strict, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        const { recordingId, uploadLink } = yield client.connectionBeginRecordingUpload(recording.id, recording.buildId, size);
        yield setMetadata(client, recordingId, metadata, strict, verbose);
        (0, recordingLog_1.addRecordingEvent)(dir, "uploadStarted", recording.id, {
            server,
            recordingId,
        });
        yield (0, utils_2.exponentialBackoffRetry)(() => client.uploadRecording(recording.path, uploadLink, size), e => {
            debug("Upload failed with error. Will be retried:  %j", e);
        });
        debug("%s: Uploaded %d bytes", recordingId, size);
        yield client.connectionEndRecordingUpload(recording.id);
        return recordingId;
    });
}
function doUploadRecording(dir_1, server_1, recording_1) {
    return __awaiter(this, arguments, void 0, function* (dir, server, recording, verbose = false, apiKey, agentOptions, removeAssets = false, strict = false) {
        debug("Uploading %s from %s to %s", recording.id, dir, server);
        (0, utils_2.maybeLog)(verbose, `Starting upload for ${recording.id}...`);
        if (recording.status == "uploaded" && recording.recordingId) {
            (0, utils_2.maybeLog)(verbose, `Already uploaded: ${recording.recordingId}`);
            return recording.recordingId;
        }
        const reason = uploadSkipReason(recording);
        if (reason) {
            handleUploadingError(reason, strict, verbose);
            return null;
        }
        if (!apiKey) {
            apiKey = yield (0, auth_1.readToken)({ directory: dir });
        }
        const agent = (0, utils_1.getHttpAgent)(server, agentOptions);
        if (recording.status == "crashed") {
            debug("Uploading crash %o", recording);
            yield doUploadCrash(dir, server, recording, verbose, apiKey, agent);
            (0, utils_2.maybeLog)(verbose, `Crash report uploaded for ${recording.id}`);
            if (removeAssets) {
                removeRecordingAssets(recording, { directory: dir });
            }
            return recording.id;
        }
        const { size } = yield fs_1.default.promises.stat(recording.path);
        debug("Uploading recording %o", recording);
        const client = new upload_1.ReplayClient();
        if (!(yield client.initConnection(server, apiKey, verbose, agent))) {
            handleUploadingError(`Cannot connect to server ${server}`, strict, verbose);
            return null;
        }
        // validate metadata before uploading so invalid data can block the upload
        const metadata = yield validateMetadata(client, recording.metadata, verbose);
        let recordingId;
        try {
            const isMultipartEnabled = yield (0, launchdarkly_1.getLaunchDarkly)().isEnabled("cli-multipart-upload", false);
            if (size > MIN_MULTIPART_UPLOAD_SIZE && isMultipartEnabled) {
                recordingId = yield multipartUploadRecording(server, client, dir, recording, metadata, size, strict, verbose, agentOptions);
            }
            else {
                recordingId = yield directUploadRecording(server, client, dir, recording, metadata, size, strict, verbose);
            }
        }
        catch (err) {
            handleUploadingError(err instanceof client_1.ProtocolError ? err.protocolMessage : String(err), strict, verbose, err);
            return null;
        }
        yield (0, p_map_1.default)(recording.sourcemaps, (sourcemap) => __awaiter(this, void 0, void 0, function* () {
            try {
                debug("Uploading sourcemap %s for recording %s", sourcemap.path, recording.id);
                const contents = fs_1.default.readFileSync(sourcemap.path, "utf8");
                const sourcemapId = yield client.connectionUploadSourcemap(recordingId, sourcemap, contents);
                yield (0, p_map_1.default)(sourcemap.originalSources, originalSource => {
                    debug("Uploading original source %s for sourcemap %s for recording %s", originalSource.path, sourcemap.path, recording.id);
                    const contents = fs_1.default.readFileSync(originalSource.path, "utf8");
                    return client.connectionUploadOriginalSource(recordingId, sourcemapId, originalSource, contents);
                }, { concurrency: 5, stopOnError: false });
            }
            catch (e) {
                handleUploadingError(`Cannot upload sourcemap ${sourcemap.path} from disk: ${e}`, strict, verbose, e);
            }
        }), { concurrency: 10, stopOnError: false });
        if (removeAssets) {
            removeRecordingAssets(recording, { directory: dir });
        }
        (0, recordingLog_1.addRecordingEvent)(dir, "uploadFinished", recording.id);
        (0, utils_2.maybeLog)(verbose, `Upload finished! View your Replay at: https://app.replay.io/recording/${recordingId}`);
        client.closeConnection();
        return recordingId;
    });
}
function uploadRecording(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, opts = {}) {
        var _a;
        const server = getServer(opts);
        const dir = (0, utils_2.getDirectory)(opts);
        const recordings = (0, recordingLog_1.readRecordings)(dir);
        const recording = recordings.find(r => r.id == id);
        if (!recording) {
            (0, utils_2.maybeLog)(opts.verbose, `Unknown recording ${id}`);
            return null;
        }
        return doUploadRecording(dir, server, recording, opts.verbose, opts.apiKey, opts.agentOptions, (_a = opts.removeAssets) !== null && _a !== void 0 ? _a : true, opts.strict);
    });
}
exports.uploadRecording = uploadRecording;
function processUploadedRecording(recordingId, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const server = getServer(opts);
        const agent = (0, utils_1.getHttpAgent)(server, opts.agentOptions);
        const { verbose } = opts;
        let apiKey = opts.apiKey;
        (0, utils_2.maybeLog)(verbose, `Processing recording ${recordingId}...`);
        if (!apiKey) {
            apiKey = yield (0, auth_1.readToken)(opts);
        }
        const client = new upload_1.ReplayClient();
        if (!(yield client.initConnection(server, apiKey, verbose, agent))) {
            (0, utils_2.maybeLog)(verbose, `Processing failed: can't connect to server ${server}`);
            return false;
        }
        try {
            const error = yield client.connectionWaitForProcessed(recordingId);
            if (error) {
                (0, utils_2.maybeLog)(verbose, `Processing failed: ${error}`);
                return false;
            }
        }
        finally {
            client.closeConnection();
        }
        (0, utils_2.maybeLog)(verbose, "Finished processing.");
        return true;
    });
}
function processRecording(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, opts = {}) {
        const recordingId = yield uploadRecording(id, opts);
        if (!recordingId) {
            return null;
        }
        const succeeded = yield processUploadedRecording(recordingId, opts);
        return succeeded ? recordingId : null;
    });
}
exports.processRecording = processRecording;
function uploadAllRecordings() {
    return __awaiter(this, arguments, void 0, function* (opts = {}) {
        const server = getServer(opts);
        const dir = (0, utils_2.getDirectory)(opts);
        const allRecordings = (0, recordingLog_1.readRecordings)(dir).filter(r => !uploadSkipReason(r));
        const recordings = filterRecordings(allRecordings, opts.filter, opts.includeCrashes);
        if (allRecordings.some(r => r.status === "crashed") &&
            !recordings.some(r => r.status === "crashed") &&
            opts.filter &&
            !opts.includeCrashes) {
            (0, utils_2.maybeLog)(opts.verbose, `\n⚠️ Warning: Some crash reports were created but will not be uploaded because of the provided filter. Add --include-crashes to upload crash reports.\n`);
        }
        if (recordings.length === 0) {
            if (opts.filter && allRecordings.length > 0) {
                (0, utils_2.maybeLog)(opts.verbose, `No replays matched the provided filter`);
            }
            else {
                (0, utils_2.maybeLog)(opts.verbose, `No replays were found to upload`);
            }
            return true;
        }
        (0, utils_2.maybeLog)(opts.verbose, `Starting upload of ${recordings.length} replays`);
        if (opts.batchSize) {
            debug("Batching upload in groups of %d", opts.batchSize);
        }
        const batchSize = Math.min(opts.batchSize || 20, 25);
        const recordingIds = yield (0, p_map_1.default)(recordings, (r) => doUploadRecording(dir, server, r, opts.verbose, opts.apiKey, opts.agentOptions, false, opts.strict), { concurrency: batchSize, stopOnError: false });
        recordingIds.forEach(id => {
            const recording = recordings.find(r => r.id === id);
            if (!recording)
                return;
            removeRecordingAssets(recording, opts);
        });
        return recordingIds.every(r => r !== null);
    });
}
exports.uploadAllRecordings = uploadAllRecordings;
function doViewRecording(dir, server, recording, verbose, apiKey, agentOptions, viewServer) {
    return __awaiter(this, void 0, void 0, function* () {
        let recordingId;
        if (recording.status === "crashUploaded") {
            (0, utils_2.maybeLog)(verbose, "Crash report already uploaded");
            return true;
        }
        else if (recording.status == "uploaded") {
            recordingId = recording.recordingId;
            server = recording.server;
        }
        else {
            recordingId = yield doUploadRecording(dir, server, recording, verbose, apiKey, agentOptions, true);
            if (!recordingId) {
                return false;
            }
            else if (recording.status === "crashed") {
                return true;
            }
        }
        const devtools = viewServer !== null && viewServer !== void 0 ? viewServer : "https://app.replay.io";
        const dispatch = server != "wss://dispatch.replay.io" ? `&dispatch=${server}` : "";
        (0, child_process_1.spawn)((0, utils_2.openExecutable)(), [`${devtools}?id=${recordingId}${dispatch}`]);
        return true;
    });
}
function viewRecording(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, opts = {}) {
        let server = getServer(opts);
        const dir = (0, utils_2.getDirectory)(opts);
        const recordings = (0, recordingLog_1.readRecordings)(dir);
        const recording = recordings.find(r => r.id == id);
        if (!recording) {
            (0, utils_2.maybeLog)(opts.verbose, `Unknown recording ${id}`);
            return false;
        }
        return doViewRecording(dir, server, recording, opts.verbose, opts.apiKey, opts.agentOptions);
    });
}
exports.viewRecording = viewRecording;
function viewLatestRecording() {
    return __awaiter(this, arguments, void 0, function* (opts = {}) {
        let server = getServer(opts);
        const dir = (0, utils_2.getDirectory)(opts);
        const recordings = (0, recordingLog_1.readRecordings)(dir);
        if (!recordings.length) {
            (0, utils_2.maybeLog)(opts.verbose, "No recordings to view");
            return false;
        }
        return doViewRecording(dir, server, recordings[recordings.length - 1], opts.verbose, opts.apiKey, opts.agentOptions, opts.viewServer);
    });
}
exports.viewLatestRecording = viewLatestRecording;
function maybeRemoveAssetFile(asset) {
    if (asset) {
        try {
            if (fs_1.default.existsSync(asset)) {
                debug("Removing asset file %s", asset);
                fs_1.default.unlinkSync(asset);
            }
        }
        catch (e) {
            debug("Failed to remove asset file: %s", e);
        }
    }
}
function removeRecording(id, opts = {}) {
    const dir = (0, utils_2.getDirectory)(opts);
    const recordings = (0, recordingLog_1.readRecordings)(dir);
    const recording = recordings.find(r => r.id == id);
    if (!recording) {
        (0, utils_2.maybeLog)(opts.verbose, `Unknown recording ${id}`);
        return false;
    }
    removeRecordingAssets(recording, opts);
    (0, recordingLog_1.removeRecordingFromLog)(dir, id);
    return true;
}
exports.removeRecording = removeRecording;
function getRecordingAssetFiles(recording) {
    const assetFiles = [];
    if (recording.path) {
        assetFiles.push(recording.path);
    }
    recording.sourcemaps.forEach(sm => {
        assetFiles.push(sm.path);
        assetFiles.push(sm.path.replace(/\.map$/, ".lookup"));
        sm.originalSources.forEach(o => assetFiles.push(o.path));
    });
    return assetFiles;
}
function removeRecordingAssets(recording, opts) {
    const localRecordings = listAllRecordings(Object.assign(Object.assign({}, opts), { filter: r => r.status !== "uploaded" && r.status !== "crashUploaded" && r.id !== recording.id }));
    const localRecordingAssetFiles = new Set(localRecordings.flatMap(getRecordingAssetFiles));
    const assetFiles = getRecordingAssetFiles(recording);
    assetFiles.forEach(file => {
        if (!localRecordingAssetFiles.has(file)) {
            maybeRemoveAssetFile(file);
        }
    });
}
function removeAllRecordings(opts = {}) {
    const dir = (0, utils_2.getDirectory)(opts);
    const recordings = (0, recordingLog_1.readRecordings)(dir);
    recordings.forEach(r => removeRecordingAssets(r, opts));
    (0, recordingLog_1.removeRecordingsFile)(dir);
}
exports.removeAllRecordings = removeAllRecordings;
function addLocalRecordingMetadata(recordingId, metadata) {
    (0, metadata_1.add)(recordingId, metadata);
}
exports.addLocalRecordingMetadata = addLocalRecordingMetadata;
function updateMetadata(_a) {
    return __awaiter(this, arguments, void 0, function* ({ init: metadata, keys = [], filter, includeCrashes, verbose, warn, directory, }) {
        let md = {};
        if (metadata) {
            md = JSON.parse(metadata);
        }
        const keyedObjects = yield (0, p_map_1.default)(keys, (v) => __awaiter(this, void 0, void 0, function* () {
            try {
                switch (v) {
                    case "source":
                        return yield metadata_1.source.init(md.source || {});
                    case "test":
                        return yield metadata_1.test.init(md.test || {});
                }
            }
            catch (e) {
                debug("Metadata initialization error: %o", e);
                if (!warn) {
                    throw e;
                }
                console.warn(`Unable to initialize metadata field: "${v}"`);
                if (e instanceof Error) {
                    console.warn(" ->", e.message);
                }
            }
            return null;
        }));
        const data = Object.assign(md, ...keyedObjects);
        const sanitized = yield (0, metadata_1.sanitize)(data);
        debug("Sanitized metadata: %O", sanitized);
        const recordings = listAllRecordings({ directory, filter, includeCrashes });
        recordings.forEach(r => {
            (0, utils_2.maybeLog)(verbose, `Setting metadata for ${r.id}`);
            (0, metadata_1.add)(r.id, sanitized);
        });
    });
}
exports.updateMetadata = updateMetadata;
function launchBrowser(browserName_1) {
    return __awaiter(this, arguments, void 0, function* (browserName, args = [], record = false, opts) {
        debug("launchBrowser: %s %o %s %o", browserName, args, record, opts);
        const execPath = (0, install_1.getExecutablePath)(browserName, opts);
        if (!execPath) {
            throw new Error(`${browserName} not supported on the current platform`);
        }
        if (!fs_1.default.existsSync(execPath)) {
            (0, utils_2.maybeLog)(opts === null || opts === void 0 ? void 0 : opts.verbose, `Installing ${browserName}`);
            yield (0, install_1.ensureBrowsersInstalled)(browserName, false, opts);
        }
        const profileDir = path_1.default.join((0, utils_2.getDirectory)(opts), "runtimes", "profiles", browserName);
        const browserArgs = {
            chromium: [
                "--no-first-run",
                "--no-default-browser-check",
                `--user-data-dir=${profileDir}`,
                ...args,
            ],
            firefox: ["-foreground", ...args],
        };
        const env = Object.assign({}, process.env);
        if (record) {
            env.RECORD_ALL_CONTENT = "1";
        }
        if (opts === null || opts === void 0 ? void 0 : opts.directory) {
            env.RECORD_REPLAY_DIRECTORY = opts === null || opts === void 0 ? void 0 : opts.directory;
        }
        const proc = (0, child_process_1.spawn)(execPath, browserArgs[browserName], {
            detached: !(opts === null || opts === void 0 ? void 0 : opts.attach),
            env,
            stdio: "inherit",
        });
        if (!(opts === null || opts === void 0 ? void 0 : opts.attach)) {
            proc.unref();
        }
        else {
            // Wait for the browser process to finish.
            yield new Promise((resolve, reject) => {
                proc.on("error", reject);
                proc.on("exit", (code, signal) => {
                    if (code || signal) {
                        reject(new Error(`Process failed code=${code}, signal=${signal}`));
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        return proc;
    });
}
exports.launchBrowser = launchBrowser;
function version() {
    return __awaiter(this, void 0, void 0, function* () {
        const version = (0, utils_1.getCurrentVersion)();
        let update = false;
        let latest = null;
        try {
            const data = yield (0, query_registry_1.getPackument)({ name: "@replayio/replay" });
            latest = data.distTags.latest;
            if ((0, semver_1.compare)(version, latest) < 0) {
                update = true;
            }
        }
        catch (e) {
            debug("Error retrieving latest package info: %o", e);
        }
        return {
            version,
            update,
            latest,
        };
    });
}
exports.version = version;
//# sourceMappingURL=main.js.map