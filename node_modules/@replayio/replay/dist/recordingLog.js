"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRecordingEvent = exports.removeRecordingsFile = exports.removeRecordingFromLog = exports.readRecordingFile = exports.readRecordings = void 0;
const debug_1 = __importDefault(require("./debug"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const generateDefaultTitle_1 = require("./generateDefaultTitle");
const main_1 = require("./main");
const utils_1 = require("./utils");
const debug = (0, debug_1.default)("replay:cli:recording-log");
function getRecordingsFile(dir) {
    return path_1.default.join(dir, "recordings.log");
}
function readRecordingFile(dir) {
    const file = getRecordingsFile(dir);
    if (!fs_1.default.existsSync(file)) {
        return [];
    }
    return fs_1.default.readFileSync(file, "utf8").split("\n");
}
exports.readRecordingFile = readRecordingFile;
function writeRecordingFile(dir, lines) {
    // Add a trailing newline so the driver can safely append logs
    fs_1.default.writeFileSync(getRecordingsFile(dir), lines.join("\n") + "\n");
}
function getBuildRuntime(buildId) {
    const match = /.*?-(.*?)-/.exec(buildId);
    return match ? match[1] : "unknown";
}
const RECORDING_LOG_KIND = [
    "createRecording",
    "addMetadata",
    "writeStarted",
    "sourcemapAdded",
    "originalSourceAdded",
    "writeFinished",
    "uploadStarted",
    "uploadFinished",
    "recordingUnusable",
    "crashed",
    "crashData",
    "crashUploaded",
];
function readRecordings(dir, includeHidden = false) {
    dir = (0, utils_1.getDirectory)({ directory: dir });
    const recordings = [];
    const lines = readRecordingFile(dir)
        .map(line => {
        try {
            return JSON.parse(line);
        }
        catch (_a) {
            return null;
        }
    })
        .filter((o) => o != null)
        .sort((a, b) => RECORDING_LOG_KIND.indexOf(a.kind) - RECORDING_LOG_KIND.indexOf(b.kind));
    for (const obj of lines) {
        switch (obj.kind) {
            case "createRecording": {
                const { id, timestamp, buildId } = obj;
                recordings.push({
                    id,
                    createTime: new Date(timestamp),
                    buildId,
                    runtime: getBuildRuntime(buildId),
                    metadata: {},
                    sourcemaps: [],
                    // We use an unknown status after the createRecording event because
                    // there should always be later events describing what happened to the
                    // recording.
                    status: "unknown",
                });
                break;
            }
            case "addMetadata": {
                const { id, metadata } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    Object.assign(recording.metadata, metadata);
                    if (!recording.metadata.title) {
                        recording.metadata.title = (0, generateDefaultTitle_1.generateDefaultTitle)(recording.metadata);
                    }
                }
                break;
            }
            case "writeStarted": {
                const { id, path } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "startedWrite");
                    recording.path = path;
                }
                break;
            }
            case "writeFinished": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "onDisk");
                }
                break;
            }
            case "uploadStarted": {
                const { id, server, recordingId } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "startedUpload");
                    recording.server = server;
                    recording.recordingId = recordingId;
                }
                break;
            }
            case "uploadFinished": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "uploaded");
                }
                break;
            }
            case "recordingUnusable": {
                const { id, reason } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "unusable");
                    recording.unusableReason = reason;
                }
                break;
            }
            case "crashed": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "crashed");
                }
                break;
            }
            case "crashData": {
                const { id, data } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    if (!recording.crashData) {
                        recording.crashData = [];
                    }
                    recording.crashData.push(data);
                }
                break;
            }
            case "crashUploaded": {
                const { id } = obj;
                const recording = recordings.find(r => r.id == id);
                if (recording) {
                    (0, main_1.updateStatus)(recording, "crashUploaded");
                }
                break;
            }
            case "sourcemapAdded": {
                const { id, recordingId, path, baseURL, targetContentHash, targetURLHash, targetMapURLHash, } = obj;
                const recording = recordings.find(r => r.id == recordingId);
                if (recording) {
                    recording.sourcemaps.push({
                        id,
                        path,
                        baseURL,
                        targetContentHash,
                        targetURLHash,
                        targetMapURLHash,
                        originalSources: [],
                    });
                }
                break;
            }
            case "originalSourceAdded": {
                const { recordingId, path, parentId, parentOffset } = obj;
                const recording = recordings.find(r => r.id === recordingId);
                if (recording) {
                    const sourcemap = recording.sourcemaps.find(s => s.id === parentId);
                    if (sourcemap) {
                        sourcemap.originalSources.push({
                            path,
                            parentOffset,
                        });
                    }
                }
                break;
            }
        }
    }
    if (includeHidden) {
        return recordings;
    }
    // There can be a fair number of recordings from gecko/chromium content
    // processes which never loaded any interesting content. These are ignored by
    // most callers. Note that we're unable to avoid generating these entries in
    // the first place because the recordings log is append-only and we don't know
    // when a recording process starts if it will ever do anything interesting.
    return recordings.filter(r => !(r.unusableReason || "").includes("No interesting content"));
}
exports.readRecordings = readRecordings;
function addRecordingEvent(dir, kind, id, tags = {}) {
    const event = Object.assign({ kind,
        id, timestamp: Date.now() }, tags);
    debug("Writing event to recording log %o", event);
    const lines = readRecordingFile(dir);
    lines.push(JSON.stringify(event));
    writeRecordingFile(dir, lines);
}
exports.addRecordingEvent = addRecordingEvent;
function removeRecordingsFile(dir) {
    const file = getRecordingsFile(dir);
    if (fs_1.default.existsSync(file)) {
        fs_1.default.unlinkSync(file);
    }
}
exports.removeRecordingsFile = removeRecordingsFile;
function removeRecordingFromLog(dir, id) {
    const lines = readRecordingFile(dir).filter(line => {
        try {
            const obj = JSON.parse(line);
            if (obj.id == id) {
                return false;
            }
        }
        catch (e) {
            return false;
        }
        return true;
    });
    writeRecordingFile(dir, lines);
}
exports.removeRecordingFromLog = removeRecordingFromLog;
//# sourceMappingURL=recordingLog.js.map