"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHttpAgent = exports.getUserAgent = exports.getCurrentVersion = exports.isValidUUID = exports.getDirectory = exports.maybeLog = exports.defer = exports.fuzzyBrowserName = exports.assertValidBrowserName = exports.linearBackoffRetry = exports.exponentialBackoffRetry = exports.openExecutable = void 0;
// This module is meant to be somewhat browser-friendly.
// It can't lead to importing node builtin modules like like worker_threads.
// Cypress bundles this file and runs it in the browser,
// some imports like path and http are OK because they are aliased~ by their webpack config:
// https://github.com/cypress-io/cypress/blob/fb87950d6337ba99d13cb5fa3ce129e5f5cac02b/npm/webpack-batteries-included-preprocessor/index.js#L151
// TODO: decouple this more so we never run into problems with this - we shouldn't rely on implementation details of Cypress bundling
const debug_1 = __importDefault(require("debug"));
const path_1 = __importDefault(require("path"));
const http_1 = require("http");
const https_1 = require("https");
const debug = (0, debug_1.default)("replay:cli");
// Get the executable name to use when opening a URL.
// It would be nice to use an existing npm package for this,
// but the obvious choice of "open" didn't actually work on linux
// when testing...
function openExecutable() {
    switch (process.platform) {
        case "darwin":
            return "open";
        case "linux":
            return "xdg-open";
        default:
            throw new Error("Unsupported platform");
    }
}
exports.openExecutable = openExecutable;
function defer() {
    let resolve = () => { };
    let reject = () => { };
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return { promise, resolve, reject };
}
exports.defer = defer;
function maybeLog(verbose, str) {
    debug(str);
    if (verbose) {
        console.log(str);
    }
}
exports.maybeLog = maybeLog;
function getDirectory(opts) {
    const home = process.env.HOME || process.env.USERPROFILE;
    return ((opts && opts.directory) || process.env.RECORD_REPLAY_DIRECTORY || path_1.default.join(home, ".replay"));
}
exports.getDirectory = getDirectory;
function isValidUUID(str) {
    if (typeof str != "string" || str.length != 36) {
        return false;
    }
    for (let i = 0; i < str.length; i++) {
        if ("0123456789abcdef-".indexOf(str[i]) == -1) {
            return false;
        }
    }
    return true;
}
exports.isValidUUID = isValidUUID;
function waitForTime(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(r => setTimeout(r, ms));
    });
}
// Random extra delay under 100ms to avoid retrying in bursts.
function jitter() {
    return Math.random() * 100.0;
}
// Returns backoff timeouts (in ms) in a geometric progression, and with jitter.
function geometricBackoff(iteration) {
    return Math.pow(2, iteration) * 100 + jitter();
}
function linearBackoff() {
    return 100 + jitter();
}
const MAX_ATTEMPTS = 5;
function retry(fn, backOffStrategy, onFail, maxTries) {
    return __awaiter(this, void 0, void 0, function* () {
        const maxAttempts = maxTries || MAX_ATTEMPTS;
        let currentAttempt = 0;
        while (currentAttempt <= maxAttempts) {
            currentAttempt++;
            try {
                return yield fn();
            }
            catch (e) {
                if (onFail) {
                    onFail(e);
                }
                if (currentAttempt == maxAttempts) {
                    throw e;
                }
                yield waitForTime(backOffStrategy(currentAttempt));
            }
        }
        throw Error("ShouldBeUnreachable");
    });
}
function exponentialBackoffRetry(fn, onFail, maxTries) {
    return __awaiter(this, void 0, void 0, function* () {
        return retry(fn, geometricBackoff, onFail, maxTries);
    });
}
exports.exponentialBackoffRetry = exponentialBackoffRetry;
function linearBackoffRetry(fn, onFail, maxTries) {
    return __awaiter(this, void 0, void 0, function* () {
        return retry(fn, linearBackoff, onFail, maxTries);
    });
}
exports.linearBackoffRetry = linearBackoffRetry;
function fuzzyBrowserName(browser) {
    var _a;
    browser = (_a = browser === null || browser === void 0 ? void 0 : browser.toLowerCase()) === null || _a === void 0 ? void 0 : _a.trim();
    switch (browser) {
        case "chrome":
            return "chromium";
        case "gecko":
            return "firefox";
    }
    return browser;
}
exports.fuzzyBrowserName = fuzzyBrowserName;
function assertValidBrowserName(browser) {
    if (!browser || (browser !== "chromium" && browser !== "firefox")) {
        throw new Error("Unsupported browser: " + browser);
    }
}
exports.assertValidBrowserName = assertValidBrowserName;
function getCurrentVersion() {
    const pkg = require("@replayio/replay/package.json");
    return pkg.version;
}
exports.getCurrentVersion = getCurrentVersion;
function getNameAndVersion() {
    const pkg = require("@replayio/replay/package.json");
    return `${pkg.name}/${pkg.version}`;
}
function getUserAgent() {
    return getNameAndVersion();
}
exports.getUserAgent = getUserAgent;
function getHttpAgent(server, agentOptions) {
    const serverURL = new URL(server);
    if (!agentOptions) {
        return;
    }
    if (["wss:", "https:"].includes(serverURL.protocol)) {
        return new https_1.Agent(agentOptions);
    }
    else if (["ws:", "http:"].includes(serverURL.protocol)) {
        return new http_1.Agent(agentOptions);
    }
    throw new Error(`Unsupported protocol: ${serverURL.protocol} for URL ${serverURL}`);
}
exports.getHttpAgent = getHttpAgent;
//# sourceMappingURL=utils.js.map