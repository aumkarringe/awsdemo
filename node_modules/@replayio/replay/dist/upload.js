"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplayClient = void 0;
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const p_map_1 = __importDefault(require("p-map"));
const path_1 = __importDefault(require("path"));
const worker_threads_1 = require("worker_threads");
const client_1 = __importDefault(require("./client"));
const debug_1 = __importStar(require("./debug"));
const metadata_1 = require("./metadata");
const utils_1 = require("./utils");
const debug = (0, debug_1.default)("replay:cli:upload");
function sha256(text) {
    return crypto_1.default.createHash("sha256").update(text).digest("hex");
}
class ReplayClient {
    constructor() {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "clientReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, utils_1.defer)()
        });
    }
    initConnection(server, accessToken, verbose, agent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                let { resolve } = this.clientReady;
                this.client = new client_1.default(server, {
                    onOpen: () => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.client.setAccessToken(accessToken);
                            resolve(true);
                        }
                        catch (err) {
                            (0, utils_1.maybeLog)(verbose, `Error authenticating with server: ${err}`);
                            resolve(false);
                        }
                    }),
                    onClose() {
                        resolve(false);
                    },
                    onError(e) {
                        (0, utils_1.maybeLog)(verbose, `Error connecting to server: ${e}`);
                        resolve(false);
                    },
                }, agent);
            }
            return this.clientReady.promise;
        });
    }
    connectionBeginRecordingUpload(id, buildId, size) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { recordingId, uploadLink } = yield this.client.sendCommand("Internal.beginRecordingUpload", {
                buildId,
                // 3/22/2022: Older builds use integers instead of UUIDs for the recording
                // IDs written to disk. These are not valid to use as recording IDs when
                // uploading recordings to the backend.
                recordingId: (0, utils_1.isValidUUID)(id) ? id : undefined,
                recordingSize: size,
            });
            return { recordingId, uploadLink };
        });
    }
    connectionBeginRecordingMultipartUpload(id, buildId, size, multiPartChunkSize) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { recordingId, uploadId, chunkSize, partLinks } = yield this.client.sendCommand("Internal.beginRecordingMultipartUpload", {
                buildId,
                // 3/22/2022: Older builds use integers instead of UUIDs for the recording
                // IDs written to disk. These are not valid to use as recording IDs when
                // uploading recordings to the backend.
                recordingId: (0, utils_1.isValidUUID)(id) ? id : undefined,
                recordingSize: size,
                chunkSize: multiPartChunkSize,
            });
            return { recordingId, uploadId, chunkSize, partLinks };
        });
    }
    buildRecordingMetadata(metadata_2) {
        return __awaiter(this, arguments, void 0, function* (metadata, _opts = {}) {
            // extract the "standard" metadata and route the `rest` through the sanitizer
            const { duration, url, uri, title, operations } = metadata, rest = __rest(metadata, ["duration", "url", "uri", "title", "operations"]);
            const metadataUrl = url || uri;
            return {
                recordingData: {
                    duration: typeof duration === "number" ? duration : 0,
                    url: typeof metadataUrl === "string" ? metadataUrl : "",
                    title: typeof title === "string" ? title : "",
                    operations: operations && typeof operations === "object"
                        ? operations
                        : {
                            scriptDomains: [],
                        },
                    lastScreenData: "",
                    lastScreenMimeType: "",
                },
                metadata: yield (0, metadata_1.sanitize)(rest),
            };
        });
    }
    setRecordingMetadata(id, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            metadata.recordingData.id = id;
            yield this.client.sendCommand("Internal.setRecordingMetadata", metadata);
        });
    }
    connectionProcessRecording(recordingId) {
        if (!this.client)
            throw new Error("Protocol client is not initialized");
        this.client.sendCommand("Recording.processRecording", { recordingId });
    }
    connectionWaitForProcessed(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { sessionId } = yield this.client.sendCommand("Recording.createSession", {
                recordingId,
            });
            const waiter = (0, utils_1.defer)();
            this.client.setEventListener("Recording.sessionError", ({ message }) => waiter.resolve(`session error ${sessionId}: ${message}`));
            this.client.setEventListener("Session.unprocessedRegions", () => { });
            this.client
                .sendCommand("Session.ensureProcessed", { level: "basic" }, null, sessionId)
                .then(() => waiter.resolve(null));
            const error = yield waiter.promise;
            return error;
        });
    }
    connectionReportCrash(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            yield this.client.sendCommand("Internal.reportCrash", { data });
        });
    }
    uploadRecording(path, uploadLink, size) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = fs_1.default.createReadStream(path);
            const resp = yield (0, node_fetch_1.default)(uploadLink, {
                method: "PUT",
                headers: { "Content-Length": size.toString(), "User-Agent": (0, utils_1.getUserAgent)() },
                body: file,
            });
            if (resp.status !== 200) {
                debug(yield resp.text());
                throw new Error(`Failed to upload recording. Response was ${resp.status} ${resp.statusText}`);
            }
        });
    }
    uploadPart(link, partMeta, size, agentOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const worker = new worker_threads_1.Worker(path_1.default.join(__dirname, "./uploadWorker.js"));
                worker.on("message", resolve);
                worker.on("error", reject);
                worker.on("exit", code => {
                    if (code !== 0) {
                        reject(new Error(`Worker stopped with exit code ${code}`));
                    }
                });
                worker.postMessage({ link, partMeta, size, logPath: debug_1.logPath, agentOptions });
            });
        });
    }
    uploadRecordingInParts(filePath, partUploadLinks, partSize, agentOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const stats = fs_1.default.statSync(filePath);
            const totalSize = stats.size;
            const results = yield (0, p_map_1.default)(partUploadLinks, (url, index) => __awaiter(this, void 0, void 0, function* () {
                return (0, utils_1.linearBackoffRetry)(() => __awaiter(this, void 0, void 0, function* () {
                    const partNumber = index + 1;
                    const start = index * partSize;
                    const end = Math.min(start + partSize, totalSize) - 1; // -1 because end is inclusive
                    debug("Uploading part %o", {
                        partNumber,
                        start,
                        end,
                        totalSize,
                        partSize,
                    });
                    return this.uploadPart(url, { filePath, start, end }, end - start + 1, agentOptions);
                }), e => {
                    debug(`Failed to upload part ${index + 1}. Will be retried: %o`, e);
                }, 10);
            }), { concurrency: 10 });
            return results;
        });
    }
    connectionEndRecordingUpload(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            yield this.client.sendCommand("Internal.endRecordingUpload", {
                recordingId,
            });
        });
    }
    connectionEndRecordingMultipartUpload(recordingId, uploadId, eTags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            yield this.client.sendCommand("Internal.endRecordingMultipartUpload", {
                recordingId,
                uploadId,
                partIds: eTags,
            });
        });
    }
    connectionUploadSourcemap(recordingId, metadata, content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const resource = yield this.createResource(content);
            const { baseURL, targetContentHash, targetURLHash, targetMapURLHash } = metadata;
            const result = yield this.client.sendCommand("Recording.addSourceMap", {
                recordingId,
                resource,
                baseURL,
                targetContentHash,
                targetURLHash,
                targetMapURLHash,
            });
            return result.id;
        });
    }
    connectionUploadOriginalSource(recordingId, parentId, metadata, content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const resource = yield this.createResource(content);
            const { parentOffset } = metadata;
            yield this.client.sendCommand("Recording.addOriginalSource", {
                recordingId,
                resource,
                parentId,
                parentOffset,
            });
        });
    }
    createResource(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const hash = "sha256:" + sha256(content);
            const { token } = yield this.client.sendCommand("Resource.token", { hash });
            let resource = {
                token,
                saltedHash: "sha256:" + sha256(token + content),
            };
            const { exists } = yield this.client.sendCommand("Resource.exists", {
                resource,
            });
            if (!exists) {
                ({ resource } = yield this.client.sendCommand("Resource.create", { content }));
            }
            return resource;
        });
    }
    closeConnection() {
        if (this.client) {
            this.client.close();
            this.client = undefined;
            this.clientReady = (0, utils_1.defer)();
        }
    }
}
exports.ReplayClient = ReplayClient;
//# sourceMappingURL=upload.js.map