"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initLDContextFromApiKey = exports.maybeAuthenticateUser = exports.readToken = exports.pollForToken = void 0;
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("./debug"));
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const graphql_1 = require("./graphql");
const utils_1 = require("./utils");
const launchdarkly_1 = require("./launchdarkly");
const debug = (0, debug_1.default)("replay:cli:auth");
class GraphQLError extends Error {
    constructor(message, errors) {
        const errorsMessage = errors
            .map((e) => e.message)
            .filter(Boolean)
            .join(", ");
        super(`${message}: ${errorsMessage}`);
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
    }
}
function isInternalError(e) {
    if (typeof e === "object" && e && "id" in e) {
        return typeof e.id === "string";
    }
    return false;
}
function getAuthHost() {
    return process.env.REPLAY_AUTH_HOST || "webreplay.us.auth0.com";
}
function getAuthClientId() {
    return process.env.REPLAY_AUTH_CLIENT_ID || "4FvFnJJW4XlnUyrXQF8zOLw6vNAH1MAo";
}
function tokenInfo(token) {
    const [_header, encPayload, _cypher] = token.split(".", 3);
    if (typeof encPayload !== "string") {
        debug("Token did not contain a valid payload: %s", maskToken(token));
        return null;
    }
    let payload;
    try {
        payload = JSON.parse(Buffer.from(encPayload, "base64").toString());
    }
    catch (err) {
        debug("Failed to decode token: %s %e", maskToken(token), err);
        return null;
    }
    if (typeof payload !== "object") {
        debug("Token payload was not an object");
        return null;
    }
    return { payload };
}
function hasTokenExpired(token) {
    var _a;
    const userInfo = tokenInfo(token);
    const exp = (_a = userInfo === null || userInfo === void 0 ? void 0 : userInfo.payload) === null || _a === void 0 ? void 0 : _a.exp;
    debug("token expiration time: %d", exp ? exp * 1000 : 0);
    return exp != null && Date.now() - exp * 1000 > 0;
}
function maskToken(token) {
    return token.replace(/.(?!.{0,2}$)/g, "*");
}
function refresh(refreshToken) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const resp = yield fetch(`https://${getAuthHost()}/oauth/token`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    audience: "https://api.replay.io",
                    scope: "openid profile",
                    grant_type: "refresh_token",
                    client_id: getAuthClientId(),
                    refresh_token: refreshToken,
                }),
            });
            const json = yield resp.json();
            if (json.error) {
                debug("OAuth token request failed: %O", json.error);
                throw {
                    id: "auth0-error",
                    message: json.error,
                };
            }
            if (!json.access_token) {
                debug("OAuth token request was missing access token: %O", json);
                throw {
                    id: "no-access-token",
                };
            }
            return json.access_token;
        }
        catch (e) {
            throw Object.assign(Object.assign({}, e), { refreshToken: maskToken(refreshToken) });
        }
    });
}
function generateAuthKey() {
    const hash = (0, crypto_1.createHash)("sha256");
    hash.write(String(globalThis.performance.now()));
    return hash.digest("hex").toString();
}
function initAuthRequest(options = {}) {
    (0, utils_1.maybeLog)(options.verbose, "üåé Launching browser to login to replay.io");
    const key = generateAuthKey();
    const server = process.env.REPLAY_APP_SERVER || "https://app.replay.io";
    (0, child_process_1.spawn)((0, utils_1.openExecutable)(), [`${server}/api/browser/auth?key=${key}&source=cli`]);
    return key;
}
function fetchToken(key) {
    return __awaiter(this, void 0, void 0, function* () {
        const resp = yield (0, graphql_1.query)("CloseAuthRequest", `
        mutation CloseAuthRequest($key: String!) {
          closeAuthRequest(input: {key: $key}) {
            success
            token
          }
        }
      `, {
            key,
        });
        if (resp.errors) {
            if (resp.errors.length === 1 &&
                resp.errors[0].message === "Authentication request does not exist") {
                throw {
                    id: "missing-request",
                };
            }
            else {
                throw {
                    id: "close-graphql-error",
                    message: resp.errors
                        .map((e) => e.message)
                        .filter(Boolean)
                        .join(", "),
                };
            }
        }
        else if (!resp.data.closeAuthRequest.token) {
            // there's no obvious reason this would occur but for completeness ...
            throw {
                id: "close-missing-token",
                message: JSON.stringify(resp),
            };
        }
        const refreshToken = resp.data.closeAuthRequest.token;
        return refreshToken;
    });
}
function pollForToken(key_1) {
    return __awaiter(this, arguments, void 0, function* (key, options = {}) {
        let timedOut = false;
        setTimeout(() => {
            timedOut = true;
        }, 60 * 1000);
        while (true) {
            if (timedOut) {
                debug("Timed out waiting for auth request");
                throw { id: "timeout" };
            }
            try {
                const refreshToken = yield fetchToken(key);
                (0, utils_1.maybeLog)(options.verbose, "üîë Fetching token");
                return yield refresh(refreshToken);
            }
            catch (e) {
                if (e.id === "missing-request") {
                    debug("Auth request was not found. Retrying.");
                    yield new Promise(resolve => setTimeout(resolve, 3000));
                }
                else {
                    throw e;
                }
            }
        }
    });
}
exports.pollForToken = pollForToken;
function getTokenPath(options = {}) {
    const directory = (0, utils_1.getDirectory)(options);
    return path_1.default.resolve(path_1.default.join(directory, "profile", "auth.json"));
}
function readToken() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        try {
            const tokenPath = getTokenPath(options);
            const tokenJson = yield (0, promises_1.readFile)(tokenPath, { encoding: "utf-8" });
            const { token } = JSON.parse(tokenJson);
            if (hasTokenExpired(token)) {
                yield (0, promises_1.writeFile)(tokenPath, "{}");
                return;
            }
            if (typeof token !== "string") {
                throw new Error("Unexpect token value: " + token);
            }
            return token;
        }
        catch (e) {
            debug("Failed to read/write token file: %o", e);
            return;
        }
    });
}
exports.readToken = readToken;
function getApiKey() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        var _a, _b, _c;
        return ((_c = (_b = (_a = options.apiKey) !== null && _a !== void 0 ? _a : process.env.REPLAY_API_KEY) !== null && _b !== void 0 ? _b : process.env.RECORD_REPLAY_API_KEY) !== null && _c !== void 0 ? _c : (yield readToken(options)));
    });
}
function writeToken(token_1) {
    return __awaiter(this, arguments, void 0, function* (token, options = {}) {
        (0, utils_1.maybeLog)(options.verbose, "‚úçÔ∏è Saving token");
        const tokenPath = getTokenPath(options);
        yield (0, promises_1.mkdir)(path_1.default.dirname(tokenPath), { recursive: true });
        yield (0, promises_1.writeFile)(tokenPath, JSON.stringify({
            "// Docs": "This contains your app.replay.io authentication token. Do not share!",
            token,
        }, undefined, 2), { encoding: "utf-8" });
    });
}
function maybeAuthenticateUser() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        try {
            const key = initAuthRequest(options);
            const token = yield pollForToken(key, options);
            yield writeToken(token);
            (0, utils_1.maybeLog)(options.verbose, "‚úÖ Authentication complete!");
            return true;
        }
        catch (e) {
            debug("Failed to authenticate user: %o", e);
            if (isInternalError(e)) {
                if (e.id === "timeout") {
                    console.error("Timed out waiting for browser authentication. Please try again.");
                }
                else {
                    console.error("Failed to authenticate (reason: %s)", e.id);
                }
            }
            else {
                console.error("Failed to authenticate");
            }
            return false;
        }
    });
}
exports.maybeAuthenticateUser = maybeAuthenticateUser;
function getAuthInfo(key) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e;
        const resp = yield (0, graphql_1.query)("AuthInfo", `
        query AuthInfo {
          viewer {
            user {
              id
            }
          }
          auth {
            workspaces {
              edges {
                node {
                  id
                }
              }
            }
          }
        }
      `, undefined, key);
        if (resp.errors) {
            throw new GraphQLError("Failed to fetch auth info", resp.errors);
        }
        const response = resp.data;
        const { viewer, auth } = response;
        if ((_a = viewer === null || viewer === void 0 ? void 0 : viewer.user) === null || _a === void 0 ? void 0 : _a.id) {
            return viewer.user.id;
        }
        if ((_e = (_d = (_c = (_b = auth === null || auth === void 0 ? void 0 : auth.workspaces) === null || _b === void 0 ? void 0 : _b.edges) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.node) === null || _e === void 0 ? void 0 : _e.id) {
            return auth.workspaces.edges[0].node.id;
        }
        throw new Error("Unrecognized type of an API key: Missing both user ID and workspace ID.");
    });
}
function getAuthInfoCachePath(options = {}) {
    const directory = (0, utils_1.getDirectory)(options);
    return path_1.default.resolve(path_1.default.join(directory, "profile", "authInfo.json"));
}
// We don't want to store the API key in plain text, especially when provided
// via env or CLI arg. Hashing it would prevent leaking the key
function authInfoCacheKey(key) {
    return (0, crypto_1.createHash)("sha256").update(key).digest("hex");
}
function writeAuthInfoCache(key_1, authInfo_1) {
    return __awaiter(this, arguments, void 0, function* (key, authInfo, options = {}) {
        const cachePath = getAuthInfoCachePath(options);
        yield (0, promises_1.mkdir)(path_1.default.dirname(getAuthInfoCachePath(options)), { recursive: true });
        const cache = {
            [authInfoCacheKey(key)]: authInfo,
        };
        yield (0, promises_1.writeFile)(cachePath, JSON.stringify(cache, undefined, 2), { encoding: "utf-8" });
        return cache;
    });
}
function readAuthInfoCache(key_1) {
    return __awaiter(this, arguments, void 0, function* (key, options = {}) {
        try {
            const cachePath = getAuthInfoCachePath(options);
            const cacheJson = yield (0, promises_1.readFile)(cachePath, { encoding: "utf-8" });
            const cache = JSON.parse(cacheJson);
            return cache[authInfoCacheKey(key)];
        }
        catch (e) {
            debug("Failed to read auth info cache: %o", e);
            return;
        }
    });
}
function initLDContextFromApiKey() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        const apiKey = yield getApiKey(options);
        if (!apiKey) {
            return;
        }
        let targetId = yield readAuthInfoCache(apiKey, options);
        if (!targetId) {
            debug("Fetching auth info from server");
            targetId = yield getAuthInfo(apiKey);
            yield writeAuthInfoCache(apiKey, targetId, options);
        }
        yield (0, launchdarkly_1.getLaunchDarkly)().initialize().identify({ type: "user", id: targetId });
    });
}
exports.initLDContextFromApiKey = initLDContextFromApiKey;
//# sourceMappingURL=auth.js.map