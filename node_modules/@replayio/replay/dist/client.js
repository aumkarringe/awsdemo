"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolError = void 0;
const debug_1 = __importDefault(require("./debug"));
const ws_1 = __importDefault(require("ws"));
const utils_1 = require("./utils");
const debug = (0, debug_1.default)("replay:protocol");
class ProtocolError extends Error {
    constructor(err) {
        var _a;
        super(`protocol error ${err.code}: ${err.message}`);
        Object.defineProperty(this, "protocolCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "protocolMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "protocolData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.protocolCode = err.code;
        this.protocolMessage = err.message;
        this.protocolData = (_a = err.data) !== null && _a !== void 0 ? _a : {};
    }
    toString() {
        return `Protocol error ${this.protocolCode}: ${this.protocolMessage}`;
    }
}
exports.ProtocolError = ProtocolError;
class ProtocolClient {
    constructor(address, callbacks, agent) {
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pendingMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "eventListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "nextMessageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        debug("Creating WebSocket for %s with %o", address, { agent });
        this.socket = new ws_1.default(address, {
            agent: agent,
        });
        this.callbacks = callbacks;
        this.socket.on("open", callbacks.onOpen);
        this.socket.on("close", callbacks.onClose);
        this.socket.on("error", callbacks.onError);
        this.socket.on("message", message => this.onMessage(message));
    }
    close() {
        this.socket.close();
    }
    setAccessToken(accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            accessToken = accessToken || process.env.REPLAY_API_KEY || process.env.RECORD_REPLAY_API_KEY;
            if (!accessToken) {
                throw new Error("Access token must be passed or set via the REPLAY_API_KEY environment variable.");
            }
            return this.sendCommand("Authentication.setAccessToken", {
                accessToken,
            });
        });
    }
    sendCommand(method, params, data, sessionId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.nextMessageId++;
            debug("Sending command %s: %o", method, { id, params, sessionId });
            this.socket.send(JSON.stringify({
                id,
                method,
                params,
                binary: data ? true : undefined,
                sessionId,
            }), err => {
                if (!err && data) {
                    this.socket.send(data, callback);
                }
                else {
                    if (err) {
                        debug("Received socket error: %s", err);
                    }
                    callback === null || callback === void 0 ? void 0 : callback(err);
                }
            });
            const waiter = (0, utils_1.defer)();
            this.pendingMessages.set(id, waiter);
            return waiter.promise;
        });
    }
    setEventListener(method, callback) {
        this.eventListeners.set(method, callback);
    }
    onMessage(contents) {
        const msg = JSON.parse(String(contents));
        debug("Received message %o", msg);
        if (msg.id) {
            const { resolve, reject } = this.pendingMessages.get(msg.id);
            this.pendingMessages.delete(msg.id);
            if (msg.result) {
                resolve(msg.result);
            }
            else if (msg.error) {
                reject(new ProtocolError(msg.error));
            }
            else {
                reject(`Channel error: ${JSON.stringify(msg)}`);
            }
        }
        else if (this.eventListeners.has(msg.method)) {
            this.eventListeners.get(msg.method)(msg.params);
        }
        else {
            console.log(`Received event without listener: ${msg.method}`);
        }
    }
}
exports.default = ProtocolClient;
//# sourceMappingURL=client.js.map