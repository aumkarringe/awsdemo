{"version":3,"sources":["metabase/lib/schema/ref.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,AAEA,AAAAA,4CAAA,mHAAA,mFAAA,wDAAA,2CAAA,yEAEsB,WAAKC;AAAL,AACE,OAACC,wBAAc,WAAKC;AAAL,AACE,SAAI,AAACC,gCAAgBD,QACjB,oEAAA,pEAACE,6CAAE,AAACC,oBAAUH;GACpBF;WANvC,+GAAA,mFAAA,mDAAA,mFAAA,wEAAA,2CAAA,6DAAA,aAAA,mFAAA,mDAAA,gJAAA,mFAAA,2DAAA,2CAAA,6DAAA,aAAA,mFAAA,mDAAA,gIAAA,mFAAA,4HAAA,2CAAA,6DAAA,aAAA,mFAAA,mDAAA;AAaA,AAAAD,4CAAA,oIAAA,mFAAA,wDAAA,mHAAA,mFAAA,mDAAA,mFAAA,+DAAA,mFAAA,mDAAA;AAOA,AAAAA,4CAAA,qHAAA,mFAAA,uDAAA,mFAAA,+CAAA,gEAAA,oIAAA;AAMA,AAAAA,4CAAA,0GAAA,mFAAA,uDAAA,mFAAA,+CAAA,gEAAA,mHAAA;AAMA,iFAAA,wDAAA,mFAAA,mDAAA,mFAAA,uDAAA,mFAAA,+CAAA,2CAAA,+HAAA,gEAAA,mFAAA,mDAAA,2HAAA,mFAAA,gDAAA,kGAAA,iJAAA,mFAAA,uDAAA,2CAAA,jjDAACO,gpBAG0BC,89BAGA,WAAKC;AAAL,AAGE,GAAM,AAACC,4BAAYD;AAAnB,AACE,IAAAE,aAAgCF;aAAhC,AAAAG,4CAAAD,WAAA,IAAA,pEAAOE;YAAP,AAAAD,4CAAAD,WAAA,IAAA,nEAAcG;iBAAd,AAAAF,4CAAAD,WAAA,IAAA,xEAAoBI;AAApB,AACE,OAACC,qCAA4BD;;AAFjC;;GAT7B,oEAAA,wEAAA,mFAAA,oFAAA,kHAAA,mFAAA,iFAAA;AAkBA,8BAAA,wDAAA,tFAACE;AAED,AAAAC,0FAAA,wDAAA,WAAAC;AAAA,AAAA,IAAAC,aAAAD;WAAA,AAAAP,4CAAAQ,WAAA,IAAA,lEACIC;WADJ,AAAAT,4CAAAQ,WAAA,IAAA,lEACSnB;kBADT,AAAAW,4CAAAQ,WAAA,IAAA,zEACcE;AADd,AAEE,IAAAC,mBAAI,AAAC,gDAAA,yEAAA,zHAACC,yLAAoCvB;AAA1C,AAAA,oBAAAsB;AAAAA;;AAAA;;;AAGF,8FAAA,kHAAA,hNAACE;AAGD,AAAAP,0FAAA,gEAAA,WAAAQ;AAAA,AAAA,IAAAC,aAAAD;WAAA,AAAAd,4CAAAe,WAAA,IAAA,lEACIN;WADJ,AAAAT,4CAAAe,WAAA,IAAA,lEACS1B;uBADT,AAAAW,4CAAAe,WAAA,IAAA,9EACcC;AADd,AAEE,IAAAL,mBAAI,AAAC,gDAAA,yEAAA,zHAACC,yLAAoCvB;AAA1C,AAAA,oBAAAsB;AAAAA;;AAAA;;;AAGF,8BAAA,gEAAA,9FAACN;AAED,AAAAjB,4CAAA,+HAAA,mFAAA,wDAAA,+GAAA,mFAAA,mDAAA,mFAAA,qDAAA,2CAAA,6DAAA,aAAA,yIAAA,mFAAA,oEAAA,2CAAA,6DAAA,aAAA,yIAAA,mFAAA,wEAAA,2CAAA,6DAAA,aAAA;AAQA,iFAAA,mEAAA,mFAAA,uDAAA,mFAAA,+CAAA,2CAAA,+HAAA,2EAAA,+HAAA,pxBAACO,qhBAEyBC;AAI1B,AAAAU,0FAAA,mEAAA,WAAAW;AAAA,AAAA,IAAAC,aAAAD;WAAA,AAAAjB,4CAAAkB,WAAA,IAAA,lEACIT;WADJ,AAAAT,4CAAAkB,WAAA,IAAA,lEACS7B;aADT,AAAAW,4CAAAkB,WAAA,IAAA,pEACcC;AADd,AAEE,IAAAR,mBAAI,AAAC,gDAAA,yEAAA,zHAACC,yLAAoCvB;AAA1C,AAAA,oBAAAsB;AAAAA;;AAAA;;;AAGF,8BAAA,mEAAA,jGAACN;AAED,8FAAA,6GAAA,gDAAA,gEAAA,mFAAA,0DAAA,mFAAA,mDAAA,9kBAACQ;AAGD,8BAAA,2DAAA,zFAACR;AAED,8FAAA,0GAAA,gDAAA,+HAAA,mFAAA,0DAAA,mFAAA,mDAAA,1oBAACQ;AAOD,8BAAA,wDAAA,tFAACR;AAED,AAAAjB,4CAAA,iGAAA,mFAAA,mDAAA,qHAAA,mFAAA,kDAAA,2CAAA,2DAIe,WAAKgC,EAAEA;AAAP,AACE,QAAA,kDACK,kDAAA,lDAACC,uDAAc,AAACC,6CAAK,oDAAA,AAAAC,kDAAA,tGAACC,oEAAaC;WACrD,WAAAC;AAAA,AAAA,IAAAC,aAAAD;UAAA,AAAA1B,4CAAA2B,WAAA,IAAA,jEAAMC;cAAND,VAAcE;AAAd,AACE,6CAAA,tCAACC,kCAAmBF","names":["metabase.util.malli.registry/register!","opts","medley.core/filter-keys","k","cljs.core/simple-keyword?","cljs.core._EQ_","cljs.core/namespace","metabase.lib.schema.mbql_clause.define_mbql_clause","metabase.lib.schema.common/normalize-keyword","clause","cljs.core/sequential?","vec__75776","cljs.core.nth","_field","_opts","id-or-name","metabase.lib.dispatch/dispatch-value","metabase.lib.hierarchy/derive","metabase.lib.schema.expression/type-of-method","p__75787","vec__75788","_tag","_id-or-name","or__5002__auto__","cljs.core.some_fn","metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","p__75840","vec__75841","_expression-name","p__75844","vec__75845","_index","_","clojure.string.join","cljs.core.sort","cljs.core/deref","cljs.core.descendants","metabase.lib.hierarchy/hierarchy","p__75848","vec__75849","tag","_clause","metabase.lib.hierarchy/isa?"],"sourcesContent":["(ns metabase.lib.schema.ref\n  \"Malli schema for a Field, aggregation, or expression reference (etc.)\"\n  (:require\n   [clojure.string :as str]\n   [medley.core :as m]\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.schema.binning :as binning]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.id :as id]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.types]\n   [metabase.util.malli.registry :as mr]))\n\n(comment metabase.types/keep-me)\n\n(mr/def ::field.options\n  [:merge\n   {:encode/serialize (fn [opts]\n                        (m/filter-keys (fn [k]\n                                         (or (simple-keyword? k)\n                                             (= (namespace k) \"lib\")))\n                                       opts))}\n   ::common/options\n   [:map\n    [:temporal-unit                              {:optional true} [:ref ::temporal-bucketing/unit]]\n    [:binning                                    {:optional true} [:ref ::binning/binning]]\n    [:metabase.lib.field/original-effective-type {:optional true} [:ref ::common/base-type]]]])\n\n(mr/def ::field.literal.options\n  [:merge\n   ::field.options\n   [:map\n    [:base-type [:ref ::common/base-type]]]])\n\n;;; `:field` clause\n(mr/def ::field.literal\n  [:tuple\n   [:= :field]\n   ::field.literal.options\n   ::common/non-blank-string])\n\n(mr/def ::field.id\n  [:tuple\n   [:= :field]\n   ::field.options ; TODO -- we should make `:base-type` required here too\n   ::id/field])\n\n(mbql-clause/define-mbql-clause :field\n  [:and\n   [:tuple\n    [:= {:decode/normalize common/normalize-keyword} :field]\n    [:ref ::field.options]\n    [:or ::id/field ::common/non-blank-string]]\n   [:multi {:dispatch      (fn [clause]\n                             ;; apparently it still tries to dispatch when humanizing errors even if the `:tuple`\n                             ;; schema above failed, so we need to check that this is actually a tuple here again.\n                             (when (sequential? clause)\n                               (let [[_field _opts id-or-name] clause]\n                                 (lib.dispatch/dispatch-value id-or-name))))\n            ;; without this it gives us dumb messages like \"Invalid dispatch value\" if the dispatch function above\n            ;; doesn't return something that matches.\n            :error/message \"Invalid :field clause ID or name: must be a string or integer\"}\n    [:dispatch-type/integer ::field.id]\n    [:dispatch-type/string ::field.literal]]])\n\n(lib.hierarchy/derive :field ::ref)\n\n(defmethod expression/type-of-method :field\n  [[_tag opts _id-or-name]]\n  (or ((some-fn :effective-type :base-type) opts)\n      ::expression/type.unknown))\n\n(mbql-clause/define-tuple-mbql-clause :expression\n  #_expression-name ::common/non-blank-string)\n\n(defmethod expression/type-of-method :expression\n  [[_tag opts _expression-name]]\n  (or ((some-fn :effective-type :base-type) opts)\n      ::expression/type.unknown))\n\n(lib.hierarchy/derive :expression ::ref)\n\n(mr/def ::aggregation-options\n  [:merge\n   ::common/options\n   [:map\n    [:name {:optional true} ::common/non-blank-string]\n    [:display-name {:optional true} ::common/non-blank-string]\n    [:lib/source-name {:optional true} ::common/non-blank-string]]])\n\n(mbql-clause/define-mbql-clause :aggregation\n  [:tuple\n   [:= {:decode/normalize common/normalize-keyword} :aggregation]\n   ::aggregation-options\n   :string])\n\n(defmethod expression/type-of-method :aggregation\n  [[_tag opts _index]]\n  (or ((some-fn :effective-type :base-type) opts)\n      ::expression/type.unknown))\n\n(lib.hierarchy/derive :aggregation ::ref)\n\n(mbql-clause/define-tuple-mbql-clause :segment :- :type/Boolean\n  #_segment-id [:schema [:ref ::id/segment]])\n\n(lib.hierarchy/derive :segment ::ref)\n\n(mbql-clause/define-tuple-mbql-clause :metric :- ::expression/type.unknown\n  ;; String references are allowed to support legacy questions\n  ;; (see metabase.lib.convert-test/round-trip-test for examples).\n  ;; :string should be removed once the legacy questions don't have to be\n  ;; supported.\n  #_metric-id [:schema [:ref ::id/metric]])\n\n(lib.hierarchy/derive :metric ::ref)\n\n(mr/def ::ref\n  [:and\n   ::mbql-clause/clause\n   [:fn\n    {:error/fn (fn [_ _]\n                 (str \"Valid reference, must be one of these clauses: \"\n                      (str/join \", \" (sort (descendants @lib.hierarchy/hierarchy ::ref)))))}\n    (fn [[tag :as _clause]]\n      (lib.hierarchy/isa? tag ::ref))]])\n"]}