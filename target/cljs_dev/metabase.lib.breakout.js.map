{"version":3,"sources":["metabase/lib/breakout.cljc"],"mappings":"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","names":["metabase.lib.metadata.calculation/describe-top-level-key-method","query","stage-number","_k","temp__5804__auto__","breakouts","cljs.core/not-empty","metabase.lib.util/query-stage","metabase.shared.util.i18n.js_i18n","clojure.string.join","metabase.shared.util.i18n/js-i18n","iter__5480__auto__","s__78930","cljs.core/LazySeq","cljs.core/seq","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","cljs.core/count","b__78932","cljs.core/chunk-buffer","i__78931","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__78929","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","breakout","metabase.lib.metadata.calculation.display_name","metabase.lib.breakout/breakout","expr","metabase.lib.ref/ref","cljs.core/fn?","metabase.lib.util/add-summary-clause","metabase.lib.breakout/breakouts","metabase.lib.breakout/breakouts-metadata","G__78933","metabase.lib.breakout.breakouts","cljs.core.mapv","field-ref","metabase.lib.metadata.calculation.metadata","cljs.core.assoc","metabase.lib.breakout/breakoutable-columns","cols","stage","options","metabase.lib.metadata.calculation.visible_columns","matching","cljs.core.into","cljs.core.keep_indexed","index","a-breakout","col","metabase.lib.equality.find_matching_column","or__5002__auto__","p1__78934#","vec__78936","cljs.core.nth","map__78939","cljs.core/--destructure-map","cljs.core.get","pos","binning","metabase.lib.binning/binning","unit","metabase.lib.temporal-bucket/temporal-bucket","G__78940","metabase.lib.binning/with-binning","metabase.lib.temporal-bucket/with-temporal-bucket","p__78941","map__78944","metabase.lib.breakout/existing-breakouts","column","same-temporal-bucket?","_options","cljs.core.filter","and__5000__auto__","cljs.core._EQ_","metabase.lib.breakout/breakout-column?","metabase.lib.breakout.existing_breakouts","metabase.lib.breakout/remove-existing-breakouts-for-column","cljs.core.reduce","metabase.lib.remove_replace.remove_clause","metabase.lib.breakout/breakout-column","breakout-ref","metabase.lib.breakout.breakoutable_columns","metabase.lib.breakout/remove-all-breakouts","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.lib.breakout\n  (:require\n   [clojure.string :as str]\n   [metabase.lib.binning :as lib.binning]\n   [metabase.lib.equality :as lib.equality]\n   [metabase.lib.metadata.calculation :as lib.metadata.calculation]\n   [metabase.lib.ref :as lib.ref]\n   [metabase.lib.remove-replace :as lib.remove-replace]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.expression :as lib.schema.expression]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.schema.ref :as lib.schema.ref]\n   [metabase.lib.temporal-bucket :as lib.temporal-bucket]\n   [metabase.lib.util :as lib.util]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util.malli :as mu]))\n\n(defmethod lib.metadata.calculation/describe-top-level-key-method :breakout\n  [query stage-number _k]\n  (when-let [breakouts (not-empty (:breakout (lib.util/query-stage query stage-number)))]\n    (i18n/tru \"Grouped by {0}\"\n              (str/join (str \\space (i18n/tru \"and\") \\space)\n                        (for [breakout breakouts]\n                          (lib.metadata.calculation/display-name query stage-number breakout :long))))))\n\n(mu/defn breakout :- ::lib.schema/query\n  \"Add a new breakout on an expression, presumably a Field reference.\"\n  ([query expr]\n   (breakout query -1 expr))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int\n    expr         :- some?]\n   (let [expr (lib.ref/ref (if (fn? expr)\n                             (expr query stage-number)\n                             expr))]\n     (lib.util/add-summary-clause query stage-number :breakout expr))))\n\n(mu/defn breakouts :- [:maybe [:sequential ::lib.schema.expression/expression]]\n  \"Return the current breakouts\"\n  ([query]\n   (breakouts query -1))\n  ([query :- ::lib.schema/query\n    stage-number :- :int]\n   (not-empty (:breakout (lib.util/query-stage query stage-number)))))\n\n(mu/defn breakouts-metadata :- [:maybe [:sequential ::lib.schema.metadata/column]]\n  \"Get metadata about the breakouts in a given stage of a `query`.\"\n  ([query]\n   (breakouts-metadata query -1))\n  ([query        :- ::lib.schema/query\n    stage-number :- :int]\n   (some->> (breakouts query stage-number)\n            (mapv (fn [field-ref]\n                    (-> (lib.metadata.calculation/metadata query stage-number field-ref)\n                        (assoc :lib/source :source/breakouts)))))))\n\n(mu/defn breakoutable-columns :- [:sequential ::lib.schema.metadata/column]\n  \"Get column metadata for all the columns that can be broken out by in\n  the stage number `stage-number` of the query `query`\n  If `stage-number` is omitted, the last stage is used.\n  The rules for determining which columns can be broken out by are as follows:\n\n  1. custom `:expressions` in this stage of the query\n\n  2. Fields 'exported' by the previous stage of the query, if there is one;\n     otherwise Fields from the current `:source-table`\n\n  3. Fields exported by explicit joins\n\n  4. Fields in Tables that are implicitly joinable.\"\n\n  ([query :- ::lib.schema/query]\n   (breakoutable-columns query -1))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int]\n   (let [cols (let [stage   (lib.util/query-stage query stage-number)\n                    options {:include-implicitly-joinable-for-source-card? false}]\n                (lib.metadata.calculation/visible-columns query stage-number stage options))]\n     (when (seq cols)\n       (let [matching (into {} (keep-indexed (fn [index a-breakout]\n                                               (when-let [col (lib.equality/find-matching-column\n                                                               query stage-number a-breakout cols\n                                                               {:generous? true})]\n                                                 [col [index a-breakout]]))\n                                             (or (breakouts query stage-number) [])))]\n         (mapv #(let [[pos a-breakout] (matching %)\n                      binning (lib.binning/binning a-breakout)\n                      {:keys [unit]} (lib.temporal-bucket/temporal-bucket a-breakout)]\n                  (cond-> (assoc % :lib/hide-bin-bucket? true)\n                    binning (lib.binning/with-binning binning)\n                    unit (lib.temporal-bucket/with-temporal-bucket unit)\n                    pos (assoc :breakout-position pos)))\n               cols))))))\n\n(mu/defn existing-breakouts :- [:maybe [:sequential {:min 1} ::lib.schema.ref/ref]]\n  \"Returns existing breakouts (as MBQL expressions) for `column` in a stage if there are any. Returns `nil` if there\n  are no existing breakouts.\"\n  ([query stage-number column]\n   (existing-breakouts query stage-number column nil))\n\n  ([query                                         :- ::lib.schema/query\n    stage-number                                  :- :int\n    column                                        :- ::lib.schema.metadata/column\n    {:keys [same-temporal-bucket?], :as _options} :- [:maybe\n                                                      [:map\n                                                       [:same-temporal-bucket? {:optional true} [:maybe :boolean]]]]]\n   (not-empty\n    (into []\n          (filter (fn [a-breakout]\n                    (and (lib.equality/find-matching-column query stage-number a-breakout [column] {:generous? true})\n                         (if same-temporal-bucket?\n                           (= (lib.temporal-bucket/temporal-bucket a-breakout)\n                              (lib.temporal-bucket/temporal-bucket column))\n                           true))))\n          (breakouts query stage-number)))))\n\n(defn breakout-column?\n  \"Returns if `column` is a breakout column of stage with `stage-number` of `query`.\"\n  [query stage-number column]\n  (seq (existing-breakouts query stage-number column)))\n\n(mu/defn remove-existing-breakouts-for-column :- ::lib.schema/query\n  \"Remove all existing breakouts against `column` if there are any in the stage in question. Disregards temporal\n  bucketing and binning.\"\n  ([query column]\n   (remove-existing-breakouts-for-column query -1 column))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int\n    column       :- ::lib.schema.metadata/column]\n   (reduce\n    (fn [query a-breakout]\n      (lib.remove-replace/remove-clause query stage-number a-breakout))\n    query\n    (existing-breakouts query stage-number column))))\n\n(mu/defn breakout-column :- ::lib.schema.metadata/column\n  \"Returns the input column used for this breakout.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   breakout-ref :- ::lib.schema.ref/ref]\n  (->> (breakoutable-columns query stage-number)\n       (lib.equality/find-matching-column breakout-ref)))\n\n(mu/defn remove-all-breakouts :- ::lib.schema/query\n  \"Remove all breakouts from a query stage.\"\n  ([query]\n   (remove-all-breakouts query -1))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int]\n   (reduce\n    (fn [query a-breakout]\n      (lib.remove-replace/remove-clause query stage-number a-breakout))\n    query\n    (breakouts query stage-number))))\n"]}