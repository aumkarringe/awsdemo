{"version":3,"sources":["metabase/lib/segment.cljc"],"mappings":"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","names":["metabase.lib.segment/resolve-segment","query","segment-id","cljs.core/integer?","metabase.lib.metadata/segment","metabase.lib.ref/ref-method","p__79766","map__79767","cljs.core/--destructure-map","cljs.core.get","id","metabase.lib.options/ensure-uuid","metabase.lib.metadata.calculation/type-of-method","_query","_stage-number","_metric-metadata","_segment-clause","metabase.lib.segment/fallback-display-name","metabase.shared.util.i18n/js-i18n","metabase.lib.metadata.calculation/display-name-method","segment-metadata","_style","or__5002__auto__","p__79778","vec__79779","cljs.core.nth","stage-number","_tag","_opts","segment-id-or-name","style","temp__5804__auto__","metabase.lib.metadata.calculation.display_name","metabase.lib.metadata.calculation/display-info-method","p__79786","map__79787","description","filter-positions","default-display-info-method","cljs.core/get-method","default-display-info","G__79788","cljs.core.assoc","p__79790","vec__79792","temp__5802__auto__","metabase.lib.metadata.calculation.display_info","metabase.lib.segment/available-segments","metabase.lib.util/canonical-stage-index","source-table-id","metabase.lib.util/source-table-id","segments","metabase.lib.metadata.protocols/segments","metabase.lib.metadata/->metadata-provider","segment-filters","cljs.core.into","cljs.core.keep_indexed","index","filter-clause","metabase.lib.util/clause-of-type?","metabase.lib.filter.filters","cljs.core/empty?","cljs.core/vec","cljs.core.mapv","filter-pos","G__79815","G__79816"],"sourcesContent":["(ns metabase.lib.segment\n  \"A Segment is a saved MBQL query stage snippet with `:filter`. Segments are always boolean expressions.\"\n  (:require\n   [metabase.lib.filter :as lib.filter]\n   [metabase.lib.metadata :as lib.metadata]\n   [metabase.lib.metadata.calculation :as lib.metadata.calculation]\n   [metabase.lib.metadata.protocols :as lib.metadata.protocols]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.ref :as lib.ref]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.util :as lib.util]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util.malli :as mu]))\n\n(defn- resolve-segment [query segment-id]\n  (when (integer? segment-id)\n    (lib.metadata/segment query segment-id)))\n\n(defmethod lib.ref/ref-method :metadata/segment\n  [{:keys [id]}]\n  (lib.options/ensure-uuid [:segment {} id]))\n\n(defmethod lib.metadata.calculation/type-of-method :metadata/segment\n  [_query _stage-number _metric-metadata]\n  :type/Boolean)\n\n(defmethod lib.metadata.calculation/type-of-method :segment\n  [_query _stage-number _segment-clause]\n  :type/Boolean)\n\n(defn- fallback-display-name []\n  (i18n/tru \"[Unknown Segment]\"))\n\n(defmethod lib.metadata.calculation/display-name-method :metadata/segment\n  [_query _stage-number segment-metadata _style]\n  (or (:display-name segment-metadata)\n      (:name segment-metadata)\n      (fallback-display-name)))\n\n(defmethod lib.metadata.calculation/display-name-method :segment\n  [query stage-number [_tag _opts segment-id-or-name] style]\n  (or (when (integer? segment-id-or-name)\n        (when-let [segment-metadata (lib.metadata/segment query segment-id-or-name)]\n          (lib.metadata.calculation/display-name query stage-number segment-metadata style)))\n      (fallback-display-name)))\n\n(defmethod lib.metadata.calculation/display-info-method :metadata/segment\n  [query stage-number {:keys [description filter-positions], :as segment-metadata}]\n  (let [default-display-info-method (get-method lib.metadata.calculation/display-info-method :default)\n        default-display-info        (default-display-info-method query stage-number segment-metadata)]\n    (cond-> default-display-info\n      description (assoc :description description)\n      filter-positions (assoc :filter-positions filter-positions))))\n\n(defmethod lib.metadata.calculation/display-info-method :segment\n  [query stage-number [_tag _opts segment-id-or-name]]\n  (if-let [segment-metadata (resolve-segment query segment-id-or-name)]\n    (lib.metadata.calculation/display-info query stage-number segment-metadata)\n    {:effective-type    :type/Boolean\n     :display-name      (fallback-display-name)\n     :long-display-name (fallback-display-name)}))\n\n(mu/defn available-segments :- [:maybe [:sequential {:min 1} ::lib.schema.metadata/segment]]\n  \"Get a list of Segments that you may consider using as filter for a query. Only Segments that have the same\n  `table-id` as the `source-table` for this query will be suggested.\"\n  ([query]\n   (available-segments query -1))\n  ([query :- ::lib.schema/query\n    stage-number :- :int]\n   (when (zero? (lib.util/canonical-stage-index query stage-number))\n     (when-let [source-table-id (lib.util/source-table-id query)]\n       (let [segments (lib.metadata.protocols/segments (lib.metadata/->metadata-provider query) source-table-id)\n             segment-filters (into {}\n                                   (keep-indexed (fn [index filter-clause]\n                                                   (when (lib.util/clause-of-type? filter-clause :segment)\n                                                     [(get filter-clause 2) index])))\n                                   (lib.filter/filters query 0))]\n         (cond\n           (empty? segments)        nil\n           (empty? segment-filters) (vec segments)\n           :else                    (mapv (fn [segment-metadata]\n                                            (let [filter-pos (-> segment-metadata :id segment-filters)]\n                                              (cond-> segment-metadata\n                                                ;; even though at most one filter can reference a given segment\n                                                ;; we use plural in order to keep the interface used with\n                                                ;; plain filters referencing columns\n                                                filter-pos (assoc :filter-positions [filter-pos]))))\n                                          segments)))))))\n"]}