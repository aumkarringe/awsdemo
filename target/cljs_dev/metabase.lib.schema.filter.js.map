{"version":3,"sources":["metabase/lib/schema/filter.cljc"],"mappings":"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","names":["metabase.lib.schema.filter/tuple-clause-of-comparables-schema","compared-position-pairs","js/Error","tag","args","cljs.core/simple-keyword?","cljs.core.apply","metabase.lib.schema.mbql-clause/tuple-clause-schema","p__75405","vec__75406","seq__75407","cljs.core/seq","first__75408","cljs.core/first","cljs.core/next","_tag","_opts","argv","cljs.core/vec","or__5002__auto__","metabase.lib.schema.expression/*suppress-expression-type-check?*","cljs.core/every?","cljs.core/true?","cljs.core.map","p__75409","vec__75410","cljs.core.nth","i","j","metabase.lib.schema.expression/comparable-expressions?","cljs.core.get","seq__75417","chunk__75418","count__75419","i__75420","temp__5804__auto__","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","op","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","seq__75425","chunk__75426","count__75427","i__75428","seq__75429","chunk__75430","count__75431","i__75432","metabase.lib.schema.mbql_clause.define_mbql_clause_with_schema_fn","seq__75492","chunk__75493","count__75494","i__75495","seq__75521","chunk__75522","count__75523","i__75524","metabase.lib.schema.filter/string-filter-options","seq__75525","chunk__75526","count__75527","i__75528","metabase.lib.schema.mbql_clause.define_mbql_clause","metabase.lib.schema.common/normalize-keyword","metabase.lib.schema.filter/time-interval-options","cljs.core.some_fn","cljs.core/keyword?","cljs.core/string?","metabase.util.malli.registry/register!"],"sourcesContent":["(ns metabase.lib.schema.filter\n  \"Schemas for the various types of filter clauses that you'd pass to `:filters` or use inside something else that takes\n  a boolean expression.\"\n  (:require\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.id :as id]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.util.malli.registry :as mr]))\n\n(defn- tuple-clause-of-comparables-schema\n  \"Helper intended for use with [[define-mbql-clause]]. Create a clause schema with `:tuple` and ensure that\n  the elements of `args` at positions specified by the pairs in `compared-position-pairs` can be compared.\"\n  [compared-position-pairs]\n  (fn [tag & args]\n    {:pre [(simple-keyword? tag)]}\n    [:and\n     (apply mbql-clause/tuple-clause-schema tag args)\n     [:fn\n      {:error/message \"arguments should be comparable\"}\n      (fn [[_tag _opts & args]]\n        (let [argv (vec args)]\n          (or expression/*suppress-expression-type-check?*\n              (every? true? (map (fn [[i j]]\n                                   (expression/comparable-expressions? (get argv i) (get argv j)))\n                                 compared-position-pairs)))))]]))\n\n(doseq [op [:and :or]]\n  (mbql-clause/define-catn-mbql-clause op :- :type/Boolean\n    [:args [:repeat {:min 2} [:schema [:ref ::expression/boolean]]]]))\n\n(mbql-clause/define-tuple-mbql-clause :not :- :type/Boolean\n  [:ref ::expression/boolean])\n\n(doseq [op [:= :!=]]\n  (mbql-clause/define-catn-mbql-clause op :- :type/Boolean\n    [:args [:repeat {:min 2} [:schema [:ref ::expression/equality-comparable]]]]))\n\n(doseq [op [:< :<= :> :>=]]\n  (mbql-clause/define-mbql-clause-with-schema-fn (tuple-clause-of-comparables-schema #{[0 1]})\n    op :- :type/Boolean\n    #_x [:ref ::expression/orderable]\n    #_y [:ref ::expression/orderable]))\n\n(mbql-clause/define-mbql-clause-with-schema-fn (tuple-clause-of-comparables-schema #{[0 1] [0 2]})\n  :between :- :type/Boolean\n  ;; TODO -- should we enforce that min is <= max (for literal number values?)\n  #_expr [:ref ::expression/orderable]\n  #_min  [:ref ::expression/orderable]\n  #_max  [:ref ::expression/orderable])\n\n;; sugar: a pair of `:between` clauses\n(mbql-clause/define-mbql-clause-with-schema-fn (tuple-clause-of-comparables-schema #{[0 2] [0 4] [1 3] [1 5]})\n  :inside :- :type/Boolean\n  ;; TODO -- should we enforce that lat-min <= lat-max and lon-min <= lon-max? Should we enforce that -90 <= lat 90\n  ;; and -180 <= lon 180 ?? (for literal number values)\n  #_lat-expr [:ref ::expression/orderable]\n  #_lon-expr [:ref ::expression/orderable]\n  #_lat-max  [:ref ::expression/orderable]  ; north\n  #_lon-min  [:ref ::expression/orderable]  ; west\n  #_lat-min  [:ref ::expression/orderable]  ; south\n  #_lon-max  [:ref ::expression/orderable]) ; east\n\n;;; null checking expressions\n;;;\n;;; these are sugar for [:= ... nil] and [:!= ... nil] respectively\n(doseq [op [:is-null :not-null]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Boolean\n    [:ref ::expression/expression]))\n\n;;; :is-empty is sugar for [:or [:= ... nil] [:= ... \"\"]] for emptyable arguments\n;;; :not-empty is sugar for [:and [:!= ... nil] [:!= ... \"\"]] for emptyable arguments\n;;; For non emptyable arguments expansion is same with :is-null and :not-null\n(doseq [op [:is-empty :not-empty]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Boolean\n    [:ref ::expression/expression]))\n\n(def ^:private string-filter-options\n  [:map [:case-sensitive {:optional true} :boolean]]) ; default true\n\n;; N-ary [:ref ::expression/string] filter clauses. These also accept a `:case-sensitive` option.\n;; Requires at least 2 string-shaped args. If there are more than 2, `[:contains x a b]` is equivalent to\n;; `[:or [:contains x a] [:contains x b]]`.\n;;\n;; `[:does-not-contain ...]` = `[:not [:contains ...]]`\n(doseq [op [:starts-with :ends-with :contains :does-not-contain]]\n  (mbql-clause/define-mbql-clause op :- :type/Boolean\n    [:schema [:catn {:error/message (str \"Valid \" op \" clause\")}\n              [:tag [:= {:decode/normalize common/normalize-keyword} op]]\n              [:options [:merge ::common/options string-filter-options]]\n              [:args [:repeat {:min 2} [:schema [:ref ::expression/string]]]]]]))\n\n(def ^:private time-interval-options\n  [:map [:include-current {:optional true} :boolean]]) ; default false\n\n;; SUGAR: rewritten as a filter clause with a relative-datetime value\n(mbql-clause/define-mbql-clause :time-interval :- :type/Boolean\n  ;; TODO -- we should probably further constrain this so you can't do weird stuff like\n  ;;\n  ;;    [:time-interval {} <time> :current :year]\n  ;;\n  ;; using units that don't agree with the expr type\n  [:tuple\n   [:= {:decode/normalize common/normalize-keyword} :time-interval]\n   [:merge ::common/options time-interval-options]\n   #_expr [:ref ::expression/temporal]\n   #_n    [:multi\n           {:dispatch (some-fn keyword? string?)}\n           [true  [:enum {:decode/normalize common/normalize-keyword} :current :last :next]]\n           ;; I guess there's no reason you shouldn't be able to do something like 1 + 2 in here\n           [false [:ref ::expression/integer]]]\n   #_unit [:ref ::temporal-bucketing/unit.date-time.interval]])\n\n;; segments are guaranteed to return valid filter clauses and thus booleans, right?\n(mbql-clause/define-mbql-clause :segment :- :type/Boolean\n  [:tuple\n   [:= {:decode/normalize common/normalize-keyword} :segment]\n   ::common/options\n   [:multi\n    {:dispatch string?}\n    [true  ::common/non-blank-string]\n    [false ::id/segment]]])\n\n(mr/def ::operator\n  [:map\n   [:lib/type [:= :operator/filter]]\n   [:short [:enum := :!= :inside :between :< :> :<= :>= :is-null :not-null :is-empty :not-empty :contains :does-not-contain :starts-with :ends-with]]\n   ;; this is used for display name and it depends on the arguments to the filter clause itself... e.g.\n   ;;\n   ;; number_a < number_b\n   ;;\n   ;; gets a display name of \"less than\" for the operator, while\n   ;;\n   ;; timestamp_a < timestamp_b\n   ;;\n   ;; gets a display name of \"before\" for the operator. We don't want to encode the display name in the `::operator`\n   ;; definition itself, because it forces us to do i18n in the definition itself; it's nicer to have static\n   ;; definitions and only add the display name when we call `display-name` or `display-info`.\n   [:display-name-variant :keyword]])\n"]}