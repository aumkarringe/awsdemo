{"version":3,"sources":["metabase/lib/schema/literal.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA,AAAAA,0FAAA,6EAAA,WACGC;AADH,AAAA;;AAIA,AAAAD,0FAAA,mFAAA,WACGE;AADH,AAAA;;AASA,AAAAC,4CAAA,iHAAA;AAOA,AAAAH,0FAAA,oFAAA,WACGI;AADH,AAAA;;AAMA,AAAAD,4CAAA,kIAAA;AAOA,AAAAH,0FAAA,kFAAA,WACGK;AADH,AAAA;;AAOA,AAAAF,4CAAA,wHAAA,mFAAA,gDAAA,2CAAA,oEAAA,8BAGGG;AAEH,AAAAH,4CAAA,sIAAA,mFAAA,gDAAA,2CAAA,oEAAA,yCAGGI;AAEH,AAAAJ,4CAAA,wHAAA,mFAAA,gDAAA,mFAAA,gDAAA,2CAAA,oEAAA,uGAAA,mFAAA,gDAAA,2CAAA,oEAAA,rTAIIK,0VAGAC;AAEJ,AAAAN,4CAAA,iIAAA,mFAAA,gDAAA,mFAAA,gDAAA,2CAAA,oEAAA,gHAAA,mFAAA,gDAAA,2CAAA,oEAAA,zTAIIO,mWAGAC;AAEJ,AAAAX,0FAAA,iFAAA,WACGY;AADH,AAEE,IAAAC,cAAOE;IAAPD,cAAmBF;AAAnB,AAAA,oBAAA,CAAAC,4CAAAA,0CAAA,iIAAAC,eAAAD,sBAAA,iIAAAC;AAAA,wFAAA,gEAAA;;AAAA,oBAAA,CAAAD,4CAAAA,0CAAA,wHAAAC,eAAAD,sBAAA,wHAAAC;AAAA,wFAAA,iEAAA;;AAAA,oBAAA,CAAAD,4CAAAA,0CAAA,wHAAAC,eAAAD,sBAAA,wHAAAC;AAAA,wFAAA,iEAAA;;AAAA;;;;;AAMF,AAAAX,4CAAA,0GAAA;AAQA,AAAAA,4CAAA,0GAAA;AAYA,AAAAA,4CAAA,iHAAA;AAcA,AAAAA,4CAAA,kHAAA,mFAAA,gDAAA,0GAAA,0GAAA;AAQA,AAAAA,4CAAA,qIAAA,mFAAA,gDAAA,2CAAA,oEAAA,oCAGGa;AAEH,AAAAb,4CAAA,wHAAA,mFAAA,gDAAA,2CAAA,oEAAA,8BAGGc;AAMH,AAAAd,4CAAA,6HAAA,mFAAA,wDAAA,mFAAA,mDAAA,uHAAA,mFAAA,mDAAA,mFAAA,yEAAA;AAeA,iFAAA,sDAAA,mFAAA,uDAAA,2CAAA,oEAAA,8BAAA,mFAAA,+CAAA,2CAAA,+HAAA,8DAAA,mFAAA,mDAAA,94BAACe,qpBAGiCC,8XAEvBC;AAEX,AAAAjB,4CAAA,gHAAA,mFAAA,gDAAA,iDAAA,4DAAA,0DAAA,iHAAA,kIAAA","names":["metabase.lib.schema.expression/type-of-method","_nil","_bool","metabase.util.malli.registry/register!","_int","_non-integer-real","metabase.shared.util.internal.time-common/local-date-regex","metabase.shared.util.internal.time-common/zone-offset-part-regex","metabase.shared.util.internal.time-common/local-time-regex","metabase.shared.util.internal.time-common/offset-time-regex","metabase.shared.util.internal.time-common/local-datetime-regex","metabase.shared.util.internal.time-common/offset-datetime-regex","s","pred__75135","expr__75136","metabase.util.malli.registry/validate","metabase.shared.util.internal.time-common/year-month-regex","metabase.shared.util.internal.time-common/year-regex","metabase.lib.schema.mbql_clause.define_mbql_clause","metabase.lib.schema.common/normalize-keyword","cljs.core/any?"],"sourcesContent":["(ns metabase.lib.schema.literal\n  \"Malli schemas for string, temporal, number, and boolean literals.\"\n  (:require\n   #?@(:clj ([metabase.lib.schema.literal.jvm]))\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.shared.util.internal.time-common :as shared.ut.common]\n   [metabase.util.malli.registry :as mr]\n   #?@(:clj\n       ([java-time.api :as t]))))\n\n(defmethod expression/type-of-method :dispatch-type/nil\n  [_nil]\n  :type/*)\n\n(defmethod expression/type-of-method :dispatch-type/boolean\n  [_bool]\n  :type/Boolean)\n\n#?(:clj\n   (defn- big-int? [x]\n     (or (instance? java.math.BigInteger x)\n         (instance? clojure.lang.BigInt x))))\n\n(mr/def ::integer\n  #?(:clj [:multi\n           {:dispatch big-int?}\n           [true  :metabase.lib.schema.literal.jvm/big-integer]\n           [false :int]]\n     :cljs :int))\n\n(defmethod expression/type-of-method :dispatch-type/integer\n  [_int]\n  :type/Integer)\n\n;;; we should probably also restrict this to disallow NaN and positive/negative infinity, I don't know in what\n;;; universe we'd want to allow those if they're not disallowed already.\n(mr/def ::non-integer-real\n  #?(:clj [:or\n           :double\n           :metabase.lib.schema.literal.jvm/float\n           :metabase.lib.schema.literal.jvm/big-decimal]\n     :cljs :double))\n\n(defmethod expression/type-of-method :dispatch-type/number\n  [_non-integer-real]\n  ;; `:type/Float` is the 'base type' of all non-integer real number types in [[metabase.types]] =(\n  :type/Float)\n\n;;; TODO -- these temporal literals could be a little stricter, right now they are pretty permissive, you shouldn't be\n;;; allowed to have month `13` or `02-29` for example\n(mr/def ::string.date\n  [:re\n   {:error/message \"date string literal\"}\n   shared.ut.common/local-date-regex])\n\n(mr/def ::string.zone-offset\n  [:re\n   {:error/message \"timezone offset string literal\"}\n   shared.ut.common/zone-offset-part-regex])\n\n(mr/def ::string.time\n  [:or\n   [:re\n    {:error/message \"local time string literal\"}\n    shared.ut.common/local-time-regex]\n   [:re\n    {:error/message \"offset time string literal\"}\n    shared.ut.common/offset-time-regex]])\n\n(mr/def ::string.datetime\n  [:or\n   [:re\n    {:error/message \"local date time string literal\"}\n    shared.ut.common/local-datetime-regex]\n   [:re\n    {:error/message \"offset date time string literal\"}\n    shared.ut.common/offset-datetime-regex]])\n\n(defmethod expression/type-of-method :dispatch-type/string\n  [s]\n  (condp mr/validate s\n    ::string.datetime #{:type/Text :type/DateTime}\n    ::string.date     #{:type/Text :type/Date}\n    ::string.time     #{:type/Text :type/Time}\n    :type/Text))\n\n(mr/def ::date\n  #?(:clj  [:or\n            [:time/local-date\n             {:error/message    \"instance of java.time.LocalDate\"\n              :encode/serialize str}]\n            ::string.date]\n     :cljs ::string.date))\n\n(mr/def ::time\n  #?(:clj [:or\n           {:doc/title \"time literal\"}\n           ::string.time\n           [:time/local-time\n            {:error/message    \"instance of java.time.LocalTime\"\n             :encode/serialize str}]\n           [:time/offset-time\n            {:error/message    \"instance of java.time.OffsetTime\"\n             :encode/serialize str}]]\n     :cljs ::string.time))\n\n(mr/def ::datetime\n  #?(:clj [:or\n           ::string.datetime\n           [:time/local-date-time\n            {:error/message    \"instance of java.time.LocalDateTime\"\n             :encode/serialize str}]\n           [:time/offset-date-time\n            {:error/message    \"instance of java.time.OffsetDateTime\"\n             :encode/serialize str}]\n           [:time/zoned-date-time\n            {:error/message    \"instance of java.time.ZonedDateTime\"\n             :encode/serialize #(str (t/offset-date-time %))}]]\n     :cljs ::string.datetime))\n\n(mr/def ::temporal\n  [:or\n   ::date\n   ::time\n   ::datetime])\n\n;;; these are currently only allowed inside `:absolute-datetime`\n\n(mr/def ::string.year-month\n  [:re\n   {:error/message \"year-month string literal\"}\n   shared.ut.common/year-month-regex])\n\n(mr/def ::string.year\n  [:re\n   {:error/message \"year string literal\"}\n   shared.ut.common/year-regex])\n\n;;; `:effective-type` is required for `:value` clauses. This was not a rule in the legacy MBQL schema, but in actual\n;;; usage they basically always have `:base-type`; in MLv2 we're trying to use `:effective-type` everywhere instead;\n;;; These clauses are useless/pointless without type information anyway, so let's enforce this rule going forward.\n;;; Conversion can take care of `:base-type` <=> `:effective-type` as needed.\n(mr/def ::value.options\n  [:merge\n   [:ref ::common/options]\n   [:map\n    [:effective-type ::common/base-type]]])\n\n;;; [:value <opts> <value>] clauses are mostly used internally by the query processor to add type information to\n;;; literals, to make it easier for drivers to process queries; see\n;;; the [[metabase.query-processor.middleware.wrap-value-literals]] middleware. It is also used to differentiate `nil`\n;;; (as in no clause or value) from something intended to be `NULL` in a compiled query, and to associate type\n;;; information with that `nil`. Even if this is mostly used internally, the schema still needs to know about it.\n;;;\n;;; The schema itself does not currently enforce that the actual <value> matches up with the `:effective-type` in the\n;;; options map; this is only enforced in the QP. For now, it assumes you know what you are doing and takes your word\n;;; for it when you say something has a given `:effective-type`.\n(mbql-clause/define-mbql-clause :value\n  [:tuple\n   {:error/message \"Value :value clause\"}\n   #_tag   [:= {:decode/normalize common/normalize-keyword} :value]\n   #_opts  [:ref ::value.options]\n   #_value any?])\n\n(mr/def ::literal\n  [:or\n   :nil\n   :boolean\n   :string\n   ::integer\n   ::non-integer-real\n   ::temporal])\n"]}