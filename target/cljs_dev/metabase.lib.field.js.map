{"version":3,"sources":["metabase/lib/field.cljc"],"mappings":"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","names":["metabase.lib.field/resolve-column-name-in-metadata","column-name","column-metadatas","or__5002__auto__","cljs.core/some","k","p1__78935#","medley.core.find_first","cljs.core._EQ_","cljs.core.get","level__73199__auto__","metabase.util.log/glogi-level","logger__73200__auto__","metabase.util.log/is-loggable?","x__73201__auto__","js/Error","lambdaisland.glogi.log","metabase.util.log.format_msg","cljs.core.pr_str","cljs.core.mapv","metabase.lib.field/*recursive-column-resolution-by-name*","metabase.lib.field/resolve-column-name","query","stage-number","*recursive-column-resolution-by-name*-orig-val__78942","*recursive-column-resolution-by-name*-temp-val__78943","previous-stage-number","metabase.lib.util/previous-stage-number","stage","metabase.lib.util/query-stage","stage-columns","cljs.core.get_in","metabase.lib.metadata.calculation.visible_columns","metabase.util.log/format-msg","temp__5804__auto__","column","and__5000__auto__","cljs.core/seq","G__78945","cljs.core.dissoc","metabase.lib.join/with-join-alias","cljs.core.assoc","p__78948","vec__78949","cljs.core.nth","map__78952","cljs.core/--destructure-map","metabase.lib.field/resolve-field-metadata","_field","join-alias","opts","id-or-name","_field-clause","metadata","cljs.core.merge","base-type","effective-type","cljs.core.some_fn","binning","unit","cljs.core/integer?","metabase.lib.equality/resolve-field-id","G__78955","metabase.lib.field/add-parent-column-metadata","map__78956","parent-metadata","metabase.lib.metadata/field","parent-name","parent-display-name","G__78957","cljs.core.update","field-name","display-name","p__78958","map__78959","metabase.lib.field/column-metadata-effective-type","temporal-unit","column-metadata","cljs.core/contains?","metabase.lib.schema.temporal-bucketing/datetime-extraction-units","metabase.lib.metadata.calculation/type-of-method","_query","_stage-number","p__78960","vec__78961","map__78964","_tag","_opts","_id-or-name","field-ref","G__78965","metabase.lib.metadata.calculation.type_of","metabase.lib.metadata.calculation/metadata-method","p__78966","map__78967","field-metadata","p__78968","vec__78969","map__78972","metabase.lib.field/extend-column-metadata-from-ref","source-uuid","source-field","metabase.lib.metadata.calculation.display_name","G__78973","G__78974","p__78975","map__78976","metabase.lib.field/field-nesting-path","metadata-providerable","parent-id","_field-metadata","field-id","path","cljs.core/List","map__78978","cljs.core.conj","metabase.lib.field/nest-display-name","cljs.core/every?","cljs.core/some?","clojure.string.join","metabase.lib.metadata.calculation/display-name-method","p__78979","map__78980","field-display-name","fk-field-id","table-id","simple-display-name","hide-bin-bucket?","style","humanized-name","metabase.util.humanization/name->human-readable-name","join-display-name","clojure.string/includes?","temp__5802__auto__","field","metabase.lib.metadata.calculation.display_info","metabase.lib.util/strip-id","table","metabase.lib.metadata/table-or-card","metabase.lib.join.util/current-join-alias","temporal-format","G__78981","G__78982","G__78983","metabase.lib.util/format","cljs.core/name","clojure.string/replace","metabase.util/capitalize-en","bin-format","G__78984","G__78985","G__78986","metabase.lib.binning/binning-display-name","cljs.core.not_EQ_","p__78987","vec__78988","map__78991","field-clause","G__78992","metabase.shared.util.i18n/js-i18n","metabase.lib.metadata.calculation/column-name-method","p__78993","map__78994","p__78995","vec__78996","metabase.lib.metadata.calculation.column_name","metabase.lib.metadata.calculation/display-info-method","fexpr__78999","cljs.core/get-method","description","fingerprint","card-id","card","metabase.lib.metadata/card","metabase.lib.temporal-bucket/temporal-bucket-method","p__79000","vec__79001","metabase.lib.temporal-bucket/with-temporal-bucket-method","p__79004","vec__79005","options","extraction-unit?","original-effective-type","new-effective-type","metabase.lib.temporal-bucket/available-temporal-buckets-method","metabase.lib.temporal_bucket.available_temporal_buckets","metabase.lib.field/fingerprint-based-default-unit","e79008","_","map__79009","earliest","latest","days","metabase.shared.util.time.day_diff","metabase.shared.util.time.coerce_to_timestamp","cljs.core/NaN?","pred__79010","expr__79011","cljs.core/>","metabase.lib.field/mark-unit","option-key","G__79014","p1__79013#","option","G__79015","fingerprint-default","G__79016","G__79017","cljs.core.isa_QMARK_","metabase.lib.temporal-bucket/datetime-bucket-options","metabase.lib.temporal-bucket/date-bucket-options","metabase.lib.temporal-bucket/time-bucket-options","metabase.lib.binning/binning-method","G__79018","metabase.lib.options/options","G__79019","cljs.core/constantly","metabase.lib.binning/with-binning-method","metabase.lib.options.update_options","metabase.util/assoc-dissoc","metabase.lib.binning/available-binning-strategies-method","metabase.lib.binning.available_binning_strategies","p__79020","map__79021","semantic-type","binning?","G__79022","metabase.lib.metadata/database","existing","metabase.lib.binning/binning","strategies","cljs.core/not","metabase.lib.binning/coordinate-binning-strategies","metabase.lib.binning/numeric-binning-strategies","iter__5480__auto__","s__79024","cljs.core/LazySeq","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","cljs.core/count","b__79026","cljs.core/chunk-buffer","i__79025","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__79023","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","strat","G__79027","G__79028","metabase.lib.binning/strategy=","metabase.lib.ref/ref-method","metabase.lib.field/column-metadata->field-ref","inherited-column?","G__79030","fexpr__79029","cljs.core/random-uuid","source-alias","source-field-id","p__79033","map__79034","source","G__79035","cljs.core/Keyword","metabase.lib.aggregation/column-metadata->aggregation-ref","metabase.lib.expression/column-metadata->expression-ref","metabase.lib.field/expression-columns","p1__79036#","cljs.core.filter","metabase.lib.field/with-fields","xs","cljs.core/not-empty","metabase.lib.ref/ref","expr-cols","included","cljs.core.into","p1__79037#","cljs.core.keep","metabase.lib.equality.find_matching_column","to-add","cljs.core.remove","cljs.core.map","metabase.lib.util.update_query_stage","metabase.lib.field/fields","metabase.lib.field/fieldable-columns","visible-columns","selected-fields","metabase.lib.field.fields","cljs.core/empty?","col","metabase.lib.equality.mark_selected_columns","metabase.lib.field/populate-fields-for-stage","defaults","metabase.lib.metadata.calculation/default-columns-for-stage","cljs.core/assoc","metabase.lib.field/query-with-fields","G__79041","metabase.lib.field/include-field","populated","field-refs","match-ref","metabase.lib.equality/find-matching-ref","column-ref","cljs.core/last","cljs.core/update","cljs.core/conj","metabase.lib.field/add-field-to-join","vec__79042","join","s__79046","b__79048","i__79047","iter__79045","metabase.lib.join.joins","joinables","metabase.lib.join/joinable-columns","join-fields","metabase.lib.join/join-fields","metabase.lib.remove_replace.replace_join","metabase.lib.join/with-join-fields","metabase.lib.field/native-query-fields-edit-error","metabase.lib.field/source-clauses-only-fields-edit-error","metabase.lib.field/add-field","G__79049","G__79050","cljs.core.ex_info","metabase.lib.remove_replace.normalize_fields_clauses","metabase.lib.field/remove-matching-ref","refs","match","p1__79051#","metabase.lib.field/exclude-field","old-fields","new-fields","G__79052","metabase.lib.field/remove-field-from-join","metabase.lib.join/resolve-join","resolved-join-fields","metabase.lib.metadata.calculation.returned_columns","removed","G__79053","metabase.lib.field/remove-field","G__79054","metabase.lib.field/find-visible-column-for-ref","columns","fexpr__79055","metabase.lib.dispatch/dispatch-value","metabase.lib.metadata.calculation/returned-columns","metabase.lib.metadata.calculation/visible-columns","metabase.lib.field/json-field?","metabase.util.malli.registry/register!","p__79056","map__79057","metabase.lib.field/infer-has-field-values","has-field-values","metabase.lib.types.isa/searchable?","metabase.lib.field/remapped-field","metabase.lib.types.isa/foreign-key?","remap-field-id","metabase.lib.field/search-field","metabase.lib.types.isa/primary-key?","name-field","metabase.util/the-id","metabase.lib.field/field-values-search-info","column-field-id","search-field-id","cljs.core/int?","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.lib.field\n  (:require\n   [clojure.string :as str]\n   [medley.core :as m]\n   [metabase.lib.aggregation :as lib.aggregation]\n   [metabase.lib.binning :as lib.binning]\n   [metabase.lib.card :as lib.card]\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.equality :as lib.equality]\n   [metabase.lib.expression :as lib.expression]\n   [metabase.lib.join :as lib.join]\n   [metabase.lib.join.util :as lib.join.util]\n   [metabase.lib.metadata :as lib.metadata]\n   [metabase.lib.metadata.calculation :as lib.metadata.calculation]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.ref :as lib.ref]\n   [metabase.lib.remove-replace :as lib.remove-replace]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.schema.temporal-bucketing\n    :as lib.schema.temporal-bucketing]\n   [metabase.lib.temporal-bucket :as lib.temporal-bucket]\n   [metabase.lib.types.isa :as lib.types.isa]\n   [metabase.lib.util :as lib.util]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.shared.util.time :as shared.ut]\n   [metabase.util :as u]\n   [metabase.util.humanization :as u.humanization]\n   [metabase.util.log :as log]\n   [metabase.util.malli :as mu]\n   [metabase.util.malli.registry :as mr]))\n\n(mu/defn resolve-column-name-in-metadata :- [:maybe ::lib.schema.metadata/column]\n  \"Find the column with `column-name` in a sequence of `column-metadatas`.\"\n  [column-name      :- ::lib.schema.common/non-blank-string\n   column-metadatas :- [:sequential ::lib.schema.metadata/column]]\n  (or (some (fn [k]\n              (m/find-first #(= (get % k) column-name)\n                            column-metadatas))\n            [:lib/desired-column-alias :name])\n      (do\n        (log/warnf \"Invalid :field clause: column %s does not exist. Found: %s\"\n                   (pr-str column-name)\n                   (pr-str (mapv :lib/desired-column-alias column-metadatas)))\n        nil)))\n\n(def ^:private ^:dynamic *recursive-column-resolution-by-name*\n  \"Whether we're in a recursive call to [[resolve-column-name]] or not. Prevent infinite recursion (#32063)\"\n  false)\n\n(mu/defn ^:private resolve-column-name :- [:maybe ::lib.schema.metadata/column]\n  \"String column name: get metadata from the previous stage, if it exists, otherwise if this is the first stage and we\n  have a native query or a Saved Question source query or whatever get it from our results metadata.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   column-name  :- ::lib.schema.common/non-blank-string]\n  (when-not *recursive-column-resolution-by-name*\n    (binding [*recursive-column-resolution-by-name* true]\n      (let [previous-stage-number (lib.util/previous-stage-number query stage-number)\n            stage                 (if previous-stage-number\n                                    (lib.util/query-stage query previous-stage-number)\n                                    (lib.util/query-stage query stage-number))\n            ;; TODO -- it seems a little icky that the existence of `:metabase.lib.stage/cached-metadata` is leaking\n            ;; here, we should look in to fixing this if we can.\n            stage-columns         (or (:metabase.lib.stage/cached-metadata stage)\n                                      (get-in stage [:lib/stage-metadata :columns])\n                                      (when (or (:source-card  stage)\n                                                (:source-table stage)\n                                                (:expressions  stage)\n                                                (:fields       stage))\n                                        (lib.metadata.calculation/visible-columns query stage-number stage))\n                                      (log/warnf \"Cannot resolve column %s: stage has no metadata\"\n                                                 (pr-str column-name)))]\n        (when-let [column (and (seq stage-columns)\n                               (resolve-column-name-in-metadata column-name stage-columns))]\n          (cond-> column\n            previous-stage-number (-> (dissoc :id :table-id\n                                              ::binning ::temporal-unit)\n                                      (lib.join/with-join-alias nil)\n                                      (assoc :name (or (:lib/desired-column-alias column) (:name column)))\n                                      (assoc :lib/source :source/previous-stage))))))))\n\n(mu/defn ^:private resolve-field-metadata :- ::lib.schema.metadata/column\n  \"Resolve metadata for a `:field` ref. This is part of the implementation\n  for [[lib.metadata.calculation/metadata-method]] a `:field` clause.\"\n  [query                                                                 :- ::lib.schema/query\n   stage-number                                                          :- :int\n   [_field {:keys [join-alias], :as opts} id-or-name, :as _field-clause] :- :mbql.clause/field]\n  (let [metadata (merge\n                  (when-let [base-type (:base-type opts)]\n                    {:base-type base-type})\n                  (when-let [effective-type ((some-fn :effective-type :base-type) opts)]\n                    {:effective-type effective-type})\n                  ;; TODO -- some of the other stuff in `opts` probably ought to be merged in here as well. Also, if\n                  ;; the Field is temporally bucketed, the base-type/effective-type would probably be affected, right?\n                  ;; We should probably be taking that into consideration?\n                  (when-let [binning (:binning opts)]\n                    {::binning binning})\n                  (when-let [unit (:temporal-unit opts)]\n                    {::temporal-unit unit})\n                  (cond\n                    (integer? id-or-name) (or (lib.equality/resolve-field-id query stage-number id-or-name)\n                                              {:lib/type :metadata/column, :name (str id-or-name)})\n                    join-alias            {:lib/type :metadata/column, :name (str id-or-name)}\n                    :else                 (or (resolve-column-name query stage-number id-or-name)\n                                              {:lib/type :metadata/column, :name (str id-or-name)})))]\n    (cond-> metadata\n      join-alias (lib.join/with-join-alias join-alias))))\n\n(mu/defn ^:private add-parent-column-metadata\n  \"If this is a nested column, add metadata about the parent column.\"\n  [query    :- ::lib.schema/query\n   metadata :- ::lib.schema.metadata/column]\n  (let [parent-metadata\n        (lib.metadata/field query (:parent-id metadata))\n\n        {parent-name :name, parent-display-name :display-name}\n        (cond->> parent-metadata\n          (:parent-id parent-metadata) (add-parent-column-metadata query))]\n    (-> metadata\n        (assoc :lib/simple-name (:name metadata))\n        (update :name (fn [field-name]\n                        (str parent-name \\. field-name)))\n        (assoc ::simple-display-name (:display-name metadata))\n        (update :display-name (fn [display-name]\n                                (str parent-display-name \": \" display-name))))))\n\n(defn- column-metadata-effective-type\n  \"Effective type of a column when taking the `::temporal-unit` into account. If we have a temporal extraction like\n  `:month-of-year`, then this actually returns an integer rather than the 'original` effective type of `:type/Date` or\n  whatever.\"\n  [{::keys [temporal-unit], :as column-metadata}]\n  (if (and temporal-unit\n           (contains? lib.schema.temporal-bucketing/datetime-extraction-units temporal-unit))\n    :type/Integer\n    ((some-fn :effective-type :base-type) column-metadata)))\n\n(defmethod lib.metadata.calculation/type-of-method :metadata/column\n  [_query _stage-number column-metadata]\n  (column-metadata-effective-type column-metadata))\n\n(defmethod lib.metadata.calculation/type-of-method :field\n  [query stage-number [_tag {:keys [temporal-unit], :as _opts} _id-or-name :as field-ref]]\n  (let [metadata (cond-> (resolve-field-metadata query stage-number field-ref)\n                   temporal-unit (assoc ::temporal-unit temporal-unit))]\n    (lib.metadata.calculation/type-of query stage-number metadata)))\n\n(defmethod lib.metadata.calculation/metadata-method :metadata/column\n  [_query _stage-number {field-name :name, :as field-metadata}]\n  (assoc field-metadata :name field-name))\n\n(defn extend-column-metadata-from-ref\n  \"Extend column metadata `metadata` with information specific to `field-ref` in `query` at stage `stage-number`.\n  `metadata` should be the metadata of a resolved field or a visible column matching `field-ref`.\"\n  [query\n   stage-number\n   metadata\n   [_tag {source-uuid :lib/uuid :keys [base-type binning effective-type join-alias source-field temporal-unit], :as opts} :as field-ref]]\n  (let [metadata (merge\n                  {:lib/type        :metadata/column\n                   :lib/source-uuid source-uuid}\n                  metadata\n                  {:display-name (or (:display-name opts)\n                                     (lib.metadata.calculation/display-name query stage-number field-ref))})]\n    (cond-> metadata\n      effective-type (assoc :effective-type effective-type)\n      base-type      (assoc :base-type base-type)\n      temporal-unit  (assoc ::temporal-unit temporal-unit)\n      binning        (assoc ::binning binning)\n      source-field   (assoc :fk-field-id source-field)\n      join-alias     (lib.join/with-join-alias join-alias))))\n\n;;; TODO -- effective type should be affected by `temporal-unit`, right?\n(defmethod lib.metadata.calculation/metadata-method :field\n  [query stage-number field-ref]\n  (let [field-metadata (resolve-field-metadata query stage-number field-ref)\n        metadata       (extend-column-metadata-from-ref query stage-number field-metadata field-ref)]\n    (cond->> metadata\n      (:parent-id metadata) (add-parent-column-metadata query))))\n\n(defn- field-nesting-path\n  [metadata-providerable {:keys [display-name parent-id] :as _field-metadata}]\n  (loop [field-id parent-id, path (list display-name)]\n    (if field-id\n      (let [{:keys [display-name parent-id]} (lib.metadata/field metadata-providerable field-id)]\n        (recur parent-id (conj path display-name)))\n      path)))\n\n(defn- nest-display-name\n  [metadata-providerable field-metadata]\n  (let [path (field-nesting-path metadata-providerable field-metadata)]\n    (when (every? some? path)\n      (str/join \": \" path))))\n\n;;; this lives here as opposed to [[metabase.lib.metadata]] because that namespace is more of an interface namespace\n;;; and moving this there would cause circular references.\n(defmethod lib.metadata.calculation/display-name-method :metadata/column\n  [query stage-number {field-display-name  :display-name\n                       field-name          :name\n                       temporal-unit       :unit\n                       binning             ::binning\n                       join-alias          :source-alias\n                       fk-field-id         :fk-field-id\n                       table-id            :table-id\n                       parent-id           :parent-id\n                       simple-display-name ::simple-display-name\n                       hide-bin-bucket?    :lib/hide-bin-bucket?\n                       :as                 field-metadata} style]\n  (let [humanized-name (u.humanization/name->human-readable-name :simple field-name)\n        field-display-name (or simple-display-name\n                               (when (and parent-id\n                                          ;; check that we haven't nested yet\n                                          (or (nil? field-display-name)\n                                              (= field-display-name humanized-name)))\n                                 (nest-display-name query field-metadata))\n                               field-display-name\n                               (if (string? field-name)\n                                 humanized-name\n                                 (str field-name)))\n        join-display-name  (when (and (= style :long)\n                                      ;; don't prepend a join display name if `:display-name` already contains one!\n                                      ;; Legacy result metadata might include it for joined Fields, don't want to add\n                                      ;; it twice. Otherwise we'll end up with display names like\n                                      ;;\n                                      ;;    Products \u2192 Products \u2192 Category\n                                      (not (str/includes? field-display-name \" \u2192 \")))\n                             (or\n                              (when fk-field-id\n                                ;; Implicitly joined column pickers don't use the target table's name, they use the FK field's name with\n                                ;; \"ID\" dropped instead.\n                                ;; This is very intentional: one table might have several FKs to one foreign table, each with different\n                                ;; meaning (eg. ORDERS.customer_id vs. ORDERS.supplier_id both linking to a PEOPLE table).\n                                ;; See #30109 for more details.\n                                (if-let [field (lib.metadata/field query fk-field-id)]\n                                  (-> (lib.metadata.calculation/display-info query stage-number field)\n                                      :display-name\n                                      lib.util/strip-id)\n                                  (let [table (lib.metadata/table-or-card query table-id)]\n                                    (lib.metadata.calculation/display-name query stage-number table style))))\n                              (or join-alias (lib.join.util/current-join-alias field-metadata))))\n        display-name       (if join-display-name\n                             (str join-display-name \" \u2192 \" field-display-name)\n                             field-display-name)\n        temporal-format    (fn [display-name]\n                             (lib.util/format \"%s: %s\" display-name (-> (name temporal-unit)\n                                                                        (str/replace \\- \\space)\n                                                                        u/capitalize-en)))\n        bin-format         (fn [display-name]\n                             (lib.util/format \"%s: %s\" display-name (lib.binning/binning-display-name binning field-metadata)))]\n    ;; temporal unit and binning formatting are only applied if they haven't been applied yet\n    (cond\n      (and (not= style :long) hide-bin-bucket?) display-name\n      (and temporal-unit (not= display-name (temporal-format humanized-name))) (temporal-format display-name)\n      (and binning       (not= display-name (bin-format humanized-name)))      (bin-format display-name)\n      :else                                                                    display-name)))\n\n(defmethod lib.metadata.calculation/display-name-method :field\n  [query\n   stage-number\n   [_tag {:keys [binning join-alias temporal-unit source-field], :as _opts} _id-or-name, :as field-clause]\n   style]\n  (if-let [field-metadata (cond-> (resolve-field-metadata query stage-number field-clause)\n                            join-alias    (assoc :source-alias join-alias)\n                            temporal-unit (assoc :unit temporal-unit)\n                            binning       (assoc ::binning binning)\n                            source-field  (assoc :fk-field-id source-field))]\n    (lib.metadata.calculation/display-name query stage-number field-metadata style)\n    ;; mostly for the benefit of JS, which does not enforce the Malli schemas.\n    (i18n/tru \"[Unknown Field]\")))\n\n(defmethod lib.metadata.calculation/column-name-method :metadata/column\n  [_query _stage-number {field-name :name}]\n  field-name)\n\n(defmethod lib.metadata.calculation/column-name-method :field\n  [query stage-number [_tag _id-or-name, :as field-clause]]\n  (if-let [field-metadata (resolve-field-metadata query stage-number field-clause)]\n    (lib.metadata.calculation/column-name query stage-number field-metadata)\n    ;; mostly for the benefit of JS, which does not enforce the Malli schemas.\n    \"unknown_field\"))\n\n(defmethod lib.metadata.calculation/display-info-method :metadata/column\n  [query stage-number field-metadata]\n  (merge\n   ((get-method lib.metadata.calculation/display-info-method :default) query stage-number field-metadata)\n   ;; These have to be calculated even if the metadata has display-name to support nested fields\n   ;; because the query processor doesn't produce nested display-names.\n   {:display-name (lib.metadata.calculation/display-name query stage-number field-metadata)\n    :long-display-name (lib.metadata.calculation/display-name query stage-number field-metadata :long)}\n   ;; Include description and fingerprint if they're present on the column. Only proper fields or columns from a model\n   ;; have these, not aggregations or expressions.\n   (when-let [description (:description field-metadata)]\n     {:description description})\n   (when-let [fingerprint (:fingerprint field-metadata)]\n     {:fingerprint fingerprint})\n   ;; if this column comes from a source Card (Saved Question/Model/etc.) use the name of the Card as the 'table' name\n   ;; rather than the ACTUAL table name.\n   (when (= (:lib/source field-metadata) :source/card)\n     (when-let [card-id (:lib/card-id field-metadata)]\n       (when-let [card (lib.metadata/card query card-id)]\n         {:table {:name (:name card), :display-name (:name card)}})))))\n\n;;; ---------------------------------- Temporal Bucketing ----------------------------------------\n\n;;; TODO -- it's a little silly to make this a multimethod I think since there are exactly two implementations of it,\n;;; right? Or can expression and aggregation references potentially be temporally bucketed as well? Think about\n;;; whether just making this a plain function like we did for [[metabase.lib.join/with-join-alias]] makes sense or not.\n\n(defmethod lib.temporal-bucket/temporal-bucket-method :field\n  [[_tag opts _id-or-name]]\n  (:temporal-unit opts))\n\n(defmethod lib.temporal-bucket/temporal-bucket-method :metadata/column\n  [metadata]\n  (::temporal-unit metadata))\n\n(defmethod lib.temporal-bucket/with-temporal-bucket-method :field\n  [[_tag options id-or-name] unit]\n  ;; if `unit` is an extraction unit like `:month-of-year`, then the `:effective-type` of the ref changes to\n  ;; `:type/Integer` (month of year returns an int). We need to record the ORIGINAL effective type somewhere in case\n  ;; we need to refer back to it, e.g. to see what temporal buckets are available if we want to change the unit, or if\n  ;; we want to remove it later. We will record this with the key `::original-effective-type`. Note that changing the\n  ;; unit multiple times should keep the original first value of `::original-effective-type`.\n  (if unit\n    (let [extraction-unit?        (contains? lib.schema.temporal-bucketing/datetime-extraction-units unit)\n          original-effective-type ((some-fn ::original-effective-type :effective-type :base-type) options)\n          new-effective-type      (if extraction-unit?\n                                    :type/Integer\n                                    original-effective-type)\n          options                 (assoc options\n                                         :temporal-unit unit\n                                         :effective-type new-effective-type\n                                         ::original-effective-type original-effective-type)]\n      [:field options id-or-name])\n    ;; `unit` is `nil`: remove the temporal bucket.\n    (let [options (if-let [original-effective-type (::original-effective-type options)]\n                    (-> options\n                        (assoc :effective-type original-effective-type)\n                        (dissoc ::original-effective-type))\n                    options)\n          options (dissoc options :temporal-unit)]\n      [:field options id-or-name])))\n\n(defmethod lib.temporal-bucket/with-temporal-bucket-method :metadata/column\n  [metadata unit]\n  (if unit\n    (assoc metadata\n           ::temporal-unit unit\n           ::original-effective-type ((some-fn ::original-effective-type :effective-type :base-type) metadata))\n    (dissoc metadata ::temporal-unit ::original-effective-type)))\n\n(defmethod lib.temporal-bucket/available-temporal-buckets-method :field\n  [query stage-number field-ref]\n  (lib.temporal-bucket/available-temporal-buckets query stage-number (resolve-field-metadata query stage-number field-ref)))\n\n(defn- fingerprint-based-default-unit [fingerprint]\n  (u/ignore-exceptions\n    (when-let [{:keys [earliest latest]} (-> fingerprint :type :type/DateTime)]\n      (let [days (shared.ut/day-diff (shared.ut/coerce-to-timestamp earliest)\n                                     (shared.ut/coerce-to-timestamp latest))]\n        (when-not (NaN? days)\n          (condp > days\n            1 :minute\n            31 :day\n            365 :week\n            :month))))))\n\n(defn- mark-unit [options option-key unit]\n  (cond->> options\n    (some #(= (:unit %) unit) options)\n    (mapv (fn [option]\n            (cond-> option\n              (contains? option option-key) (dissoc option option-key)\n              (= (:unit option) unit)       (assoc option-key true))))))\n\n(defmethod lib.temporal-bucket/available-temporal-buckets-method :metadata/column\n  [_query _stage-number field-metadata]\n  (if (not= (:lib/source field-metadata) :source/expressions)\n    (let [effective-type ((some-fn :effective-type :base-type) field-metadata)\n          fingerprint-default (some-> field-metadata :fingerprint fingerprint-based-default-unit)]\n      (cond-> (cond\n                (isa? effective-type :type/DateTime) lib.temporal-bucket/datetime-bucket-options\n                (isa? effective-type :type/Date)     lib.temporal-bucket/date-bucket-options\n                (isa? effective-type :type/Time)     lib.temporal-bucket/time-bucket-options\n                :else                                [])\n        fingerprint-default              (mark-unit :default fingerprint-default)\n        (::temporal-unit field-metadata) (mark-unit :selected (::temporal-unit field-metadata))))\n    []))\n\n;;; ---------------------------------------- Binning ---------------------------------------------\n\n(defmethod lib.binning/binning-method :field\n  [field-clause]\n  (some-> field-clause\n          lib.options/options\n          :binning\n          (assoc :lib/type    ::lib.binning/binning\n                 :metadata-fn (fn [query stage-number]\n                                (resolve-field-metadata query stage-number field-clause)))))\n\n(defmethod lib.binning/binning-method :metadata/column\n  [metadata]\n  (some-> metadata\n          ::binning\n          (assoc :lib/type    ::lib.binning/binning\n                 :metadata-fn (constantly metadata))))\n\n(defmethod lib.binning/with-binning-method :field\n  [field-clause binning]\n  (lib.options/update-options field-clause u/assoc-dissoc :binning binning))\n\n(defmethod lib.binning/with-binning-method :metadata/column\n  [metadata binning]\n  (u/assoc-dissoc metadata ::binning binning))\n\n(defmethod lib.binning/available-binning-strategies-method :field\n  [query stage-number field-ref]\n  (lib.binning/available-binning-strategies query stage-number (resolve-field-metadata query stage-number field-ref)))\n\n(defmethod lib.binning/available-binning-strategies-method :metadata/column\n  [query _stage-number {:keys [effective-type fingerprint semantic-type] :as field-metadata}]\n  (if (not= (:lib/source field-metadata) :source/expressions)\n    (let [binning?    (some-> query lib.metadata/database :features (contains? :binning))\n          fingerprint (get-in fingerprint [:type :type/Number])\n          existing    (lib.binning/binning field-metadata)\n          strategies  (cond\n                        ;; Abort if the database doesn't support binning, or this column does not have a defined range.\n                        (not (and binning?\n                                  (:min fingerprint)\n                                  (:max fingerprint)))               nil\n                        (isa? semantic-type :type/Coordinate)        (lib.binning/coordinate-binning-strategies)\n                        (and (isa? effective-type :type/Number)\n                             (not (isa? semantic-type :Relation/*))) (lib.binning/numeric-binning-strategies))]\n      ;; TODO: Include the time and date binning strategies too; see metabase.api.table/assoc-field-dimension-options.\n      (for [strat strategies]\n        (cond-> strat\n          (lib.binning/strategy= strat existing) (assoc :selected true))))\n    []))\n\n(defmethod lib.ref/ref-method :field\n  [field-clause]\n  field-clause)\n\n(defn- column-metadata->field-ref\n  [metadata]\n  (let [inherited-column? (when-not (::lib.card/force-broken-id-refs metadata)\n                            (#{:source/card :source/native :source/previous-stage} (:lib/source metadata)))\n        options           (merge {:lib/uuid       (str (random-uuid))\n                                  :base-type      (:base-type metadata)\n                                  :effective-type (column-metadata-effective-type metadata)}\n                                 ;; This one deliberately comes first so it will be overwritten by current-join-alias.\n                                 ;; We don't want both :source-field and :join-alias, though.\n                                 (when-let [source-alias (and (not inherited-column?)\n                                                              (not (:fk-field-id metadata))\n                                                              (not= :source/implicitly-joinable\n                                                                    (:lib/source metadata))\n                                                              (:source-alias metadata))]\n                                   {:join-alias source-alias})\n                                 (when-let [join-alias (when-not inherited-column?\n                                                         (lib.join.util/current-join-alias metadata))]\n                                   {:join-alias join-alias})\n                                 (when-let [temporal-unit (::temporal-unit metadata)]\n                                   {:temporal-unit temporal-unit})\n                                 (when-let [original-effective-type (::original-effective-type metadata)]\n                                   {::original-effective-type original-effective-type})\n                                 (when-let [binning (::binning metadata)]\n                                   {:binning binning})\n                                 (when-let [source-field-id (when-not inherited-column?\n                                                              (:fk-field-id metadata))]\n                                   {:source-field source-field-id}))\n        id-or-name        ((if inherited-column?\n                             (some-fn :lib/desired-column-alias :name)\n                             (some-fn :id :name))\n                           metadata)]\n    [:field options id-or-name]))\n\n(defmethod lib.ref/ref-method :metadata/column\n  [{source :lib/source, :as metadata}]\n  (case source\n    :source/aggregations (lib.aggregation/column-metadata->aggregation-ref metadata)\n    :source/expressions  (lib.expression/column-metadata->expression-ref metadata)\n    ;; `:source/fields`/`:source/breakouts` can hide the true origin of the column. Since it's impossible to break out\n    ;; by aggregation references at the current stage, we only have to check if we break out by an expression\n    ;; reference. `:lib/expression-name` is only set for expression references, so if it's set, we have to generate an\n    ;; expression ref, otherwise we generate a normal field ref.\n    (:source/fields :source/breakouts)\n    (if (:lib/expression-name metadata)\n      (lib.expression/column-metadata->expression-ref metadata)\n      (column-metadata->field-ref metadata))\n\n    #_else\n    (column-metadata->field-ref metadata)))\n\n(defn- expression-columns\n  \"Return the [[::lib.schema.metadata/column]] for all the expressions in a stage of a query.\"\n  [query stage-number]\n  (filter #(= (:lib/source %) :source/expressions)\n          (lib.metadata.calculation/visible-columns\n           query\n           stage-number\n           (lib.util/query-stage query stage-number)\n           {:include-joined?              false\n            :include-expressions?         true\n            :include-implicitly-joinable? false})))\n\n(mu/defn with-fields :- ::lib.schema/query\n  \"Specify the `:fields` for a query. Pass `nil` or an empty sequence to remove `:fields`.\"\n  ([xs]\n   (fn [query stage-number]\n     (with-fields query stage-number xs)))\n\n  ([query xs]\n   (with-fields query -1 xs))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int\n    xs]\n   (let [xs        (not-empty (mapv lib.ref/ref xs))\n         ;; If any fields are specified, include all expressions not yet included.\n         expr-cols (expression-columns query stage-number)\n         ;; Set of expr-cols which are *already* included.\n         included  (into #{}\n                         (keep #(lib.equality/find-matching-column query stage-number % expr-cols))\n                         (or xs []))\n         ;; Those expr-refs which must still be included.\n         to-add    (remove included expr-cols)\n         xs        (when xs (into xs (map lib.ref/ref) to-add))]\n     (lib.util/update-query-stage query stage-number u/assoc-dissoc :fields xs))))\n\n(mu/defn fields :- [:maybe [:ref ::lib.schema/fields]]\n  \"Fetches the `:fields` for a query. Returns `nil` if there are no `:fields`. `:fields` should never be empty; this is\n  enforced by the Malli schema.\"\n  ([query]\n   (fields query -1))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int]\n   (:fields (lib.util/query-stage query stage-number))))\n\n(mu/defn fieldable-columns :- [:sequential ::lib.schema.metadata/column]\n  \"Return a sequence of column metadatas for columns that you can specify in the `:fields` of a query. This is\n  basically just the columns returned by the source Table/Saved Question/Model or previous query stage.\n\n  Includes a `:selected?` key letting you know this column is already in `:fields` or not; if `:fields` is\n  unspecified, all these columns are returned by default, so `:selected?` is true for all columns (this is a little\n  strange but it matches the behavior of the QB UI).\"\n  ([query]\n   (fieldable-columns query -1))\n\n  ([query :- ::lib.schema/query\n    stage-number :- :int]\n   (let [visible-columns (lib.metadata.calculation/visible-columns query\n                                                                   stage-number\n                                                                   (lib.util/query-stage query stage-number)\n                                                                   {:include-joined?              false\n                                                                    :include-expressions?         false\n                                                                    :include-implicitly-joinable? false})\n         selected-fields (fields query stage-number)]\n     (if (empty? selected-fields)\n       (mapv (fn [col]\n               (assoc col :selected? true))\n             visible-columns)\n       (lib.equality/mark-selected-columns query stage-number visible-columns selected-fields)))))\n\n(defn- populate-fields-for-stage\n  \"Given a query and stage, sets the `:fields` list to be the fields which would be selected by default.\n  This is exactly [[lib.metadata.calculation/returned-columns]] filtered by the `:lib/source`.\n  Fields from explicit joins are listed on the join itself and should not be listed in `:fields`.\"\n  [query stage-number]\n  (let [defaults (lib.metadata.calculation/default-columns-for-stage query stage-number)]\n    (lib.util/update-query-stage query stage-number assoc :fields (mapv lib.ref/ref defaults))))\n\n(defn- query-with-fields\n  \"If the given stage already has a `:fields` clause, do nothing. If it doesn't, populate the `:fields` clause with the\n  full set of `returned-columns`. (See [[populate-fields-for-stage]] for the details.)\"\n  [query stage-number]\n  (cond-> query\n    (not (:fields (lib.util/query-stage query stage-number))) (populate-fields-for-stage stage-number)))\n\n(defn- include-field [query stage-number column]\n  (let [populated  (query-with-fields query stage-number)\n        field-refs (fields populated stage-number)\n        match-ref  (lib.equality/find-matching-ref column field-refs)\n        column-ref (lib.ref/ref column)]\n    (if (and match-ref\n             (or (string? (last column-ref))\n                 (integer? (last match-ref))))\n      ;; If the column is already found, do nothing and return the original query.\n      query\n      (lib.util/update-query-stage populated stage-number update :fields conj column-ref))))\n\n(defn- add-field-to-join [query stage-number column]\n  (let [column-ref   (lib.ref/ref column)\n        [join field] (first (for [join  (lib.join/joins query stage-number)\n                                  :let [joinables (lib.join/joinable-columns query stage-number join)\n                                        field     (lib.equality/find-matching-column\n                                                   query stage-number column-ref joinables)]\n                                  :when field]\n                              [join field]))\n        join-fields  (lib.join/join-fields join)]\n\n    ;; Nothing to do if it's already selected, or if this join already has :fields :all.\n    ;; Otherwise, append it to the list of fields.\n    (if (or (= join-fields :all)\n            (and field\n                 (not= join-fields :none)\n                 (lib.equality/find-matching-ref field join-fields)))\n      query\n      (lib.remove-replace/replace-join query stage-number join\n                                       (lib.join/with-join-fields join\n                                         (if (= join-fields :none)\n                                           [column]\n                                           (conj join-fields column)))))))\n\n(defn- native-query-fields-edit-error []\n  (i18n/tru \"Fields cannot be adjusted on native queries. Either edit the native query, or save this question and edit the fields in a GUI question based on this one.\"))\n\n(defn- source-clauses-only-fields-edit-error []\n  (i18n/tru (str \"Only source columns (those from a table, model, or saved question) can be adjusted on a query. \"\n                 \"Aggregations, breakouts and expressions are always returned, and must be removed from the query or \"\n                 \"hidden in the UI.\")))\n\n(mu/defn add-field :- ::lib.schema/query\n  \"Adds a given field (`ColumnMetadata`, as returned from eg. [[visible-columns]]) to the fields returned by the query.\n  Exactly what this means depends on the source of the field:\n  - Source table/card, previous stage of the query, custom expression, aggregation or breakout:\n      - Add it to the `:fields` list\n      - If `:fields` is missing, it's implicitly `:all`, so do nothing.\n  - Implicit join: add it to the `:fields` list; query processor will do the right thing with it.\n  - Explicit join: add it to that join's `:fields` list.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   column       :- lib.metadata.calculation/ColumnMetadataWithSource]\n  (let [stage  (lib.util/query-stage query stage-number)\n        source (:lib/source column)]\n    (-> (case source\n          (:source/table-defaults\n            :source/fields\n            :source/card\n            :source/previous-stage\n            :source/expressions\n            :source/aggregations\n            :source/breakouts)         (cond-> query\n                                         (contains? stage :fields) (include-field stage-number column))\n          :source/joins               (add-field-to-join query stage-number column)\n          :source/implicitly-joinable (include-field query stage-number column)\n          :source/native              (throw (ex-info (native-query-fields-edit-error) {:query query :stage stage-number}))\n          ;; Default case - do nothing if we don't know about the incoming value.\n          ;; Generates a warning, as we should aim to capture all the :source/* values here.\n          (do\n            (log/warnf \"Cannot add-field with unknown source %s\" (pr-str source))\n            query))\n        ;; Then drop any redundant :fields clauses.\n        lib.remove-replace/normalize-fields-clauses)))\n\n(defn- remove-matching-ref [column refs]\n  (let [match (lib.equality/find-matching-ref column refs)]\n     (remove #(= % match) refs)))\n\n(defn- exclude-field\n  \"This is called only for fields that plausibly need removing. If the stage has no `:fields`, this will populate it.\n  It shouldn't happen that we can't find the target field, but if that does happen, this will return the original query\n  unchanged. (In particular, if `:fields` did not exist before it will still be omitted.)\"\n  [query stage-number column]\n  (let [old-fields (-> (query-with-fields query stage-number)\n                       (lib.util/query-stage stage-number)\n                       :fields)\n        new-fields (remove-matching-ref column old-fields)]\n    (cond-> query\n      ;; If we couldn't find the field, return the original query unchanged.\n      (< (count new-fields) (count old-fields)) (lib.util/update-query-stage stage-number assoc :fields new-fields))))\n\n(defn- remove-field-from-join [query stage-number column]\n  (let [join        (lib.join/resolve-join query stage-number (::lib.join/join-alias column))\n        join-fields (lib.join/join-fields join)]\n    (if (or (nil? join-fields)\n            (= join-fields :none))\n      ;; Nothing to do if there's already no join fields.\n      query\n      (let [resolved-join-fields (if (= join-fields :all)\n                                   (map lib.ref/ref (lib.metadata.calculation/returned-columns query stage-number join))\n                                   join-fields)\n            removed              (remove-matching-ref column resolved-join-fields)]\n        (cond-> query\n          ;; If we actually removed a field, replace the join. Otherwise return the query unchanged.\n          (< (count removed) (count resolved-join-fields))\n          (lib.remove-replace/replace-join stage-number join (lib.join/with-join-fields join removed)))))))\n\n(mu/defn remove-field :- ::lib.schema/query\n  \"Removes the field (a `ColumnMetadata`, as returned from eg. [[visible-columns]]) from those fields returned by the\n  query. Exactly what this means depends on the source of the field:\n  - Source table/card, previous stage, custom expression, aggregations or breakouts:\n      - If `:fields` is missing, it's implicitly `:all` - populate it with all the columns except the removed one.\n      - Remove the target column from the `:fields` list\n  - Implicit join: remove it from the `:fields` list; do nothing if it's not there.\n      - (An implicit join only exists in the `:fields` clause, so if it's not there then it's not anywhere.)\n  - Explicit join: remove it from that join's `:fields` list (handle `:fields :all` like for source tables).\"\n  [query      :- ::lib.schema/query\n   stage-number :- :int\n   column       :- lib.metadata.calculation/ColumnMetadataWithSource]\n  (let [source (:lib/source column)]\n    (-> (case source\n          (:source/table-defaults\n           :source/fields\n           :source/card\n           :source/previous-stage\n           :source/expressions\n           :source/implicitly-joinable) (exclude-field query stage-number column)\n          :source/joins                 (remove-field-from-join query stage-number column)\n          :source/native                (throw (ex-info (native-query-fields-edit-error)\n                                                         {:query query :stage stage-number}))\n\n          (:source/breakouts\n           :source/aggregations)        (throw (ex-info (source-clauses-only-fields-edit-error)\n                                                        {:query  query\n                                                         :stage  stage-number\n                                                         :source source}))\n          ;; Default case: do nothing and return the query unchaged.\n          ;; Generate a warning - we should aim to capture every `:source/*` value above.\n          (do\n            (log/warnf \"Cannot remove-field with unknown source %s\" (pr-str source))\n            query))\n        ;; Then drop any redundant :fields clauses.\n        lib.remove-replace/normalize-fields-clauses)))\n\n;; TODO: Refactor this away? The special handling for aggregations is strange.\n(mu/defn find-visible-column-for-ref :- [:maybe ::lib.schema.metadata/column]\n  \"Return the visible column in `query` at `stage-number` referenced by `field-ref`. If `stage-number` is omitted, the\n  last stage is used. This is currently only meant for use with `:field` clauses.\"\n  ([query field-ref]\n   (find-visible-column-for-ref query -1 field-ref))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int\n    field-ref    :- some?]\n   (let [stage   (lib.util/query-stage query stage-number)\n         ;; not 100% sure why, but [[lib.metadata.calculation/visible-columns]] doesn't seem to return aggregations,\n         ;; so we have to use [[lib.metadata.calculation/returned-columns]] instead.\n         columns ((if (= (lib.dispatch/dispatch-value field-ref) :aggregation)\n                    lib.metadata.calculation/returned-columns\n                    lib.metadata.calculation/visible-columns)\n                  query stage-number stage)]\n     (lib.equality/find-matching-column query stage-number field-ref columns))))\n\n(defn json-field?\n  \"Return true if field is a JSON field, false if not.\"\n  [field]\n  (some? (:nfc-path field)))\n\n;;; yes, this is intentionally different from the version in `:metabase.lib.schema.metadata/column.has-field-values`.\n;;; The FE isn't supposed to need to worry about the distinction between `:auto-list` and `:list` for filter purposes.\n;;; See [[infer-has-field-values]] for more info.\n(mr/def ::field-values-search-info.has-field-values\n  [:enum :list :search :none])\n\n(mr/def ::field-values-search-info\n  [:map\n   [:field-id         [:maybe [:ref ::lib.schema.id/field]]]\n   [:search-field-id  [:maybe [:ref ::lib.schema.id/field]]]\n   [:has-field-values [:ref ::field-values-search-info.has-field-values]]])\n\n(mu/defn infer-has-field-values :- ::field-values-search-info.has-field-values\n  \"Determine the value of `:has-field-values` we should return for column metadata for frontend consumption to power\n  filter search widgets, either when returned by the the REST API or in MLv2 with [[field-values-search-info]].\n\n  Note that this value is not necessarily the same as the value of `has_field_values` in the application database.\n  `has_field_values` may be unset, in which case we will try to infer it. `:auto-list` is not currently understood by\n  the FE filter stuff, so we will instead return `:list`; the distinction is not important to it anyway.\"\n  [{:keys [has-field-values], :as field} :- [:map\n                                             ;; this doesn't use `::lib.schema.metadata/column` because it's stricter\n                                             ;; than we need and the REST API calls this function with optimized Field\n                                             ;; maps that don't include some keys like `:name`\n                                             [:base-type        {:optional true} [:maybe ::lib.schema.common/base-type]]\n                                             [:effective-type   {:optional true} [:maybe ::lib.schema.common/base-type]]\n                                             [:has-field-values {:optional true} [:maybe ::lib.schema.metadata/column.has-field-values]]]]\n  (cond\n    ;; if `has_field_values` is set in the DB, use that value; but if it's `auto-list`, return the value as `list` to\n    ;; avoid confusing FE code, which can remain blissfully unaware that `auto-list` is a thing\n    (= has-field-values :auto-list)   :list\n    has-field-values                  has-field-values\n    ;; otherwise if it does not have value set in DB we will infer it\n    (lib.types.isa/searchable? field) :search\n    :else                             :none))\n\n(mu/defn ^:private remapped-field :- [:maybe ::lib.schema.metadata/column]\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   column                :- ::lib.schema.metadata/column]\n  (when (lib.types.isa/foreign-key? column)\n    (when-let [remap-field-id (get-in column [:lib/external-remap :field-id])]\n      (lib.metadata/field metadata-providerable remap-field-id))))\n\n(mu/defn ^:private search-field :- [:maybe ::lib.schema.metadata/column]\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   column                :- ::lib.schema.metadata/column]\n  (let [col (or (when (lib.types.isa/primary-key? column)\n                  (when-let [name-field (:name-field column)]\n                    (lib.metadata/field metadata-providerable (u/the-id name-field))))\n                (remapped-field metadata-providerable column)\n                column)]\n    (when (lib.types.isa/searchable? col)\n      col)))\n\n(mu/defn field-values-search-info :- ::field-values-search-info\n  \"Info about whether the column in question has FieldValues associated with it for purposes of powering a search\n  widget in the QB filter modals.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   column                :- ::lib.schema.metadata/column]\n  (when column\n    (let [column-field-id (:id column)\n          search-field-id (:id (search-field metadata-providerable column))]\n      {:field-id (when (int? column-field-id) column-field-id)\n       :search-field-id (when (int? search-field-id) search-field-id)\n       :has-field-values (if column\n                           (infer-has-field-values column)\n                           :none)})))\n"]}