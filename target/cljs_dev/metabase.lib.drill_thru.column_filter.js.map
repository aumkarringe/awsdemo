{"version":3,"sources":["metabase/lib/drill_thru/column_filter.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;;;;;;;;;;;;;;;;yEAAA,zEAASA,0JAcNC,MACAC,aACAC,OACAC,WACAC;AAlBH,AAmBE,IAAMC,uDAAmB,AAACC,wCAA+BN,MAAMC,xFACtC,AAACM,oCAA2BP;IAC/CQ,OAAc,+kBAAA,2CAAA,8DAAA,2FAAA,8BAAA,2CAAA,8DAAA,yFAAA,AAAA,2CAAA,+FAAA,sEAAA,jsCAME,GAAK,EAAI,iJAAA,jJAACC,6CAAE,AAAA,4FAAaP,+FAChB,EAAK,iJAAA,jJAACO,6CAAE,AAAA,4FAAaP,yFAChB,oDAAA,pDAACO,6CAAEL,kLACFJ,4EACAC,uCAIfI,+GAA0BL,4EACAK,sHAEA,AAACK,gCAAuBV;;IAElEW,UAAc,AAACC,qEAA8B,AAAA,sFAAQJ,MAAM,AAAA,oGAAeA;IAC1EK,gBAAc,iBAAAC,mBAAI,AAACC,yEACC,AAAA,sFAAQP,MAAM,AAAA,oGAAeA,MAAML,WAAWQ;AADpD,AAAA,oBAAAG;AAAAA;;AAEI,IAAAE,oBAAK,AAAA,sGAAkBd;AAAvB,AAAA,oBAAAc;AACK,4DAAA,WAAAC,hEAACC;AAAD,AAAe,OAACT,6CAAE,AAAA,sGAAAQ,kBAAqB,AAAA,sGAAkBf;GAC3CS;;AAFnBK;;;;AAxBxB,AA2BE,0DAAA,nDAACG,8CAAMX,8DAAaK;;AAExB;;;;;;;;;;;4DAAA,uFAAAO,nJAASI,gIAMNxB,MACAC;AAPH,AAAA,IAAAoB,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;aAAA,AAAAE,4CAAAF,eAAA,pEAQWnB;iBARX,AAAAqB,4CAAAF,eAAA,xEAQkBlB;YARlB,AAAAoB,4CAAAF,eAAA,nEAQ6BI;AAR7B,AAUE,oBAAM,iBAAAT,oBAAK,AAACU,iDAAkC1B,MAAMC;AAA9C,AAAA,GAAAe;AAAA,IAAAA,wBACKd;AADL,AAAA,oBAAAc;AAAA,SAEK,UAAA,TAAMS,oBACN,GAAK,AAACE,yCAA0BzB;;AAHrCc;;;AAAAA;;;AAAN,AAIE,IAAMY,aAAW,kDAAA,KAAA,rDAAU,AAACC,uCAAwB3B,4EAC7B,AAAC4B,8CAAqC5B,9DACtC6B,9CACA,8CAAA,uEAAA,0DAAA,/KAACZ;AAHxB,AAKE,8GAAA,2CAAA,0DAAA,6GAAA,qDAAA,0FAAA,xcAACa,wgBAGcJ,mBAEb,4GAAA,5GAAC7B,uEAAiCC,MAAMC,aAAaC,OAAOC;;AAdlE;;;AAgBF,AAAA8B,kGAAA,0FAAA,gCAAAC,rBACGE,OAAOC;AADV,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAAb,4BAAAa;iBAAA,AAAAZ,4CAAAY,eAAA,xEACgCP;AADhC,AAAA,kDAAA,qDAAA,0FAAA,gEAGeA;;AAEf,AAAAU,6FAAA,0FAAA,8BAAAC,nBACGvC,MACAC,sBAEAyC,UACAjB;AALH,AAAA,IAAAe,aAAAD;IAAAC,iBAAA,AAAAlB,4BAAAkB;kBAAAA,dAGuBC;aAHvB,AAAAlB,4CAAAiB,eAAA,pEAGWtC;AAHX,AAME,OAACyC,yDAAkB3C,MAAMC,aAAa,AAAC2C,uEAAyBF,UAAUxC,yDAAOuB","names":["metabase.lib.drill-thru.column-filter/prepare-query-for-drill-addition","query","stage-number","column","column-ref","adding","next-stage","metabase.lib.util/canonical-stage-index","metabase.lib.util/next-stage-number","base","cljs.core._EQ_","metabase.lib.stage/append-stage","columns","metabase.lib.filter.filterable_columns","filter-column","or__5002__auto__","metabase.lib.equality.find_matching_column","and__5000__auto__","p1__79242#","medley.core.find_first","cljs.core.assoc","p__79248","map__79249","cljs.core/--destructure-map","cljs.core.get","metabase.lib.drill-thru.column-filter/column-filter-drill","value","metabase.lib.drill-thru.common/mbql-stage?","metabase.lib.types.isa/structured?","initial-op","metabase.lib.types.isa/temporal?","metabase.lib.filter.operator/filter-operators","cljs.core/first","cljs.core.merge","metabase.lib.drill-thru.common/drill-thru-info-method","p__79253","map__79254","_query","_stage-number","metabase.lib.drill-thru.common/drill-thru-method","p__79259","map__79260","_drill-thru","filter-op","metabase.lib.filter.filter","metabase.lib.filter.filter_clause"],"sourcesContent":["(ns metabase.lib.drill-thru.column-filter\n  \"Enables \\\"Filter by this column\\\" menu item.\n\n  The caveat here is that for aggregation and breakout columns we need to append a stage before adding a filter. There\n  is a helper function called `filterDrillDetails` which returns the query with a possibly appended stage, and the\n  corresponding column for that stage. In each test case where drill thru is allowed we need to verify that\n  `filterDrillDetails` appended the stage where needed.\n\n  Another caveat is that we need to verify that `filterDrillDetails` returned a _filterable_ column, i.e. a column\n  obtained from `filterableColumns` call. A good way to verify that is to call `filterableColumnOperators` and check\n  that a non-empty list is returned.\n\n  Entry points:\n\n  - Column header\n\n  Requirements:\n\n  - Column not `type/Structured`\n\n  Query transformation:\n\n  - None/identity. The FE will show the FilterPicker and not call `drillThru` for this drill.\n\n  Question transformation:\n  - None\"\n  (:require\n   [medley.core :as m]\n   [metabase.lib.drill-thru.common :as lib.drill-thru.common]\n   [metabase.lib.equality :as lib.equality]\n   [metabase.lib.filter :as lib.filter]\n   [metabase.lib.filter.operator :as lib.filter.operator]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.drill-thru :as lib.schema.drill-thru]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.schema.ref :as lib.schema.ref]\n   [metabase.lib.stage :as lib.stage]\n   [metabase.lib.types.isa :as lib.types.isa]\n   [metabase.lib.util :as lib.util]\n   [metabase.util.malli :as mu]))\n\n(mu/defn prepare-query-for-drill-addition :- [:map\n                                              [:query ::lib.schema/query]\n                                              [:stage-number :int]\n                                              [:column lib.filter/ColumnWithOperators]]\n  \"If the column we're filtering on is an aggregation, the filtering must happen in a later stage. This function returns\n  a map with that possibly-updated `:query` and `:stage-number`, plus the `:column` for filtering in that stage (with\n  filter operators, as returned by [[lib.filter/filterable-columns]]).\n\n  If the column is an aggregation but the query already has a later stage, that stage is reused.\n  If the column is not an aggregation, the query and stage-number are returned unchanged, but the\n  [[lib.filter/filterable-columns]] counterpart of the input `column` is still returned.\n\n  This query and filterable column are exactly what the FE needs to render the filtering UI for a column filter drill,\n  or certain tricky cases of quick filter.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   column       :- ::lib.schema.metadata/column\n   column-ref   :- ::lib.schema.ref/ref\n   adding       :- [:enum :filter :expression]]\n  (let [next-stage    (->> (lib.util/canonical-stage-index query stage-number)\n                           (lib.util/next-stage-number query))\n        base          (cond\n                        ;; An extra stage is needed if:\n                        ;; - The target column is an aggregation\n                        ;; - OR the target column is a breakout AND we are adding a custom expression based on it.\n                        ;;\n                        ;; So if neither of those cases apply, we can just return the original query and stage index.\n                        (not (or (= (:lib/source column) :source/aggregations)\n                                 (and (= (:lib/source column) :source/breakouts)\n                                      (= adding :expression))))\n                        {:query        query\n                         :stage-number stage-number}\n\n                        ;; An extra stage is needed.\n                        ;; If there's a later stage, then use it.\n                        next-stage {:query        query\n                                    :stage-number next-stage}\n                        ;; And if there isn't a later stage, add one.\n                        :else      {:query        (lib.stage/append-stage query)\n                                    :stage-number -1})\n        columns       (lib.filter/filterable-columns (:query base) (:stage-number base))\n        filter-column (or (lib.equality/find-matching-column\n                            (:query base) (:stage-number base) column-ref columns)\n                          (and (:lib/source-uuid column)\n                               (m/find-first #(= (:lib/source-uuid %) (:lib/source-uuid column))\n                                             columns)))]\n    (assoc base :column filter-column)))\n\n(mu/defn column-filter-drill :- [:maybe ::lib.schema.drill-thru/drill-thru.column-filter]\n  \"Filtering at the column level, based on its type. Displays a submenu of eg. \\\"Today\\\", \\\"This Week\\\", etc. for date\n  columns.\n\n  Note that if the clicked column is an aggregation, filtering by it will require a new stage. Therefore this drill\n  returns a possibly-updated `:query` and `:stage-number` along with a `:column` referencing that later stage.\"\n  [query                             :- ::lib.schema/query\n   stage-number                      :- :int\n   {:keys [column column-ref value]} :- ::lib.schema.drill-thru/context]\n  ;; Note: original code uses an addition `clicked.column.field_ref != null` condition.\n  (when (and (lib.drill-thru.common/mbql-stage? query stage-number)\n             column\n             (nil? value)\n             (not (lib.types.isa/structured? column)))\n    (let [initial-op (when-not (lib.types.isa/temporal? column) ; Date fields have special handling in the FE.\n                       (-> (lib.filter.operator/filter-operators column)\n                           first\n                           (assoc :lib/type :operator/filter)))]\n\n      (merge\n        {:lib/type   :metabase.lib.drill-thru/drill-thru\n         :type       :drill-thru/column-filter\n         :initial-op initial-op}\n        ;; When the column we would be filtering on is an aggregation, it can't be filtered without adding a stage.\n        (prepare-query-for-drill-addition query stage-number column column-ref :filter)))))\n\n(defmethod lib.drill-thru.common/drill-thru-info-method :drill-thru/column-filter\n  [_query _stage-number {:keys [initial-op]}]\n  {:type       :drill-thru/column-filter\n   :initial-op initial-op})\n\n(mu/defmethod lib.drill-thru.common/drill-thru-method :drill-thru/column-filter :- ::lib.schema/query\n  [query                            :- ::lib.schema/query\n   stage-number                     :- :int\n   {:keys [column] :as _drill-thru} :- ::lib.schema.drill-thru/drill-thru.column-filter\n   filter-op                        :- [:or :keyword :string] ; filter tag\n   value                            :- :any]\n  (lib.filter/filter query stage-number (lib.filter/filter-clause filter-op column value)))\n"]}