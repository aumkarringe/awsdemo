{"version":3,"sources":["metabase/lib/drill_thru/pivot.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA;;;;;;;;;iDAAA,4EAAAA,7HAAmBI,0GAIhBC,MACAC,sBAEAG;AAPH,AAAA,IAAAR,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;aAAA,AAAAE,4CAAAF,eAAA,pEAMWM;YANX,AAAAJ,4CAAAF,eAAA,nEAMkBO;AANlB,AAQE,oBAAM,iBAAAE,oBAAK,AAACC,iDAAkCN,MAAMC;AAA9C,AAAA,GAAAI;AAAA,IAAAA,wBACKH;AADL,AAAA,oBAAAG;AAAA,SAEK,GAAA,UAAA,TAAOF,sBACP,iJAAA,jJAACI,6CAAE,AAAA,4FAAaL;;AAHrBG;;;AAAAA;;;AAAN,iEAIO,AAACG,yEAAkCR,MAAMC,hJACzC,OAACQ,+CAAOL;;AALf;;;AAOF,sDAAA,2CAAA,oNAAA,mGAAA,xZAAeM,8JACF,AAACC,mDAAWC,uCACA,AAACC,qBAAWC,qGACxBA,2FACAC;AAEb,8CAAA,9CAAOC,oGAAehB,MAAMC,aAAagB;AAAzC,AACE,IAAMf,SAAO,AAACgB,yEAAkClB,MAAMC,aAAagB;AAAnE,AACE,GACE,AAACF,uCAAwBb;AAD3B;;AAAA,GAEE,AAACY,sCAAuBZ;AAF1B;;AAAA,GAGE,AAACU,uCAAwBV;AAH3B;;AAAA;;;;;AAKJ;;;;;;;;;;;;;;;;;;sDAAA,tDAAmBiB,oHAahBnB,MACAC;AAdH,AAeE,IAAAmB,WAAM,sBACK,4CAAA,WAAAE,vDAACC,tBACDC;AADA,AAAM,sEAAAF,/DAACN,4CAAchB,MAAMC;GAD3B,AAACoB,8DAAuBrB,MAAMC;AAAzC,AAAA,GAAA,AAAAM,6CAAA,2CAAA,sDAAA,YAAAa;AAAA,wFAAA,kEAAA;;AAAA,GAAA,AAAAb,6CAAA,2CAAA,sDAAA,IAAA,6DAAA,YAAAa;AAAA,wFAAA,kEAAA;;AAAA,GAAA,AAAAb,6CAAA,2CAAA,0DAAA,YAAAa;AAAA,wFAAA,kEAAA;;AAAA,GAAA,AAAAb,6CAAA,mCAAAa;AAAA,wFAAA,kEAAA,0DAAA;;AAAA,GAAA,AAAAb,6CAAA,2CAAA,6DAAA,YAAAa;AAAA,wFAAA,kEAAA;;AAAA,GAAA,AAAAb,6CAAA,2CAAA,6DAAA,YAAAa;AAAA,wFAAA,kEAAA;;AAAA,AAAA;;;;;;;;;AAmBF;;;;;;;;;;4CAAA,uEAAAK,nHAASE,gGAKN3B,MACAC;AANH,AAAA,IAAAyB,aAAAD;IAAAC,iBAAA,AAAA7B,4BAAA6B;cAAAA,VAOwCG;aAPxC,AAAA/B,4CAAA4B,eAAA,pEAOWxB;iBAPX,AAAAJ,4CAAA4B,eAAA,xEAOkBE;YAPlB,AAAA9B,4CAAA4B,eAAA,nEAO6BvB;AAP7B,AAQE,oBAAM,iBAAAE,oBAAK,AAACC,iDAAkCN,MAAMC;AAA9C,AAAA,GAAAI;AAAA,IAAAA,wBACKH;AADL,AAAA,oBAAAG;AAAA,mCAAA,1BAEK,GAAA,UAAA,TAAOF,wBACP,iJAAA,jJAACI,6CAAE,AAAA,4FAAaL,+FAChB,CAAA,2GAAA,3FAAI,AAAC4B,oEAA6B9B,MAAMC,1FAAc8B;;AAJ3D1B;;;AAAAA;;;AAAN,AAKE,IAAM2B,uBAAqB,AAACb,oDAAsBnB,MAAMC;IAClDgC,SAAqB,6CAAA,7CAACC,gFAAQ,iBAAAC,qBAAA,kEAAAC;AAAA,AAAA,YAAAC,kBAAA,KAAA;AAAA,AAAA,IAAAD,eAAAA;;AAAA,AAAA,IAAAE,qBAAA,AAAAC,cAAAH;AAAA,AAAA,GAAAE;AAAA,AAAA,IAAAF,eAAAE;AAAA,AAAA,GAAA,AAAAE,6BAAAJ;AAAA,IAAAK,kBAk1EW,AAAA6C,sBAAAlD;IAl1EXM,qBAAA,AAAAX,gBAAAU;IAAAE,WAAA,AAAAC,uBAAAF;AAAA,AAAA,GAAA,AAAA,iBAAAG,WAAA;;AAAA,AAAA,GAAA,CAAAA,WAAAH;AAAA,iBAAA,AAAAI,eAAAL,gBAAAI,5CAAMU;AAAN,AAAA,IACYC,OAAQ,AAAC1D,4CAAIY,oDAAsB6C;IACnCE,UAAQ,AAAC1D,+CAAiBC,MAAMC,aAAa4B,QAAQ2B;AAFjE,AAAA,oBAGY,AAACE,oBAAUD;AAHvB,AAAA,AAAAV,uBAAAJ,SAAA,mFAIGY,WAAWE;;AAJd,eAAA,CAAAZ,WAAA;;;;AAAA,eAAA,CAAAA,WAAA;;;;;AAAA;;;;;AAAA,OAAAG,qBAAA,AAAAC,gBAAAN,UAAA,AAAAO,wDAAA,AAAAC,qBAAAf;;AAAA,OAAAY,qBAAA,AAAAC,gBAAAN,UAAA;;;AAAA,iBAAA,AAAAS,gBAAAhB,7BAAMmB;AAAN,AAAA,IACYC,OAAQ,AAAC1D,4CAAIY,oDAAsB6C;IACnCE,UAAQ,AAAC1D,+CAAiBC,MAAMC,aAAa4B,QAAQ2B;AAFjE,AAAA,oBAGY,AAACE,oBAAUD;AAHvB,OAAAJ,eAAA,8GAAA,AAAAH,wDAAA,AAAAI,eAAAlB,lGAIGmB,WAAWE;;AAJd,eAAA,AAAAH,eAAAlB;;;;;;AAAA;;;;GAAA,KAAA;;AAAA,AAAA,OAAAD,mBAAiBH;;AADrD,AAME,GAAU,AAAC2B,uBAAO1B;AAAlB;;AAAA,AAAA,kDAAA,0DAAA,6GAAA,qDAAA,2EAAA,4EAAA,XAGeL,kEACAK;;;AAfnB;;;AAiBF,AAAA2B,kGAAA,2EAAA,WACGC,OAAOC,cAAcC;AADxB,AAEE,wCAAA,mFAAA,+DAAA,+DAAA,lPAACC,sBAAYD;;AAKf;;;;;;;4CAAA,5CAASE,gGAENF;AAFH,AAIE,oDAAA,eAAA,AAAA,qFAAIA,pGAAmBG,7CAAKC;;AAE9B;;;;;;;uDAAA,vDAASC,sHAENL,WAEAR;AAJH,AAKE,iEAAA,mFAAA,7IAACc,+CAAON,qJAAoBR;;AAE9B,sDAAA,iFAAAe,vIAAOE,oHAAoBxE,MAAMC;AAAjC,AAAA,IAAAsE,aAAAD;IAAAC,iBAAA,AAAA1E,4BAAA0E;iBAAAA,bAAwEE;aAAxE,AAAA3E,4CAAAyE,eAAA,pEAAsDrE;YAAtD,AAAAJ,4CAAAyE,eAAA,nEAA6DpE;AAA7D,yJACMH,zFACA,AAAC0E,+FAAkDzE,aAAaC,5KAChE,OAACyE,6KAAkB1E,aAAa,AAAC2E,yBAAa1E,OAAOC;;AAO3D,AAAA0E,6FAAA,2EAAA;iEAAAC,9BACG9E,MAAMC,aAAa8D;AADtB,AAAA,IAAAgB,aAAAD;aAAA,AAAAE,4CAAAD,WAAA,IAAA,pEACoC7E;AADpC,AAEE,IAAM+E,WAAS,+CAAA,WAAAC,iBAAAC,3EAACC;AAAD,AAAS,2DAAAF,8BAAAC,lFAACX,qEAAsBvE;GAAiBD,MAAM,AAAA,+FAAa+D;AAAnF,AACE,OAACsB,6DAAsBJ,SAAShF,aAAaC;;yBAF9CF,MAAMC,aAAa8D;IADtBe;;;;EAAAA;;kEAAAA,9BACG9E,MAAMC,aAAa8D;;;IAAnB/D;;IAAMC;;IAAa8D;IADtBe;wDAAAA,9BACG9E,MAAMC,aAAa8D","names":["p__79298","map__79299","cljs.core/--destructure-map","cljs.core.get","metabase.lib.drill-thru.pivot/pivot-drill-pred","query","stage-number","column","value","field-pred","and__5000__auto__","metabase.lib.drill-thru.common/mbql-stage?","cljs.core._EQ_","metabase.lib.breakout.breakoutable_columns","cljs.core.filter","metabase.lib.drill-thru.pivot/pivot-type-predicates","cljs.core.every_pred","metabase.lib.types.isa/category?","cljs.core/complement","metabase.lib.types.isa/address?","metabase.lib.types.isa/temporal?","metabase.lib.drill-thru.pivot/breakout-type","breakout","metabase.lib.metadata.calculation.metadata","metabase.lib.drill-thru.pivot/permitted-pivot-types","G__79301","metabase.lib.breakout.breakouts","p1__79300#","cljs.core.map","cljs.core/frequencies","p__79302","map__79303","metabase.lib.drill-thru.pivot/pivot-drill","dimensions","context","metabase.lib.aggregation.aggregations","cljs.core/count","breakout-pivot-types","pivots","cljs.core.into","iter__5480__auto__","s__79305","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","b__79307","cljs.core/chunk-buffer","i__79306","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__79304","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","pivot-type","pred","columns","cljs.core/not-empty","cljs.core/empty?","metabase.lib.drill-thru.common/drill-thru-info-method","_query","_stage-number","drill-thru","cljs.core/select-keys","metabase.lib.drill-thru.pivot/pivot-types","cljs.core/keys","cljs.core.sort","metabase.lib.drill-thru.pivot/pivot-columns-for-type","cljs.core.get_in","p__79308","map__79309","metabase.lib.drill-thru.pivot/breakouts->filters","_dimension","metabase.lib.breakout.remove_existing_breakouts_for_column","metabase.lib.filter.filter","metabase.lib.filter/=","metabase.lib.drill-thru.common/drill-thru-method","p__79312","vec__79313","cljs.core.nth","filtered","p1__79310#","p2__79311#","cljs.core.reduce","metabase.lib.breakout.breakout","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.lib.drill-thru.pivot\n  \"\\\"Breakout by\\\" transform.\n\n  Entry points:\n\n  - Cell\n\n  Requirements:\n\n  - Query with at least 1 aggregation\n\n  - Column from the aggregation clause was selected\n\n  For different query types/shapes different breakout columns are allowed:\n\n  - No breakouts - `type/Date`, `type/Address`, and `type/Category` (only which are not also `type/Address`)\n\n  - At least 1 aggregation and exactly 1 breakout based on `Address` column - `Date`, `Category`\n\n  - At least 1 aggregation and 1-2 breakouts based on `Category` columns - `Date`, `Category`\n\n  - At least 1 aggregation and either (1 breakout on a date column OR 1st breakout is `Date` and 2nd is `Category`) -\n    `Address`, `Category`\n\n  - In other cases the drill is not supported\n\n  Query transformation is similar to `zoom-in` but can be simplified because legend items aren't supported:\n\n  - Remove existing breakouts\n\n  - Add filters based on `dimensions`, i.e. filters for all existing breakout\n\n  - Add a breakout based on the selected column\n\n  Question transformation:\n\n  - Set default display\n\n  Other functions:\n\n  - `pivotTypes` function that return available column types for the drill - \\\"category\\\" | \\\"location\\\" | \\\"time\\\"\n\n  - `pivotColumnsForType` returns the list of available columns for the drill and the selected type\"\n  (:require\n   [metabase.lib.aggregation :as lib.aggregation]\n   [metabase.lib.breakout :as lib.breakout]\n   [metabase.lib.drill-thru.common :as lib.drill-thru.common]\n   [metabase.lib.filter :as lib.filter]\n   [metabase.lib.metadata.calculation :as lib.metadata.calculation]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.drill-thru :as lib.schema.drill-thru]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.types.isa :as lib.types.isa]\n   [metabase.util.malli :as mu]))\n\n(mu/defn ^:private pivot-drill-pred :- [:sequential ::lib.schema.metadata/column]\n  \"Implementation for pivoting on various kinds of fields.\n\n  Don't call this directly; call [[pivot-drill]].\"\n  [query                  :- ::lib.schema/query\n   stage-number           :- :int\n   {:keys [column value]} :- ::lib.schema.drill-thru/context\n   field-pred             :- [:=> [:cat [:schema ::lib.schema.metadata/column]] boolean?]]\n  (when (and (lib.drill-thru.common/mbql-stage? query stage-number)\n             column\n             (some? value)\n             (= (:lib/source column) :source/aggregations))\n    (->> (lib.breakout/breakoutable-columns query stage-number)\n         (filter field-pred))))\n\n(def ^:private pivot-type-predicates\n  {:category (every-pred lib.types.isa/category?\n                         (complement lib.types.isa/address?))\n   :location lib.types.isa/address?\n   :time     lib.types.isa/temporal?})\n\n(defn- breakout-type [query stage-number breakout]\n  (let [column (lib.metadata.calculation/metadata query stage-number breakout)]\n    (cond\n      (lib.types.isa/temporal? column) :date\n      (lib.types.isa/address? column) :address\n      (lib.types.isa/category? column) :category)))\n\n(mu/defn ^:private permitted-pivot-types :- [:maybe [:set ::lib.schema.drill-thru/pivot-types]]\n  \"This captures some complex conditions formerly encoded by `visualizations/click-actions/Mode/*` in the FE.\n  See [here](https://github.com/metabase/metabase/blob/f4415fec8563353615ef600f52de871507a052ec/frontend/src/metabase/visualizations/click-actions/Mode/utils.ts#L15)\n  for the original logic. (It returns `MODE_TYPE_*` enums, which are referenced below.)\n  Pivot drills are only available in certain conditions, like all drills: structured queries with aggregation(s), when\n  clicking a specific cell.\n  - No breakouts: any pivot is permitted. (`metric` mode)\n  - Exactly one date breakout, with an optional category breakout: no `:time` pivot. (`timeseries` mode)\n  - Exactly one breakout and it's an address: no `:location` pivot. (`geo` mode)\n  - One or two category breakouts: no `:location` pivot. (`pivot` mode)\n  - If all these conditions fail, no pivots are allowed and the pivot drill should not be returned.\n\n  This function encodes all these rules, returning a (possibly emtpy) set of permitted types.\"\n  [query                                         :- ::lib.schema/query\n   stage-number                                  :- :int]\n  (case (->> (lib.breakout/breakouts query stage-number)\n             (map #(breakout-type query stage-number %))\n             frequencies)\n    ({:date 1}\n     {:date 1, :category 1})\n    #{:category :location}\n\n    {:address 1}\n    #{:category :time}\n\n    {}\n    #{:category :location :time}\n\n    ({:category 1} {:category 2})\n    #{:category :time}\n\n    ;; If there are breakouts but none of those conditions matched, no pivots are permitted.\n    #{}))\n\n(mu/defn pivot-drill :- [:maybe ::lib.schema.drill-thru/drill-thru.pivot]\n  \"Return all possible pivoting options on the given column and value.\n\n  See `:pivots` key, which holds a map `{t [breakouts...]}` where `t` is `:category`, `:location`, or `:time`.\n  If a key is missing, there are no breakouts of that kind.\"\n  [query                                         :- ::lib.schema/query\n   stage-number                                  :- :int\n   {:keys [column dimensions value] :as context} :- ::lib.schema.drill-thru/context]\n  (when (and (lib.drill-thru.common/mbql-stage? query stage-number)\n             column\n             (some? value)\n             (= (:lib/source column) :source/aggregations)\n             (-> (lib.aggregation/aggregations query stage-number) count pos?))\n    (let [breakout-pivot-types (permitted-pivot-types query stage-number)\n          pivots               (into {} (for [pivot-type breakout-pivot-types\n                                              :let [pred    (get pivot-type-predicates pivot-type)\n                                                    columns (pivot-drill-pred query stage-number context pred)]\n                                              :when (not-empty columns)]\n                                          [pivot-type columns]))]\n      (when-not (empty? pivots)\n        {:lib/type   :metabase.lib.drill-thru/drill-thru\n         :type       :drill-thru/pivot\n         :dimensions dimensions\n         :pivots     pivots}))))\n\n(defmethod lib.drill-thru.common/drill-thru-info-method :drill-thru/pivot\n  [_query _stage-number drill-thru]\n  (select-keys drill-thru [:many-pks? :object-id :type]))\n\n;; Note that pivot drills have specific public functions for accessing the nested pivoting options.\n;; Therefore the [[drill-thru-info-method]] is just the default `{:type :drill-thru/pivot}`.\n\n(mu/defn pivot-types :- [:sequential ::lib.schema.drill-thru/pivot-types]\n  \"A helper for the FE. Returns the set of pivot types (category, location, time) that apply to this drill-thru.\"\n  [drill-thru :- [:and ::lib.schema.drill-thru/drill-thru\n                  [:map [:type [:= :drill-thru/pivot]]]]]\n  (-> drill-thru :pivots keys sort))\n\n(mu/defn pivot-columns-for-type :- [:sequential ::lib.schema.metadata/column]\n  \"A helper for the FE. Returns all the columns of the given type which can be used to pivot the query.\"\n  [drill-thru :- [:and ::lib.schema.drill-thru/drill-thru\n                  [:map [:type [:= :drill-thru/pivot]]]]\n   pivot-type :- ::lib.schema.drill-thru/pivot-types]\n  (get-in drill-thru [:pivots pivot-type]))\n\n(defn- breakouts->filters [query stage-number {:keys [column value] :as _dimension}]\n  (-> query\n      (lib.breakout/remove-existing-breakouts-for-column stage-number column)\n      (lib.filter/filter stage-number (lib.filter/= column value))))\n\n;; Pivot drills are in play when clicking an aggregation cell. Pivoting is applied by:\n;; 1. For each \"dimension\", ie. the specific values for all breakouts at the originally clicked cell:\n;;     a. Filter the query to have the dimension's column = the dimension's value at that cell.\n;;     b. Go through the breakouts, and remove any that match this dimension from the query.\n;; 2. Add a new breakout for the selected column.\n(defmethod lib.drill-thru.common/drill-thru-method :drill-thru/pivot\n  [query stage-number drill-thru & [column]]\n  (let [filtered (reduce #(breakouts->filters %1 stage-number %2) query (:dimensions drill-thru))]\n    (lib.breakout/breakout filtered stage-number column)))\n"]}