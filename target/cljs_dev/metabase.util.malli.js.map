{"version":3,"sources":["metabase/util/malli.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;6CAAA,qDAAAA,lGAAWI;AAAX,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;YAAA,AAAAE,4CAAAF,eAAA,nEAEWI;cAFX,AAAAF,4CAAAF,eAAA,rEAEiBK;AAFjB,AAIE,6DAAA,gGAAA,zGAAKA,0DAAa,AAAAC,kCAAA,kBAA2B,AAACC,wGAAOH;;AAEvD;;;8BAAA,9BAAWI,oEAERC,OAAOL;AAFV,0DAGM,AAACM,iDAAWD,OAAOL,lHACnB,yHAAA,2CAAA,7JAACO,iNAAmBR;;AAE1B,6BAAA,mFAAA,wEAAA,mFAAA,kDAAA,2CAAA,oEAAA,5aAAeS,mKACPC,kSACgCC;AAExC;;;8CAAA,9CAAKC;AAQL;;;;;;;4BAAA,5BAA0BC,+DAEvBC,QAAQC;AAFX,AAGE,OAACC,kEAAsB,AAACC,gDAAUH,SAASI,kEAAMH;;AAGnD;;;;;;;;;;;;;;6CAAA,7CAA0BI;;+DAStBL,QAAkBM;AATtB,AAUG,QAACD,2EAAAA,gHAAAA,vCAAuBL,4FAAAA,pFAAQM,4FAAAA,9EAAcA,4FAAAA;;+DAC7CN,QACAO,oBACAC;AAbJ,AAcG,oMAAA,wFAAA,rRAACN,kEAAsB,AAACC,gDAAUH,SAASS,sIAEPF,+EAEA,AAACG,qBAAWF;;sDAP/CR,QACAO,oBACAC;;;+DAFAR,QACAO;;+DADAP,QACAO,oBACAC;;;;;;;;;AA6DJ,AAAA;;;;uCAAA,+CAAAG,tFAAWM;AAAX,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,0EAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,4EAAA,5EAAWE,uFAGRM,WAAaC;;AAHhB,AAIE,oBAAIA;AACF,GAAI,AAACH,eAAKG;AACR,IAAMC,MAAI,AAACL,gBAAMI;IACXE,MAAI,AAACN,gBAAM,AAACC,eAAKG;IACjBG,MAAI,AAACC,+CAAUL,WAAWE,IAAIC;AAFpC,AAGE,eAAOC;eAAI,AAACE,gBAAML;;;;;AACpB,MAAO,gDAAA,uFAAA,vIAACM;;;AACVP;;;;;;AAXJ,CAAA,+DAAA,/DAAWN;;AAAX;AAAA,CAAA,yDAAA,WAAAC,pEAAWD;AAAX,AAAA,IAAAE,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,SAAAD;;;AAAA","names":["p__74685","map__74686","cljs.core/--destructure-map","cljs.core.get","metabase.util.malli/humanize-include-value","value","message","metabase.shared.util.i18n/js-i18n","cljs.core.pr_str","metabase.util.malli/explain","schema","malli.core.explain","malli.error.humanize","metabase.util.malli/Schema","cljs.core/any?","malli.core/schema","metabase.util.malli/localized-string-schema","metabase.util.malli/with","mschema","props","malli.util.update_properties","malli.core.schema","cljs.core/merge","metabase.util.malli/with-api-error-message","error-message","description-message","specific-error-message","cljs.core/assoc","cljs.core/constantly","var_args","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","metabase.util.malli/map-schema-assoc","seq74719","G__74720","cljs.core/first","cljs.core/next","self__5711__auto__","map-schema","kvs","key","val","ret","malli.util.assoc","cljs.core/nnext","cljs.core.ex_info"],"sourcesContent":["(ns metabase.util.malli\n  (:refer-clojure :exclude [fn defn defmethod])\n  (:require\n   #?@(:clj\n       ([metabase.util.i18n]\n        [metabase.util.malli.defn :as mu.defn]\n        [metabase.util.malli.fn :as mu.fn]\n        [net.cgrand.macrovich :as macros]\n        [potemkin :as p]))\n   [clojure.core :as core]\n   [malli.core :as mc]\n   [malli.destructure]\n   [malli.error :as me]\n   [malli.util :as mut]\n   [metabase.shared.util.i18n :as i18n])\n  #?(:cljs (:require-macros [metabase.util.malli])))\n\n#?(:clj\n   (p/import-vars\n    [mu.fn fn]\n    [mu.defn defn]))\n\n(core/defn humanize-include-value\n  \"Pass into mu/humanize to include the value received in the error message.\"\n  [{:keys [value message]}]\n  ;; TODO Should this be translated with more complete context? (tru \"{0}, received: {1}\" message (pr-str value))\n  (str message \", \" (i18n/tru \"received\") \": \" (pr-str value)))\n\n(core/defn explain\n  \"Explains a schema failure, and returns the offending value.\"\n  [schema value]\n  (-> (mc/explain schema value)\n      (me/humanize {:wrap humanize-include-value})))\n\n(def ^:private Schema\n  [:and any?\n   [:fn {:description \"a malli schema\"} mc/schema]])\n\n(def localized-string-schema\n  \"Schema for localized string.\"\n  #?(:clj  [:fn {:error/message \"must be a localized string\"}\n            metabase.util.i18n/localized-string?]\n     ;; TODO Is there a way to check if a string is being localized in CLJS, by the `ttag`?\n     ;; The compiler seems to just inline the translated strings with no annotation or wrapping.\n     :cljs :string))\n\n(metabase.util.malli/defn with\n  \"Update a malli schema with an arbitrary map of properties\"\n  [mschema props]\n  (mut/update-properties (mc/schema mschema) merge props))\n\n;; Kondo gets confused by :refer [defn] on this, so it's referenced fully qualified.\n(metabase.util.malli/defn with-api-error-message\n  \"Update a malli schema to have a :description (used by umd/describe, which is used by api docs),\n  and a :error/fn (used by me/humanize, which is used by defendpoint).\n  They don't have to be the same, but usually are.\n\n  (with-api-error-message\n    [:string {:min 1}]\n    (deferred-tru \\\"Must be a string with at least 1 character representing a User ID.\\\"))\"\n  {:style/indent [:form]}\n  ([mschema :- Schema error-message :- localized-string-schema]\n   (with-api-error-message mschema error-message error-message))\n  ([mschema                :- :any\n    description-message    :- localized-string-schema\n    specific-error-message :- localized-string-schema]\n   (mut/update-properties (mc/schema mschema) assoc\n                          ;; override generic description in api docs and :errors key in API's response\n                          :description description-message\n                          ;; override generic description in :specific-errors key in API's response\n                          :error/fn    (constantly specific-error-message))))\n\n#?(:clj\n   (defmacro disable-enforcement\n     \"Convenience for disabling [[defn]] and [[metabase.util.malli.fn/fn]] input/output schema validation. Since\n  input/output validation is currently disabled for ClojureScript, this is a no-op.\"\n     {:style/indent 0}\n     [& body]\n     (macros/case\n       :clj\n       `(binding [mu.fn/*enforce* false]\n          ~@body)\n\n       :cljs\n       `(do ~@body))))\n\n#?(:clj\n   (defmacro -defmethod-clj\n     \"Impl for [[defmethod]] for regular Clojure.\"\n     [multifn dispatch-value & fn-tail]\n     (let [dispatch-value-symb (gensym \"dispatch-value-\")\n           error-context-symb  (gensym \"error-context-\")]\n       `(let [~dispatch-value-symb ~dispatch-value\n              ~error-context-symb  {:fn-name        '~(or (some-> (resolve multifn) symbol)\n                                                          (symbol multifn))\n                                    :dispatch-value ~dispatch-value-symb}\n              f#                   ~(mu.fn/instrumented-fn-form error-context-symb (mu.fn/parse-fn-tail fn-tail))]\n          (.addMethod ~(vary-meta multifn assoc :tag 'clojure.lang.MultiFn)\n                      ~dispatch-value-symb\n                      f#)))))\n#?(:clj\n   (defmacro -defmethod-cljs\n     \"Impl for [[defmethod]] for ClojureScript.\"\n     [multifn dispatch-value & fn-tail]\n     `(core/defmethod ~multifn ~dispatch-value\n        ~@(mu.fn/deparameterized-fn-tail (mu.fn/parse-fn-tail fn-tail)))))\n\n#?(:clj\n   (defmacro defmethod\n     \"Like [[schema.core/defmethod]], but for Malli.\"\n     [multifn dispatch-value & fn-tail]\n     (macros/case\n       :clj  `(-defmethod-clj ~multifn ~dispatch-value ~@fn-tail)\n       :cljs `(-defmethod-cljs ~multifn ~dispatch-value ~@fn-tail))))\n\n#?(:clj\n   (defn validate-throw\n     \"Returns the value if it matches the schema, else throw an exception.\"\n     [schema-or-validator value]\n     (if-not ((if (fn? schema-or-validator)\n                schema-or-validator\n                (mc/validator schema-or-validator))\n              value)\n       (throw (ex-info \"Value does not match schema\" {:value value :schema schema-or-validator}))\n       value)))\n\n(core/defn map-schema-assoc\n  \"Returns a new schema that is the same as map-schema, but with the key k associated with the value v.\n   If kvs are provided, they are also associated with the schema.\"\n  [map-schema & kvs]\n  (if kvs\n    (if (next kvs)\n      (let [key (first kvs)\n            val (first (next kvs))\n            ret (mut/assoc map-schema key val)]\n        (recur ret (nnext kvs)))\n      (throw (ex-info \"map-schema-assoc expects even number of arguments after schema-map, found odd number\" {})))\n    map-schema))\n"]}