{"version":3,"sources":["metabase/lib/schema/expression/arithmetic.cljc"],"mappings":"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","names":["p__75318","vec__75319","cljs.core.nth","metabase.lib.schema.expression.arithmetic/valid-interval-for-type?","_tag","_opts","_n","unit","_interval","expr-type","unit-schema","cljs.core.isa_QMARK_","metabase.util.malli.registry/validate","metabase.util.malli.registry/register!","p__75326","vec__75327","seq__75328","cljs.core/seq","first__75329","cljs.core/first","cljs.core/next","metabase.lib.schema.expression.arithmetic/validate-plus-minus-temporal-arithmetic-expression","exprs","map__75331","cljs.core/--destructure-map","cljs.core.get","non-intervals","intervals","p1__75325#","cljs.core/group-by","metabase.lib.schema.expression/type-of","cljs.core.not_EQ_","cljs.core/count","cljs.core/some","p__75333","vec__75334","interval","p__75342","map__75343","value","_","cljs.core/complement","metabase.lib.schema.expression.arithmetic/type-of-numeric-arithmetic-arg","expr","and__5000__auto__","metabase.lib.schema.expression.arithmetic/type-of-numeric-arithmetic-args","args","cljs.core.transduce","cljs.core.map","cljs.core.completing","x","y","metabase.types/most-specific-common-ancestor","metabase.lib.schema.expression.arithmetic/type-of-temporal-arithmetic-args","first-non-interval-arg-type","p1__75348#","medley.core.find_first","metabase.lib.schema.expression.arithmetic/type-of-arithmetic-args","tag","p1__75353#","cljs.core._EQ_","p1__75355#","cljs.core/every?","p1__75359#","metabase.lib.schema.common/normalize-keyword","metabase.lib.schema.mbql_clause.define_mbql_clause","p__75530","vec__75531","seq__75532","first__75533","p1__75529#","metabase.lib.schema.common/is-clause?","p__75535","vec__75536","seq__75537","first__75538","p1__75534#","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","seq__75539","chunk__75540","count__75541","i__75542","temp__5804__auto__","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","metabase.lib.hierarchy/derive","metabase.lib.schema.expression/type-of-method","p__75543","vec__75544","seq__75545","first__75546","metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","seq__75547","chunk__75548","count__75549","i__75550","op","seq__75551","chunk__75552","count__75553","i__75554","p__75555","vec__75556","exponent"],"sourcesContent":["(ns metabase.lib.schema.expression.arithmetic\n  \"Arithmetic expressions like `:+`.\"\n  (:require\n   [medley.core :as m]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.types :as types]\n   [metabase.util.malli.registry :as mr]))\n\n(defn- valid-interval-for-type? [[_tag _opts _n unit :as _interval] expr-type]\n  (let [unit-schema (cond\n                      (isa? expr-type :type/Date)     ::temporal-bucketing/unit.date.interval\n                      (isa? expr-type :type/Time)     ::temporal-bucketing/unit.time.interval\n                      (isa? expr-type :type/DateTime) ::temporal-bucketing/unit.date-time.interval)]\n    (if unit-schema\n      (mr/validate unit-schema unit)\n      true)))\n\n(mr/def ::args.numbers\n  [:repeat {:min 2} [:schema [:ref ::expression/number]]])\n\n(defn- validate-plus-minus-temporal-arithmetic-expression\n  \"Validate a `:+` or `:-` expression with temporal args. Return a string describing any errors found, or `nil` if it\n  looks ok.\"\n  [[_tag _opts & exprs]]\n  (let [{non-intervals false, intervals true} (group-by #(isa? (expression/type-of %) :type/Interval) exprs)]\n    (cond\n      (not= (count non-intervals) 1)\n      \"Temporal arithmetic expression must contain exactly one non-interval value\"\n\n      (< (count intervals) 1)\n      \"Temporal arithmetic expression must contain at least one :interval\"\n\n      :else\n      (let [expr-type (expression/type-of (first non-intervals))]\n        (some (fn [[_tag _opts _n unit :as interval]]\n                (when-not (valid-interval-for-type? interval expr-type)\n                  (str \"Cannot add a \" unit \" interval to a \" expr-type \" expression\")))\n              intervals)))))\n\n;;; TODO -- doesn't really make sense to say something like `[:- <interval -1 day> \"2023-11-23\"]`, does it? What does -1\n;;; day minus <date> mean?\n(mr/def ::plus-minus-temporal-interval-schema\n  [:and\n   {:error/message \":+ or :- clause with a temporal expression and one or more :interval clauses\"}\n   [:cat\n    {:min 4}\n    [:enum :+ :-]\n    [:schema [:ref ::common/options]]\n    [:repeat [:schema [:ref :mbql.clause/interval]]]\n    [:schema [:ref ::expression/temporal]]\n    [:repeat [:schema [:ref :mbql.clause/interval]]]]\n   [:fn\n    {:error/fn (fn [{:keys [value]} _]\n                 (str \"Invalid :+ or :- clause: \" (validate-plus-minus-temporal-arithmetic-expression value)))}\n    (complement validate-plus-minus-temporal-arithmetic-expression)]])\n\n(mr/def ::plus-minus-numeric-schema\n  [:cat\n   {:error/message \":+ or :- clause with numeric args\"}\n   :keyword\n   [:schema [:ref ::common/options]]\n   [:repeat {:min 2} [:schema [:ref ::expression/number]]]])\n\n(defn- type-of-numeric-arithmetic-arg [expr]\n  (let [expr-type (expression/type-of expr)]\n    (if (and (isa? expr-type ::expression/type.unknown)\n             (mr/validate :metabase.lib.schema.ref/ref expr))\n      :type/Number\n      expr-type)))\n\n(defn- type-of-numeric-arithmetic-args\n  \"Given a sequence of args to a numeric arithmetic expression like `:+`, determine the type returned by the expression\n  by calculating the most-specific common ancestor type of all the args. E.g. `[:+ ... 2.0 2.0]` has two `:type/Float`\n  args, and thus the most-specific common ancestor type is `:type/Float`. `[:+ ... 2.0 2]` has a `:type/Float` and a\n  `:type/Integer` arg; the most-specific common ancestor type is `:type/Number`. For refs without type\n  information (e.g. `:field` clauses), assume `:type/Number`.\"\n  [args]\n  (transduce\n   (map type-of-numeric-arithmetic-arg)\n   (completing (fn [x y]\n                 (if (nil? x)\n                   y\n                   (types/most-specific-common-ancestor x y))))\n   nil\n   args))\n\n(defn- type-of-temporal-arithmetic-args\n  \"Given a temporal value plus one or more intervals `args` passed to an arithmetic expression like `:+`, determine the\n  overall type returned by the expression. This is the type of the temporal value (the arg that is not an interval),\n  or assume `:type/Temporal` if it is a ref without type information.\"\n  [args]\n  (let [first-non-interval-arg-type (m/find-first #(not (isa? % :type/Interval))\n                                                  (map expression/type-of args))]\n    (if (isa? first-non-interval-arg-type ::expression/type.unknown)\n      :type/Temporal\n      first-non-interval-arg-type)))\n\n(defn- type-of-arithmetic-args\n  \"Given a sequence of `args` to an arithmetic expression like `:+`, determine the overall type that the expression\n  returns. There are three types of arithmetic expressions:\n\n  * Ones consisting of numbers. See [[type-of-numeric-arithmetic-args]].\n\n  * Ones consisting of a temporal value like a Date plus one or more `:interval` clauses, in any order. See\n    [[type-of-temporal-arithmetic-args]].\n\n  * Ones consisting of exactly two temporal values being subtracted to produce an `:interval`. See\n    [[type-of-temporal-arithmetic-args]].\"\n  [tag args]\n  (cond\n    ;; temporal value + intervals\n    (some #(isa? (expression/type-of %) :type/Interval) args)\n    (type-of-temporal-arithmetic-args args)\n\n    ;; the difference of exactly two temporal values\n    (and (= tag :-)\n         (= (count args) 2)\n         (or (every? #(isa? (expression/type-of %) :type/Date) args)\n             (every? #(isa? (expression/type-of %) :type/DateTime) args)))\n    :type/Interval\n\n    ;; fall back to numeric args\n    :else (type-of-numeric-arithmetic-args args)))\n\n(mr/def ::temporal-difference-schema\n  [:cat\n   {:error/message \":- clause taking the difference of two temporal expressions\"}\n   [:= {:decode/normalize common/normalize-keyword} :-]\n   [:schema [:ref ::common/options]]\n   [:schema [:ref ::expression/temporal]]\n   [:schema [:ref ::expression/temporal]]])\n\n(mbql-clause/define-mbql-clause :+\n  [:and\n   {:error/message \"valid :+ clause\"}\n   [:cat\n    [:= {:decode/normalize common/normalize-keyword} :+]\n    [:schema [:ref ::common/options]]\n    [:+ {:min 2} :any]]\n   [:multi\n    {:dispatch (fn [[_tag _opts & args]]\n                 (if (some #(common/is-clause? :interval %)\n                           args)\n                   :temporal\n                   :numeric))}\n    [:temporal [:ref ::plus-minus-temporal-interval-schema]]\n    [:numeric  [:ref ::plus-minus-numeric-schema]]]])\n\n;;; TODO -- should `:-` support just a single arg (for numbers)? What about `:+`?\n(mbql-clause/define-mbql-clause :-\n  [:and\n   [:cat\n    [:= {:decode/normalize common/normalize-keyword} :-]\n    [:schema [:ref ::common/options]]\n    [:+ {:min 2} :any]]\n   [:multi\n    {:dispatch (fn [[_tag _opts & args]]\n                 (cond\n                   (some #(common/is-clause? :interval %) args) :temporal\n                   (> (count args) 2)                           :numeric\n                   :else                                        :numeric-or-temporal-difference))}\n    [:temporal [:ref ::plus-minus-temporal-interval-schema]]\n    [:numeric  [:ref ::plus-minus-numeric-schema]]\n    ;; TODO -- figure out a way to know definitively what type of `:-` this should be so we don't need to use `:or`\n    [:numeric-or-temporal-difference\n     [:or\n      [:ref ::plus-minus-numeric-schema]\n      [:ref ::temporal-difference-schema]]]]])\n\n(mbql-clause/define-catn-mbql-clause :*\n  [:args ::args.numbers])\n\n;;; we always do non-integer real division even if all the expressions are integers, e.g.\n;;;\n;;;    [:/ <int-field>  2] => my_int_field / 2.0\n;;;\n;;; so the results are 0.5 as opposed to 0. This is what people expect division to do\n(mbql-clause/define-catn-mbql-clause :/ :- :type/Float\n  [:args ::args.numbers])\n\n(doseq [tag [:+ :- :*]]\n  (lib.hierarchy/derive tag :lib.type-of/type-is-type-of-arithmetic-args))\n\n;;; `:+`, `:-`, and `:*` all have the same logic; also used for [[metabase.lib.metadata.calculation/type-of-method]]\n(defmethod expression/type-of-method :lib.type-of/type-is-type-of-arithmetic-args\n  [[tag _opts & args]]\n  (type-of-arithmetic-args tag args))\n\n(mbql-clause/define-tuple-mbql-clause :abs\n  [:schema [:ref ::expression/number]])\n\n(lib.hierarchy/derive :abs :lib.type-of/type-is-type-of-first-arg)\n\n(doseq [op [:log :exp :sqrt]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Float\n    [:schema [:ref ::expression/number]]))\n\n(doseq [op [:ceil :floor :round]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Integer\n    [:schema [:ref ::expression/number]]))\n\n(mbql-clause/define-tuple-mbql-clause :power\n  #_num [:schema [:ref ::expression/number]]\n  #_exp [:schema [:ref ::expression/number]])\n\n(defmethod expression/type-of-method :power\n  [[_tag _opts expr exponent]]\n  ;; if both expr and exponent are integers, this will return an integer.\n  (if (and (isa? (expression/type-of expr) :type/Integer)\n           (isa? (expression/type-of exponent) :type/Integer))\n    :type/Integer\n    ;; otherwise this will return some sort of number with a decimal place. e.g.\n    ;;\n    ;;    (Math/pow 2 2.1) => 4.2870938501451725\n    ;;\n    ;; If we don't know the type of `expr` or `exponent` it's safe to assume `:type/Float` anyway, maybe not as\n    ;; specific as `:type/Integer` but better than `:type/*` or `::expression/type.unknown`.\n    :type/Float))\n"]}