{"version":3,"sources":["metabase/util/memoize.cljs"],"mappings":"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","names":["this__5287__auto__","writer__5288__auto__","opt__5289__auto__","cljs.core/-write","metabase.util.memoize/RetryingDelay","metabase.util.memoize/->RetryingDelay","fun","available?","value","_","v","metabase.util.memoize/d-lay","metabase.util.memoize/make-derefable","cljs.core/IDeref","metabase.util.memoize/t_metabase$util$memoize74657","metabase.util.memoize/derefable-seed","seed","cljs.core/update-vals","cljs.core/PROTOCOL_SENTINEL","metabase.util.memoize/PluggableMemoization","metabase.util.memoize/->PluggableMemoization","f","cache","item","cljs.cache/has?","cljs.cache/hit","result","cljs.cache/miss","key","cljs.cache/evict","cljs.cache/lookup","not-found","cljs.core/Delay","base","cljs.cache/seed","p1__74713#","metabase.util.memoize/args-fn","or__5002__auto__","cljs.core/meta","cljs.core/identity","metabase.util.memoize/through*","args","p1__74714#","cljs.cache.through","cljs.core.apply","metabase.util.memoize/cached-function","cache-atom","ckey-fn","ckey","cs","cljs.core.swap_BANG_","val","cljs.core/deref","n","cljs.core._EQ_","temp__5804__auto__","v'","var_args","G__74716","metabase.util.memoize/memoizer","js/Error","cljs.core.atom","G__74725","metabase.util.memoize/lru","metabase.util.memoize.lru","tkey","threshold","metabase.util.memoize.memoizer","cljs.cache.lru_cache_factory"],"sourcesContent":["(ns metabase.util.memoize\n  \"Copied from clojure.core.memoize.\"\n  (:require [cljs.cache :as cache]))\n\n;; Similar to clojure.lang.Delay, but will not memoize an exception and will\n;; instead retry.\n;;   fun - the function, never nil\n;;   available? - indicates a memoized value is available, volatile for visibility\n;;   value - the value (if available) - volatile for visibility\n(deftype RetryingDelay [fun ^:volatile-mutable available? ^:volatile-mutable value]\n  IDeref\n  (-deref [_]\n    ;; first check (safe with volatile flag)\n    (if available?\n      value\n      ;; fun may throw - will retry on next deref\n      (let [v (fun)]\n        (set! value v)\n        (set! available? true)\n        v)))\n  IPending\n  (-realized? [_]\n    available?))\n\n(defn- d-lay [fun]\n  (->RetryingDelay fun false nil))\n\n(defn- make-derefable\n  \"If a value is not already derefable, wrap it up.\n\n  This is used to help rebuild seed/base maps passed in to the various\n  caches so that they conform to core.memoize's world view.\"\n  [v]\n  (if (instance? IDeref v)\n    v\n    (reify IDeref\n      (-deref [_] v))))\n\n(defn- derefable-seed\n  \"Given a seed/base map, ensure all the values in it are derefable.\"\n  [seed]\n  (update-vals seed make-derefable))\n\n(deftype PluggableMemoization [f cache]\n  cache/CacheProtocol\n  (has? [_ item]\n    (cache/has? cache item))\n  (hit  [_ item]\n    (PluggableMemoization. f (cache/hit cache item)))\n  (miss [_ item result]\n    (PluggableMemoization. f (cache/miss cache item result)))\n  (evict [_ key]\n    (PluggableMemoization. f (cache/evict cache key)))\n  (lookup [_ item]\n    (cache/lookup cache item nil))\n  (lookup [_ item not-found]\n    (cache/lookup cache item (delay not-found)))\n  (seed [_ base]\n    (PluggableMemoization.\n     f (cache/seed cache (derefable-seed base))))\n  Object\n  (toString [_] (str cache)))\n\n(def ^{:private true\n       :doc \"Returns a function's argument transformer.\"}\n  args-fn #(or (::args-fn (meta %)) identity))\n\n(defn- through*\n  \"The basic hit/miss logic for the cache system based on `cache/through`.\n  Clojure delays are used to hold the cache value.\"\n  [cache f args item]\n  (cache/through\n   (fn [f _] (d-lay #(f args)))\n   #(apply f %)\n   cache\n   item))\n\n(defn- cached-function\n  \"Given a function, an atom containing a (pluggable memoization cache), and\n  and cache key function, return a new function that behaves like the original\n  function except it is cached, based on its arguments.\"\n  [f cache-atom ckey-fn]\n  (fn [& args]\n    (let [ckey (or (ckey-fn args) [])\n          cs   (swap! cache-atom through* f args ckey)\n          val  (cache/lookup cs ckey ::not-found)]\n       ;; If `lookup` returns `(delay ::not-found)`, it's likely that\n       ;; we ran into a timing issue where eviction and access\n       ;; are happening at about the same time. Therefore, we retry\n       ;; the `swap!` (potentially several times).\n       ;;\n       ;; metabase.util.memoize currently wraps all of its values in a `delay`.\n      (when val\n        (loop [n 0 v @val]\n          (if (= ::not-found v)\n            (when-let [v' (cache/lookup\n                           (swap! cache-atom through* f args ckey)\n                           ckey ::not-found)]\n              (when (< n 10)\n                (recur (inc n) @v')))\n            v))))))\n\n(defn memoizer\n  \"Build a pluggable memoized version of a function. Given a function and a\n  (pluggable memoized) cache, and an optional seed (hash map of arguments to\n  return values), return a cached version of that function.\n\n  If you want to build your own cached function, perhaps with combined caches\n  or customized caches, this is the preferred way to do so now.\"\n  ([f cache]\n   (let [cache   (atom (PluggableMemoization. f cache))\n         ckey-fn (args-fn f)]\n     (cached-function f cache ckey-fn)))\n  ([f cache seed]\n   (let [cache   (atom (cache/seed (PluggableMemoization. f cache)\n                                   (derefable-seed seed)))\n         ckey-fn (args-fn f)]\n     (cached-function f cache ckey-fn))))\n\n(defn lru\n  \"Works the same as the basic memoization function (i.e.\n   `core.memoize` except when a given threshold is breached.\n   When the threshold is passed, the cache will expel the\n   **L**east **R**ecently **U**sed element in favor of the new.\"\n  ([f] (lru f {} :lru/threshold 32))\n  ([f base] (lru f base :lru/threshold 32))\n  ([f tkey threshold] (lru f {} tkey threshold))\n  ([f base key threshold]\n   (assert (= key :lru/threshold) (str \"wrong parameter key \" key))\n   (memoizer f (cache/lru-cache-factory {} :threshold threshold) base)))\n"]}