{"version":3,"sources":["metabase/lib/filter/update.cljc"],"mappings":"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","names":["metabase.lib.filter.update/is-ref-for-column?","expr","column","and__5000__auto__","metabase.lib.util/clause-of-type?","metabase.lib.equality.find_matching_column","metabase.lib.filter.update/remove-existing-filters-against-column","query","stage-number","cljs.core.reduce","p__79712","vec__79713","cljs.core.nth","_tag","_opts","filter-clause","metabase.lib.remove_replace.remove_clause","metabase.lib.filter.filters","metabase.lib.filter.update/update-numeric-filter","numeric-column","start","end","vec__79716","cljs.core.sort","metabase.lib.filter.filter","metabase.lib.filter/between","metabase.lib.filter.update/temporal-filter-min-num-points","metabase.lib.filter.update/unit->next-unit","units","cljs.core/zipmap","cljs.core/cons","metabase.lib.filter.update/temporal-filter-find-best-breakout-unit","unit","num-points","metabase.shared.util.time.unit_diff","too-few-points?","temp__5802__auto__","next-largest-unit","metabase.lib.filter.update/temporal-filter-update-breakouts","new-unit","cljs.core.transduce","cljs.core/identity","p__79719","map__79721","cljs.core/--destructure-map","cljs.core.get","p__79720","map__79722","has-seen-column?","m","breakout","query'","col-ref","metabase.lib.ref/ref","metabase.lib.temporal-bucket/with-temporal-bucket","metabase.lib.remove_replace.replace_clause","metabase.lib.breakout.breakouts","metabase.util.malli.registry/register!","p1__79723#","js/Date","metabase.lib.filter.update/update-temporal-filter","temporal-column","metabase.lib.temporal-bucket/raw-temporal-bucket","maybe-string","t","G__79724","metabase.shared.util.time.format_for_base_type","cljs.core.some_fn","cljs.core/not","metabase.shared.util.time.truncate","metabase.shared.util.time.add","breakout-unit","cljs.core._EQ_","metabase.lib.filter/=","cljs.core/number?","p__79725","map__79726","metabase.lib.filter.update/update-lat-lon-filter","latitude-column","longitude-column","bounds","north","east","south","west","_bounds","vec__79727","vec__79730","lat-min","lat-max","lon-min","lon-max","metabase.lib.filter/inside"],"sourcesContent":["(ns metabase.lib.filter.update\n  \"Conveniences for adding or updating certain types of filters, used to power the drag-and-drop 'brush' zoom-in\n  filtering in the frontend. For example the user might drag the mouse between two points on a timeseries\n  visualization, and we use these functions to update the query accordingly and add a filter between the start and end\n  points.\n\n  There are three types of brush filters:\n\n  - [[update-temporal-filter]], which works on a single temporal column (e.g. zooming in on certain range in a\n    timeseries visualization)\n\n  - [[update-numeric-filter]], which works on a single numeric column\n\n  - [[update-lat-lon-filter]], which works on a latitude and longitude column pair. This is used with map visualizations --\n    draw a box between two points to zoom in to that part of the map.\n\n  If there is no existing filter on the column(s), these add a new filter. Existing filters are replaced.\"\n  (:require\n   [metabase.lib.breakout :as lib.breakout]\n   [metabase.lib.equality :as lib.equality]\n   [metabase.lib.filter :as lib.filter]\n   [metabase.lib.ref :as lib.ref]\n   [metabase.lib.remove-replace :as lib.remove-replace]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.literal :as lib.schema.literal]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.schema.temporal-bucketing :as lib.schema.temporal-bucketing]\n   [metabase.lib.temporal-bucket :as lib.temporal-bucket]\n   [metabase.lib.util :as lib.util]\n   [metabase.shared.util.time :as shared.ut]\n   [metabase.util.malli :as mu]\n   [metabase.util.malli.registry :as mr]))\n\n(defn- is-ref-for-column? [expr column]\n  (and (lib.util/clause-of-type? expr :field)\n       (lib.equality/find-matching-column expr [column])))\n\n(mu/defn ^:private remove-existing-filters-against-column :- ::lib.schema/query\n  \"Remove any existing filters clauses that use `column` as the first arg in a stage of a `query`.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   column       :- ::lib.schema.metadata/column]\n  (reduce\n   (fn [query [_tag _opts expr :as filter-clause]]\n     (if (is-ref-for-column? expr column)\n       (lib.remove-replace/remove-clause query stage-number filter-clause)\n       query))\n   query\n   (lib.filter/filters query stage-number)))\n\n(mu/defn update-numeric-filter :- ::lib.schema/query\n  \"Add or update a filter against `numeric-column`. Adapted from\n  https://github.com/metabase/metabase/blob/98bcd7fc3102bd7c07e8b68878c3738f3cb8727b/frontend/src/metabase-lib/queries/utils/actions.js#L151-L154\"\n  ([query numeric-column start end]\n   (update-numeric-filter query -1 numeric-column start end))\n\n  ([query          :- ::lib.schema/query\n    stage-number   :- :int\n    numeric-column :- ::lib.schema.metadata/column\n    start          :- number?\n    end            :- number?]\n   (let [[start end] (sort [start end])]\n     (-> query\n         (remove-existing-filters-against-column stage-number numeric-column)\n         (lib.filter/filter stage-number (lib.filter/between numeric-column start end))))))\n\n;;; points in this case correspond to the number of rows returned by a query if there are no gaps. E.g. if we have a\n;;; query like\n;;;\n;;;    orders, count aggregation, broken out by month(created_at) between 2024-01 and 2024-03 (inclusive)\n;;;\n;;; we would have at most 3 rows returned -- the value for 2024-01, the value for 2024-02, and the value for 2024-03.\n;;; If no rows have a created_at in that month, then those rows may not get returned. However, the FE should\n;;; interpolate the missing values and still include points with values of zero; that's what we mean when we\n;;; say \"points\" below.\n(def ^:private temporal-filter-min-num-points\n  \"Minimum number of points an updated query should return; if it will return less than this, switch to\n  the [[unit->next-unit]]. E.g. if we zoom in on a query using unit is `:day` and the zoomed in query would\n  only return 2 points, switch the unit to `:minute`.\"\n  4)\n\n(def ^:private unit->next-unit\n  \"E.g. the next unit after `:hour` is `:minute`.\"\n  (let [units [:minute :hour :day :week :month :quarter :year]]\n    (zipmap units (cons nil units))))\n\n(mu/defn ^:private temporal-filter-find-best-breakout-unit :- ::lib.schema.temporal-bucketing/unit.date-time.truncate\n  \"If the current breakout `unit` will not return at least [[temporal-filter-min-num-points]], find the largest unit\n  that will.\"\n  [unit  :- ::lib.schema.temporal-bucketing/unit.date-time.truncate\n   start :- ::lib.schema.literal/temporal\n   end   :- ::lib.schema.literal/temporal]\n  (loop [unit unit]\n    (let [num-points      (shared.ut/unit-diff unit start end)\n          too-few-points? (< num-points temporal-filter-min-num-points)]\n      (if-let [next-largest-unit (when too-few-points?\n                                   (unit->next-unit unit))]\n        (recur next-largest-unit)\n        unit))))\n\n(mu/defn ^:private temporal-filter-update-breakouts :- ::lib.schema/query\n  \"Update the first breakout against `column` so it uses `new-unit` rather than the original unit (if any); remove all\n  other breakouts against that column.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   column       :- ::lib.schema.metadata/column\n   new-unit     :- ::lib.schema.temporal-bucketing/unit.date-time.truncate]\n  (transduce\n   identity\n   (fn\n     ([{:keys [query]}]\n      query)\n     ([{:keys [query has-seen-column?], :as m} breakout]\n      (if (is-ref-for-column? breakout column)\n        (let [query' (if has-seen-column?\n                       ;; already seen a breakout for this column: remove other breakouts.\n                       (lib.remove-replace/remove-clause query stage-number breakout)\n                       ;; this is the first breakout we've seen for this column: replace it with one that uses\n                       ;; `new-unit`.\n                       (let [col-ref (lib.ref/ref (lib.temporal-bucket/with-temporal-bucket column new-unit))]\n                         (lib.remove-replace/replace-clause query stage-number breakout col-ref)))]\n          {:query query', :has-seen-column? true})\n        ;; not a breakout against `column`: ignore it\n        m)))\n   {:query query, :has-seen-column? false}\n   (lib.breakout/breakouts query stage-number)))\n\n;;; just for [[update-temporal-filter]], we will also support plain JavaScript `Date`s and moment.js Moments. We\n;;; should probably do this more generally, since `::lib.schema.literal/temporal` accepts `java.time` instances in\n;;; JVM... this is experimental for now to see if this works without too much trouble, we can generalize this more in\n;;; the future if it works nicely.\n(mr/def ::temporal-literal\n  #?(:clj\n     ::lib.schema.literal/temporal\n\n     :cljs\n     [:or\n      ::lib.schema.literal/temporal\n      [:fn\n       {:error/message \"Instance of a JS Date\"}\n       #(instance? js/Date %)]]))\n\n(mu/defn update-temporal-filter :- ::lib.schema/query\n  \"Add or update a filter against `temporal-column`. Modify the temporal unit for any breakouts. For use powering the\n  brush zoom-in in timeseries visualizations.\n\n  This is adapted from old MLv1 code here\n  https://github.com/metabase/metabase/blob/98bcd7fc3102bd7c07e8b68878c3738f3cb8727b/frontend/src/metabase-lib/queries/utils/actions.js#L75-L132\"\n  ([query temporal-column start end]\n   (update-temporal-filter query -1 temporal-column start end))\n\n  ([query           :- ::lib.schema/query\n    stage-number    :- :int\n    temporal-column :- ::lib.schema.metadata/column\n    start           :- ::temporal-literal\n    end             :- ::temporal-literal]\n   (let [query        (remove-existing-filters-against-column query stage-number temporal-column)\n         unit         (lib.temporal-bucket/raw-temporal-bucket temporal-column)\n         ;; convert start and end to plain strings if they are JavaScript Date instances. The truncation stuff will\n         ;; work better because the ISO-8601 Strings let us differentiate between Dates/DateTimes/Times better than\n         ;; raw Date does. Also, the FE won't have to worry about converting it later\n         maybe-string #?(:clj identity\n                         :cljs (fn [t]\n                                 (cond-> t\n                                   (not (string? t))\n                                   (shared.ut/format-for-base-type ((some-fn :effective-type :base-type) temporal-column)))))\n         start        (maybe-string start)\n         end          (maybe-string end)]\n     (if-not unit\n       ;; Temporal column is not bucketed: we don't need to update any temporal units here. Add/update a `:between`\n       ;; filter.\n       (lib.filter/filter query stage-number (lib.filter/between temporal-column start end))\n       ;; temporal-column IS bucketed: need to update the breakout(s) against this column.\n       (let [;; clamp range to unit to ensure we select exactly what's represented by the dots/bars. E.g. if I draw my\n             ;; filter from `2024-01-02` to `2024-03-05` and the unit is `:month`, we should only show the months\n             ;; between those two values, i.e. only `2024-02` and `2024-03`.\n             start         (shared.ut/truncate (shared.ut/add start unit 1) unit)\n             end           (shared.ut/truncate end unit)\n             ;; update the breakout unit if appropriate.\n             breakout-unit (temporal-filter-find-best-breakout-unit unit start end)\n             query         (if (= unit breakout-unit)\n                             query\n                             (temporal-filter-update-breakouts query stage-number temporal-column breakout-unit))]\n         ;; TODO: This \"same unit or multiple units\" logic exists in `shared.ut` somewhere; reuse it here.\n         (if (= (str start) (str end))\n           ;; is the start and end are the same (in whatever the original unit was) then just do an \"=\"\n           (lib.filter/filter query stage-number (lib.filter/= temporal-column start))\n           ;; otherwise do a between (which is inclusive)\n           (lib.filter/filter query stage-number (lib.filter/between temporal-column start end))))))))\n\n(mr/def ::lat-lon.bounds\n  [:map\n   [:north number?]\n   [:east  number?]\n   [:south number?]\n   [:west  number?]])\n\n(mu/defn update-lat-lon-filter :- ::lib.schema/query\n  \"For use powering the brush zoom-in behavior in map visualizations. Adapted from\n  https://github.com/metabase/metabase/blob/98bcd7fc3102bd7c07e8b68878c3738f3cb8727b/frontend/src/metabase-lib/queries/utils/actions.js#L134-L149\"\n  ([query latitude-column longitude-column bounds]\n   (update-lat-lon-filter query -1 latitude-column longitude-column bounds))\n\n  ([query                                        :- ::lib.schema/query\n    stage-number                                 :- :int\n    latitude-column                              :- ::lib.schema.metadata/column\n    longitude-column                             :- :some\n    {:keys [north east south west], :as _bounds} :- [:ref ::lat-lon.bounds]]\n   (-> query\n       (remove-existing-filters-against-column stage-number latitude-column)\n       (remove-existing-filters-against-column stage-number longitude-column)\n       (lib.filter/filter stage-number (let [[lat-min lat-max] (sort [north south])\n                                             [lon-min lon-max] (sort [east west])]\n                                         (lib.filter/inside latitude-column longitude-column lat-max lon-min lat-min lon-max))))))\n"]}