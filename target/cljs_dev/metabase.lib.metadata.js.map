{"version":3,"sources":["metabase/lib/metadata.cljc"],"mappings":"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","names":["metabase.lib.metadata/->metadata-provider","metadata-providerable","metabase.lib.metadata.protocols/metadata-provider?","G__76696","metabase.lib.metadata/database","metabase.lib.metadata.protocols/database","metabase.lib.metadata/tables","metabase.lib.metadata.protocols/tables","metabase.lib.metadata/table","table-id","metabase.lib.metadata.protocols/table","metabase.lib.metadata/fields","metabase.lib.metadata.protocols/fields","metabase.lib.metadata/metadatas-for-table","metadata-type","metabase.lib.metadata.protocols/metadatas-for-table","metabase.lib.metadata/field","field-id","metabase.lib.metadata.protocols/field","metabase.lib.metadata/setting","setting-key","metabase.lib.metadata.protocols/setting","metabase.lib.metadata/stage","query","stage-number","metabase.lib.util/query-stage","metabase.lib.metadata/stage-column","column-name","cljs.core/some","column","cljs.core._EQ_","metabase.lib.metadata/card","card-id","metabase.lib.metadata.protocols/card","metabase.lib.metadata/card-or-throw","or__5002__auto__","cljs.core.ex_info","metabase.shared.util.i18n.js_i18n","cljs.core.pr_str","metabase.lib.metadata/segment","segment-id","metabase.lib.metadata.protocols/segment","metabase.lib.metadata/metric","metric-id","temp__5804__auto__","card-meta","cljs.core.assoc","metabase.lib.metadata/table-or-card","temp__5802__auto__","metabase.lib.util/legacy-string-table-id->card-id","metabase.lib.metadata/editable?","map__76729","cljs.core/--destructure-map","cljs.core.get","source-table","source-card","stage0","cljs.core/boolean","and__5000__auto__","map__76730","id","metabase.lib.metadata/bulk-metadata","ids","cljs.core/not-empty","G__76731","cljs.core/set?","cljs.core.distinct","provider","results","metabase.lib.metadata.protocols/metadatas","id->result","cljs.core.into","cljs.core.map","cljs.core.juxt","cljs.core/identity","cljs.core.comp","cljs.core.filter","cljs.core/some?","metabase.lib.metadata/missing-bulk-metadata-error","metabase.lib.metadata/bulk-metadata-or-throw","fetched-ids","cljs.core.keep","seq__76732","cljs.core/seq","chunk__76733","count__76734","i__76735","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","cljs.core/contains?","metabase.lib.metadata/invoked-ids","metabase.lib.metadata.protocols/invoked-ids"],"sourcesContent":["(ns metabase.lib.metadata\n  (:require\n   [metabase.lib.metadata.protocols :as lib.metadata.protocols]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.util :as lib.util]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util.malli :as mu]))\n\n;;; TODO -- deprecate all the schemas below, and just use the versions in [[lib.schema.metadata]] instead.\n\n;;; Column vs Field?\n;;;\n;;; Lately I've been using `Field` to only mean a something that lives in the application database, i.e. something\n;;; that is associated with row in the `Field` table and has an `:id`. I'm using `Column` as a more generic term that\n;;; includes not only `Field`s but also the columns returned by a stage of a query, e.g. `SELECT count(*) AS count`\n;;; returns a `Column` called `count`, but it's not a `Field` because it's not associated with an actual Field in the\n;;; application database.\n\n(mu/defn ->metadata-provider :- ::lib.schema.metadata/metadata-provider\n  \"Get a MetadataProvider from something that can provide one.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable]\n  (if (lib.metadata.protocols/metadata-provider? metadata-providerable)\n    metadata-providerable\n    (some-> metadata-providerable :lib/metadata ->metadata-provider)))\n\n(mu/defn database :- ::lib.schema.metadata/database\n  \"Get metadata about the Database we're querying.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable]\n  (lib.metadata.protocols/database (->metadata-provider metadata-providerable)))\n\n(mu/defn tables :- [:sequential ::lib.schema.metadata/table]\n  \"Get metadata about all Tables for the Database we're querying.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable]\n  (lib.metadata.protocols/tables (->metadata-provider metadata-providerable)))\n\n(mu/defn table :- ::lib.schema.metadata/table\n  \"Find metadata for a specific Table, either by string `table-name`, and optionally `schema`, or by ID.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   table-id              :- ::lib.schema.id/table]\n  (lib.metadata.protocols/table (->metadata-provider metadata-providerable) table-id))\n\n(mu/defn fields :- [:sequential ::lib.schema.metadata/column]\n  \"Get metadata about all the Fields belonging to a specific Table.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   table-id              :- ::lib.schema.id/table]\n  (lib.metadata.protocols/fields (->metadata-provider metadata-providerable) table-id))\n\n(mu/defn metadatas-for-table :- [:sequential [:or\n                                              ::lib.schema.metadata/column\n                                              ::lib.schema.metadata/metric\n                                              ::lib.schema.metadata/segment]]\n  \"Return active (non-archived) metadatas associated with a particular Table, either Fields, Metrics, or\n   Segments -- `metadata-type` must be one of either `:metadata/column`, `:metadata/metric`, `:metadata/segment`.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   metadata-type         :- [:enum :metadata/column :metadata/metric :metadata/segment]\n   table-id              :- ::lib.schema.id/table]\n  (lib.metadata.protocols/metadatas-for-table (->metadata-provider metadata-providerable) metadata-type table-id))\n\n(mu/defn field :- [:maybe ::lib.schema.metadata/column]\n  \"Get metadata about a specific Field in the Database we're querying.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   field-id              :- ::lib.schema.id/field]\n  (lib.metadata.protocols/field (->metadata-provider metadata-providerable) field-id))\n\n(mu/defn setting :- any?\n  \"Get the value of a Metabase setting for the instance we're querying.\"\n  ([metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n    setting-key           :- [:or string? keyword?]]\n   (lib.metadata.protocols/setting (->metadata-provider metadata-providerable) setting-key)))\n\n;;;; Stage metadata\n\n(mu/defn stage :- [:maybe ::lib.schema.metadata/stage]\n  \"Get metadata associated with a particular `stage-number` of the query, if any. `stage-number` can be a negative\n  index.\n\n  Currently, only returns metadata if it is explicitly attached to a stage; in the future we will probably dynamically\n  calculate this stuff if possible based on DatabaseMetadata and previous stages. Stay tuned!\"\n  [query        :- :map\n   stage-number :- :int]\n  (:lib/stage-metadata (lib.util/query-stage query stage-number)))\n\n(mu/defn stage-column :- [:maybe ::lib.schema.metadata/column]\n  \"Metadata about a specific column returned by a specific stage of the query, e.g. perhaps the first stage of the\n  query has an expression `num_cans`, then\n\n    (lib.metadata/stage-column query stage \\\"num_cans\\\")\n\n  should return something like\n\n    {:name \\\"num_cans\\\", :base-type :type/Integer, ...}\n\n  This is currently a best-effort thing and will only return information about columns if stage metadata is attached\n  to a particular stage. In the near term future this should be better about calculating that metadata dynamically and\n  returning correct info here.\"\n  ([query       :- :map\n    column-name :- ::lib.schema.common/non-blank-string]\n   (stage-column query -1 column-name))\n\n  ([query        :- :map\n    stage-number :- :int\n    column-name  :- ::lib.schema.common/non-blank-string]\n   (some (fn [column]\n           (when (= (:name column) column-name)\n             column))\n         (:columns (stage query stage-number)))))\n\n(mu/defn card :- [:maybe ::lib.schema.metadata/card]\n  \"Get metadata for a Card, aka Saved Question, with `card-id`, if it can be found.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   card-id               :- ::lib.schema.id/card]\n  (lib.metadata.protocols/card (->metadata-provider metadata-providerable) card-id))\n\n(mu/defn card-or-throw :- ::lib.schema.metadata/card\n  \"Like [[card]], but throws if the Card is not found.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   card-id               :- ::lib.schema.id/card]\n  (or (card metadata-providerable card-id)\n      (throw (ex-info (i18n/tru \"Card {0} does not exist, or belongs to a different Database.\" (pr-str card-id))\n                      {:card-id card-id}))))\n\n(mu/defn segment :- [:maybe ::lib.schema.metadata/segment]\n  \"Get metadata for the Segment with `segment-id`, if it can be found.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   segment-id            :- ::lib.schema.id/segment]\n  (lib.metadata.protocols/segment (->metadata-provider metadata-providerable) segment-id))\n\n(mu/defn metric :- [:maybe ::lib.schema.metadata/metric]\n  \"Get metadata for the Metric with `metric-id`, if it can be found.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   metric-id             :- ::lib.schema.id/metric]\n  (when-let [card-meta (lib.metadata.protocols/card (->metadata-provider metadata-providerable) metric-id)]\n    (when (= (:type card-meta) :metric)\n      (assoc card-meta :lib/type :metadata/metric))))\n\n(mu/defn table-or-card :- [:maybe [:or ::lib.schema.metadata/card ::lib.schema.metadata/table]]\n  \"Convenience, for frontend JS usage (see #31915): look up metadata based on Table ID, handling legacy-style\n  `card__<id>` strings as well. Throws an Exception (Clj-only, due to Malli validation) if passed an integer Table ID\n  and the Table does not exist, since this is a real error; however if passed a `card__<id>` that does not exist,\n  simply returns `nil` (since we do not have a strict expectation that Cards always be present in the\n  MetadataProvider).\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   table-id              :- [:or ::lib.schema.id/table :string]]\n  (if-let [card-id (lib.util/legacy-string-table-id->card-id table-id)]\n    (card metadata-providerable card-id)\n    (table metadata-providerable table-id)))\n\n(mu/defn editable? :- :boolean\n  \"Given a query, returns whether it is considered editable.\n\n  There's no editable flag! Instead, a query is **not** editable if:\n  - Database is missing from the metadata (no permissions at all);\n  - Database is present but it doesn't have native write permissions;\n  - Database is present but tables (at least the `:source-table`) are missing (missing table permissions); or\n  - Similarly, the card specified by `:source-card` is missing from the metadata.\n  If metadata for the `:source-table` or `:source-card` can be found, then the query is editable.\"\n  [query :- ::lib.schema/query]\n  (let [{:keys [source-table source-card] :as stage0} (lib.util/query-stage query 0)]\n    (boolean (and (when-let [{:keys [id]} (database query)]\n                    (= (:database query) id))\n                  (or (and source-table (table query source-table))\n                      (and source-card  (card  query source-card))\n                      (and\n                       (= (:lib/type stage0) :mbql.stage/native)\n                       ;; Couldn't import and use `lib.native/has-write-permissions` here due to a circular dependency\n                       ;; TODO Find a way to unify has-write-permissions and this function?\n                       (= :write (:native-permissions (database query)))))))))\n\n;;; TODO -- I'm wondering if we need both this AND [[bulk-metadata-or-throw]]... most of the rest of the stuff here\n;;; throws if we can't fetch the metadata, not sure what situations we wouldn't want to do that in places that use\n;;; this (like QP middleware). Maybe we should only have a throwing version.\n(mu/defn bulk-metadata :- [:maybe [:sequential [:map\n                                                [:lib/type :keyword]\n                                                [:id pos-int?]]]]\n  \"Fetch multiple objects in bulk. If our metadata provider is a bulk provider (e.g., the application database\n  metadata provider), does a single fetch with [[lib.metadata.protocols/bulk-metadata]] if not (i.e., if this is a\n  mock provider), fetches them with repeated calls to the appropriate single-object method,\n  e.g. [[lib.metadata.protocols/field]].\n\n  The order of the returned objects will match the order of `ids`, but does check that all objects are returned. If\n  you want that behavior, use [[bulk-metadata-or-throw]] instead.\n\n  This can also be called for side-effects to warm the cache.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   metadata-type         :- ::lib.schema.metadata/type\n   ids                   :- [:maybe [:or [:sequential pos-int?] [:set pos-int?]]]]\n  (when-let [ids (not-empty (cond-> ids\n                              (not (set? ids)) distinct))] ; remove duplicates but preserve order.\n    (let [provider   (->metadata-provider metadata-providerable)\n          results    (lib.metadata.protocols/metadatas provider metadata-type ids)\n          id->result (into {} (map (juxt :id identity)) results)]\n      (into []\n            (comp (map id->result)\n                  (filter some?))\n            ids))))\n\n(defn- missing-bulk-metadata-error [metadata-type id]\n  (ex-info (i18n/tru \"Failed to fetch {0} {1}: either it does not exist, or it belongs to a different Database\"\n                     (pr-str metadata-type)\n                     (pr-str id))\n           {:status-code   400\n            :metadata-type metadata-type\n            :id            id}))\n\n(mu/defn bulk-metadata-or-throw :- [:maybe [:sequential [:map\n                                                         [:lib/type :keyword]\n                                                         [:id pos-int?]]]]\n  \"Like [[bulk-metadata]], but verifies that all the requested objects were returned; throws an Exception otherwise.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   metadata-type         :- ::lib.schema.metadata/type\n   ids                   :- [:maybe [:or [:sequential pos-int?] [:set pos-int?]]]]\n  (let [results     (bulk-metadata metadata-providerable metadata-type ids)\n        fetched-ids (into #{} (keep :id) results)]\n    (doseq [id ids]\n      (when-not (contains? fetched-ids id)\n        (throw (missing-bulk-metadata-error metadata-type id))))\n    results))\n\n;; Invocation tracker provider\n(mu/defn invoked-ids :- [:maybe [:sequential :any]]\n  \"Get all invoked ids of a metadata type.\"\n  [metadata-providerable :- ::lib.schema.metadata/metadata-providerable\n   metadata-type         :- ::lib.schema.metadata/type]\n  (lib.metadata.protocols/invoked-ids metadata-providerable metadata-type))\n"]}