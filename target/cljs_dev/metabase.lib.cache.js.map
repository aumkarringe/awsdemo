{"version":3,"sources":["metabase/lib/cache.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,AAAA;;;;;yCAAA,iDAAAA,1FAAOE;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC;;;KAAA;AAAA,OAAAA,qEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,qEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,uEAAA,vEAAOD;AAAP,AAI2B,oDAAA,7CAACE;;;AAJ5B,CAAA,uEAAA,vEAAOF,kFAKHG,MAAMC,OAAOC;AALjB,AAK2B,mDAAA,AAAAC,5CAACC,4DAAKJ,OAAMC;;;AALvC,CAAA,uEAAA,vEAAOJ,kFAMHG,MAAMC,OAAOC,GAAGG;AANpB,AAM2B,OAACC,mDAAMN,MAAMO,gBAAMN,OAAOI;;;AANrD,CAAA,iEAAA,jEAAOR;;AAAP,AASG,AAAA;;;;;;;;0CAAA,kDAAAF,5FAAOc;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC;;;KAAA;AAAA,OAAAA,sEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,sEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAX,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,wEAAA,xEAAOW;AAAP,AAAA;;;AAAA,CAAA,wEAAA,xEAAOA,mFAQCT,MAAMC,OAAOS;AARrB,AAQ8B,IAAAC,qBAAuB,AAACE,+CAAYb,MAAMC;AAA1C,AAAA,oBAAAU;AAAA,AAAA,kBAAAA,dAAWC;AAAX,AACE,OAAMA,gBAAYF;;AADpB;;;;AAR9B,CAAA,wEAAA,xEAAOD,mFAUCT,MAAMC,OAAOS,EAAEL;AAVvB,AAU8B,IAAMO,cAAY,mFAAA,nFAACE,sEAAmCd,MAAMC;AAA1C,AAAkD,YAAAc;;AAApE,AACE,OAAMH,gBAAYF,EAAEL;;;AAXpD,CAAA,kEAAA,lEAAOI;;AAAP,AAaH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8CAAA,sEAAAO,pHAAOG,oGAiCJlB,OAAOmB,KAAKV,EAAEW;AAjCjB,AAAA,IAAAJ,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;eAAA,AAAAb,4CAAAa,eAAA,tEAiC2BK,gIACOzB;mBAlClC,AAAAO,4CAAAa,eAAA,1EAiCoCM;AAjCpC,AAmCE;AAES,oBAAI,iBAAAC,mBAAID;AAAJ,AAAA,oBAAAC;AAAAA;;AAAA,SAAW,AAACC,wBAAQL,WAAM,AAACM,qBAAKN;;;AAClC,AACE,oBAAU,AAAiBA;AAA3B;AAAA,AACE,CAAM,AAAiBA,iBAAM,CAACE,yCAAAA,2CAAAA;;;AAChC,IAAAK,qBAAe,AAAiBP;AAAhC,AAAA,oBAAAO;AAAA,YAAAA,RAAS3B;AAAT,AACE,IAAA2B,yBAAgB,CAACL,yCAAAA,yDAAAA,lBAAStB,qCAAAA,/BAAMC,qCAAAA,9BAAOS,qCAAAA;AAAvC,AAAA,oBAAAiB;AAAA,aAAAA,TAASC;AAAT,AACEA;;AAEA,IAAMvB,QAAM,CAACgB,kCAAAA,qCAAAA,LAAEX,iBAAAA;AAAf,AACE,CAACY,yCAAAA,+DAAAA,xBAAStB,2CAAAA,rCAAMC,2CAAAA,pCAAOS,2CAAAA,zCAAEL,2CAAAA;;AACzBA;;;AACJ,QAACgB,kCAAAA,qCAAAA,LAAEX,iBAAAA;;;AACP,QAACW,kCAAAA,qCAAAA,LAAEX,iBAAAA;;;AAEhB,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;wCAAA,gDAAAf,xFAAMmC;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAhC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sEAAA,tEAAMgC,iFAwBF7B,OAAOS,EAAEW;AAxBb,AAyBG,sFAAA,/EAACU,oEAAmB9B,OAAOS,EAAEW;;;AAzBhC,CAAA,sEAAA,tEAAMS,iFA0BF7B,OAAOS,EAAEW,EAAEE;AA1Bf,AA2BG,gEAAA,2CAAA,iGAAA,rMAACJ,4CAAoBlB,OAAOS,EAAEA,EAAEW,uGACAxB,gGACA0B;;;AA7BnC,CAAA,sEAAA,tEAAMO,iFA8BF7B,OAAOmB,KAAKV,EAAEW,EAAEW;AA9BpB,AA+BG,OAACb,4CAAoBlB,OAAOmB,KAAKV,EAAEW,EACd,uGAAA,2CAAA,lJAACY,4MAAiBpC,+CAAqBmC;;;AAhC/D,CAAA,gEAAA,hEAAMF;;AAAN,AAmCG;;;;;kDAAA,lDAAMI,4GAIHjC,OAAOmB,KAAKV,EAAEW,EAAEW;AAJnB,AAKE,OAACb,4CAAoBlB,OAAOmB,KAAKV,EAAEW,EAAE,uGAAA,2CAAA,lJAACY,4MAAiBxB,gDAAsBuB","names":["var_args","G__76165","metabase.lib.cache/atomic-map-cache-fn","js/Error","cljs.core.atom","cache","subkey","_x","cljs.core/deref","cljs.core.get","value","cljs.core.swap_BANG_","cljs.core/assoc","G__76180","metabase.lib.cache/js-weak-map-cache-fn","x","temp__5804__auto__","inner-cache","metabase.lib.cache.goog$module$goog$object.get","metabase.lib.cache.goog$module$goog$object.setWithReturnValueIfNotSet","js/WeakMap","p__76221","map__76222","cljs.core/--destructure-map","metabase.lib.cache/side-channel-cache*","host","f","cache-fn","force?","or__5002__auto__","cljs.core/object?","cljs.core/map?","temp__5802__auto__","cached","G__76225","metabase.lib.cache/side-channel-cache","metabase.lib.cache.side_channel_cache","opts","cljs.core.merge","metabase.lib.cache/side-channel-cache-weak-refs"],"sourcesContent":["(ns metabase.lib.cache\n  #?@(:cljs ((:require [goog.object :as gobject]))))\n\n(defn- atomic-map-cache-fn\n  \"Caching wrapper for use in [[side-channel-cache]].\n\n  Uses an `(atom {})` as the cache and any CLJS value as the `subkey`.\"\n  ([]                      (atom {}))\n  ([cache subkey _x]       (get @cache subkey))\n  ([cache subkey _x value] (swap! cache assoc subkey value)))\n\n#?(:cljs\n   (defn- js-weak-map-cache-fn\n     \"Caching wrapper for use in [[side-channel-cache*]].\n\n     Uses a two-layer cache: the outer layer is a vanilla JS object with string `subkey`s as its keys. The values are\n     `WeakMap`s, using the input value `x` as the key and holding the cached result.\n\n     For example, this works for caching by `:database-id` and then by legacy query object.\"\n     ([]                         #js {})\n     ([^js cache subkey x]       (when-let [inner-cache (gobject/get cache subkey)]\n                                   (.get inner-cache x)))\n     ([^js cache subkey x value] (let [inner-cache (gobject/setWithReturnValueIfNotSet cache subkey #(js/WeakMap.))]\n                                   (.set inner-cache x value)))))\n\n(defn- side-channel-cache*\n  \"(CLJS only; this is a pass-through in CLJ.)\n\n  Attaches a JS property `__mbcache` to `host` (a JS object or CLJS map) if it doesn't already have one.\n\n  This cache forms a \\\"personal\\\" cache attached to `host`. `subkey` is used as the key into that cache, and on a cache\n  miss the value is computed with `(f x)`.\n\n  If the `host` is a CLJS value like a map, the cache is ignored by CLJS since it's a raw JS property. Any change to\n  the CLJS map will return a new object, effectively invalidating the cache.\n\n  If the `host` is a JS object, it cannot have had `Object.freeze()` called on it before the first call to\n  [[side-channel-cache*]]. The `host` JS object must also be treated as immutable, since if it is modified the cache will\n  contain outdated values. You have been warned.\n\n  The caches are passed both `subkey` and the input value `x` to use as keys. Which of these are actually used as keys\n  is up to the `cache-fn`.\n\n  If there is no existing value in the cache for `subkey` and `x`, `(f x)` is called the result is cached for `subkey`\n  and `x`.\n\n  Options:\n  - The optional `:cache-fn` option defines how the cache is implemented.\n    It should be a function with 0-arity, 3-arity, and 4-arity forms, and works like this:\n    - `(cache-fn)` returns a new, empty cache.\n    - `(cache-fn cache subkey x)` looks up `subkey` and `x` (the input value) in the cache.\n      Returns the value, or `nil`.\n    - `(cache-fn cache subkey x value)` caches `value` as the value for `subkey` and `x`.\n      Returns nothing - the cache is mutable.\n\n    By default, the cache is an `(atom {})` with `get` and `(swap! ... assoc ...)`; see [[atomic-map-cache-fn]].\n  - `:force? true` causes the caching to be used even if the `host` does not meet the usual safety check of\n    being a vanilla JS object or a CLJS map. (Eg. if the `host` is an instance of a JS class.)\"\n  [subkey host x f {:keys [cache-fn force?]\n                    :or {cache-fn atomic-map-cache-fn}}]\n  (comment subkey, force?, cache-fn, host) ; Avoids lint warning for half-unused inputs.\n  #?(:clj  (f x)\n     :cljs (if (or force? (object? host) (map? host))\n             (do\n               (when-not (.-__mbcache ^js host)\n                 (set! (.-__mbcache ^js host) (cache-fn)))\n               (if-let [cache (.-__mbcache ^js host)]\n                 (if-let [cached (cache-fn cache subkey x)]\n                   cached\n                   ;; Cache miss - generate the value and cache it.\n                   (let [value (f x)]\n                     (cache-fn cache subkey x value)\n                     value))\n                 (f x)))\n             (f x))))\n\n(defn side-channel-cache\n  \"(CLJS only; this is a pass-through in CLJ.)\n\n  Attaches a JS property `__mbcache` to `host` (a JS object or CLJS map) if it doesn't already have one.\n\n  This cache forms a \\\"personal\\\" cache attached to `host`. `subkey` is used as the key into that cache, and on a cache\n  miss the value is computed with `(f x)`.\n\n  The 3-arity uses `x` and both the cache host and the value passed to `f`. The 5-arity has separate `host` and `x`.\n\n  If the `host` is a CLJS value like a map, the cache is ignored by CLJS since it's a raw JS property. Any change to\n  the CLJS map will return a new object, effectively invalidating the cache.\n\n  If the `host` is a JS object, it cannot have had `Object.freeze()` called on it before the first call to\n  [[side-channel-cache*]]. The `host` JS object must also be treated as immutable, since if it is modified the cache will\n  contain outdated values. You have been warned.\n\n  If there is no existing value at `subkey` in the cache, this will call `(f x)` and cache the result at `subkey`.\n\n  The cache is an `(atom {})` and any CLJS value can be used as the `subkey`; typically strings are used.\n\n  Options:\n  - `:force? true` causes the caching to be used even if the `host` does not meet the usual safety check of\n    being a vanilla JS object or a CLJS map. (Eg. if the `host` is an instance of a JS class.)\"\n  ([subkey x f]\n   (side-channel-cache subkey x f false))\n  ([subkey x f force?]\n   (side-channel-cache* subkey x x f\n                        {:cache-fn atomic-map-cache-fn\n                         :force?   force?}))\n  ([subkey host x f opts]\n   (side-channel-cache* subkey host x f\n                        (merge {:cache-fn atomic-map-cache-fn} opts))))\n\n#?(:cljs\n   (defn side-channel-cache-weak-refs\n     \"See [[side-channel-cache]] for the overview.\n\n     This version uses a JS `WeakMap` as the cache and JS objects as the `subkey`s.\"\n     [subkey host x f opts]\n     (side-channel-cache* subkey host x f (merge {:cache-fn js-weak-map-cache-fn} opts))))\n"]}