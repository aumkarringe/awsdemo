{"version":3,"sources":["metabase/lib/util.cljc"],"mappings":"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","names":["metabase.lib.util/format","goog.string/format","metabase.lib.util/clause?","clause","and__5000__auto__","cljs.core/vector?","cljs.core/Keyword","cljs.core/first","opts","cljs.core.get","cljs.core/map?","cljs.core/contains?","metabase.lib.util/clause-of-type?","clause-type","cljs.core._EQ_","metabase.lib.util/field-clause?","metabase.lib.util/ref-clause?","metabase.lib.hierarchy/isa?","metabase.lib.util/original-isa?","expression","typ","cljs.core.isa_QMARK_","or__5002__auto__","cljs.core/second","metabase.lib.schema.expression/type-of","metabase.lib.util/expression-name","metabase.lib.options/options","metabase.lib.util/top-level-expression-clause","a-name","cljs.core/random-uuid","metabase.lib.options/update-options","cljs.core.assoc","cljs.core.dissoc","js/metabase","js/metabase.lib","js/metabase.lib.util","js/metabase.lib.util.custom-name-method","method-table__5599__auto__","cljs.core.atom","prefer-table__5600__auto__","method-cache__5601__auto__","cached-hierarchy__5602__auto__","hierarchy__5603__auto__","fexpr__76456","cljs.core/MultiFn","cljs.core.symbol","metabase.lib.util/custom-name-method","metabase.lib.dispatch/dispatch-value","metabase.lib.hierarchy/hierarchy","metabase.lib.util/custom-name","x","cljs.core.some_fn","js/Error","metabase.lib.util/replace-clause","stage","location","target-clause","new-clause","p1__76463#","medley.core/update-existing-in","clause-or-clauses","iter__5480__auto__","s__76468","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","cljs.core/count","b__76470","cljs.core/chunk-buffer","i__76469","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__76467","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","metabase.lib.options/uuid","cljs.core/vec","metabase.lib.util/remove-clause","stage-number","temp__5802__auto__","target","cljs.core.get_in","vec__76484","cljs.core.nth","target-uuid","first-loc","last-loc","cljs.core/last","result","cljs.core.into","cljs.core.remove","cljs.core.comp","p1__76481#","cljs.core/every?","cljs.core/assoc-in","cljs.core.ex_info","metabase.shared.util.i18n/js-i18n","cljs.core/pop","cljs.core.update_in","cljs.core/dissoc","medley.core.dissoc_in","metabase.lib.util/native-query->pipeline","query","cljs.core.merge","clojure.set/rename-keys","metabase.lib.util/update-legacy-boolean-expression->list","m","legacy-key","pMBQL-key","G__76495","p1__76493#","cljs.core.update","cljs.core.drop","metabase.lib.util/join->pipeline","join","source","cljs.core/select-keys","stages","metabase.lib.util/inner-query->stages","metabase.lib.options/ensure-uuid","metabase.lib.util/joins->pipeline","joins","cljs.core.mapv","metabase.lib.util/->stage-metadata","source-metadata","cljs.core/seqable?","columns","column","cljs.core/update-keys","metabase.util/->kebab-case-en","p__76496","map__76497","cljs.core/--destructure-map","source-query","inner-query","previous-stages","previous-stage","G__76498","stage-type","this-stage","G__76499","cljs.core.conj","metabase.lib.util/mbql-query->pipeline","metabase.lib.util/LegacyOrPMBQLQuery","metabase.lib.util/pipeline","G__76500","p__76501","map__76502","metabase.lib.util/canonical-stage-index","_query","stage-number'","metabase.shared.util.i18n.js_i18n","metabase.lib.util/previous-stage-number","metabase.lib.util/first-stage?","cljs.core/not","p__76503","map__76504","metabase.lib.util/next-stage-number","metabase.lib.util/query-stage","map__76505","metabase.lib.util/previous-stage","stage-num","metabase.lib.util/update-query-stage","f","args","map__76506","stages'","cljs.core.apply","cljs.core/update","metabase.lib.util/ensure-mbql-final-stage","G__76507","cljs.core/conj","metabase.lib.util/join-strings-with-conjunction","conjunction","coll","clojure.string/trim","clojure.string.join","cljs.core/butlast","metabase.lib.util/truncate-alias-max-length-bytes","metabase.lib.util/truncated-alias-hash-suffix-length","metabase.lib.util/crc32-checksum","s","js/shadow.js.shim.module$crc_32.str","metabase.lib.util/truncate-alias","max-bytes","metabase.util/string-byte-count","checksum","truncated","metabase.util/truncate-string-to-byte-count","metabase.lib.util/legacy-string-table-id->card-id","table-id","vec__76515","_match","card-id-str","cljs.core/re-find","cljs.core/parse-long","metabase.lib.util/source-table-id","metabase.lib.util/source-card-id","metabase.lib.util/first-stage-type","metabase.lib.util/first-stage-is-native?","metabase.lib.util/escape-and-truncate","database","metabase.lib.database.methods/escape-alias","metabase.lib.util.truncate_alias","metabase.lib.util/unique-alias","original","suffix","metabase.lib.util/unique-name-generator","metadata-provider","G__76537","metabase.lib.metadata.protocols/database","uniqify","metabase.legacy_mbql.util.unique_name_generator","metabase.util/lower-case-en","cljs.core.partial","id","existing-names","seq__76542","chunk__76543","count__76544","i__76545","c__5525__auto__","cljs.core/chunk-first","cljs.core/next","existing","metabase.lib.util/strip-id-regex","js/RegExp","metabase.lib.util/strip-id","display-name","clojure.string/replace","metabase.lib.util/add-summary-clause","a-summary-clause","new-summary?","new-query","metabase.lib.util.update_query_stage","summary-clauses","metabase.lib.common/->op-arg","medley.core.update_existing","p1__76562#","p1__76563#","cljs.core/subvec","var_args","G__76582","metabase.lib.util/fresh-uuids","metabase.lib.util.fresh_uuids","cljs.core/constantly","register-fn","cljs.core/sequential?","cljs.core/empty","p1__76576#","cljs.core.map","p__76591","vec__76592","k","v","new-id","metabase.lib.util/replace-uuid-references","replacement-map","replacement","cljs.core/find","cljs.core/val","p1__76596#","p__76601","vec__76604","G__76607","cljs.core.not_EQ_","metabase.lib.util/fresh-query-instance","v-replacement","cljs.core/volatile!","cljs.core/transient","almost-query","p1__76609#","p2__76610#","cljs.core.assoc_BANG_","cljs.core/deref","cljs.core/persistent!","metabase.lib.util/normalized-query-type","query-type","cljs.core.keyword","p1__76614#","cljs.core/some","fexpr__76619","metabase.lib.util/referenced-field-ids","cljs.core/not-empty","cljs.core/cat","cljs.core.filter","cljs.core/some?","&parents","&match","&match_0__76628","cljs.core/keyword-identical?","&match_2__76630","cljs.core.match/backtrack","e76637","e__46214__auto__","e76636","e76631","metabase.lib.util.match.impl/match-in-collection","match-76623","cljs.core/int?","metabase.lib.util/collect-source-tables","from-joins","cljs.core.mapcat","cljs.core.concat","G__76638"],"sourcesContent":["(ns metabase.lib.util\n  (:refer-clojure :exclude [format])\n  (:require\n   #?@(:clj\n       ([potemkin :as p]))\n   #?@(:cljs\n       ([\"crc-32\" :as CRC32]\n        [goog.string :as gstring]\n        [goog.string.format :as gstring.format]))\n   [clojure.set :as set]\n   [clojure.string :as str]\n   [medley.core :as m]\n   [metabase.legacy-mbql.util :as mbql.u]\n   [metabase.lib.common :as lib.common]\n   [metabase.lib.database.methods :as lib.database.methods]\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.metadata.protocols :as lib.metadata.protocols]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.expression :as lib.schema.expression]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.lib.schema.ref :as lib.schema.ref]\n   [metabase.lib.util.match :as lib.util.match]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.malli :as mu]))\n\n#?(:clj\n   (set! *warn-on-reflection* true))\n\n;; The formatting functionality is only loaded if you depend on goog.string.format.\n#?(:cljs (comment gstring.format/keep-me))\n\n;;; For convenience: [[metabase.lib.util/format]] maps to [[clojure.core/format]] in Clj and [[goog.string/format]] in\n;;; Cljs. They both work like [[clojure.core/format]], but since that doesn't exist in Cljs, you can use this instead.\n#?(:clj\n   (p/import-vars [clojure.core format])\n\n   :cljs\n   (def format \"Exactly like [[clojure.core/format]] but ClojureScript-friendly.\" gstring/format))\n\n(defn clause?\n  \"Returns true if this is a clause.\"\n  [clause]\n  (and (vector? clause)\n       (keyword? (first clause))\n       (let [opts (get clause 1)]\n         (and (map? opts)\n              (contains? opts :lib/uuid)))))\n\n(defn clause-of-type?\n  \"Returns true if this is a clause.\"\n  [clause clause-type]\n  (and (clause? clause)\n       (= (first clause) clause-type)))\n\n(defn field-clause?\n  \"Returns true if this is a field clause.\"\n  [clause]\n  (clause-of-type? clause :field))\n\n(defn ref-clause?\n  \"Returns true if this is any sort of reference clause\"\n  [clause]\n  (and (clause? clause)\n       (lib.hierarchy/isa? (first clause) ::lib.schema.ref/ref)))\n\n(defn original-isa?\n  \"Returns whether the type of `expression` isa? `typ`.\n   If the expression has an original-effective-type due to bucketing, check that.\"\n  [expression typ]\n  (isa?\n    (or (and (clause? expression)\n             (:metabase.lib.field/original-effective-type (second expression)))\n        (lib.schema.expression/type-of expression))\n    typ))\n\n(defn expression-name\n  \"Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause.\"\n  [clause]\n  (when (clause? clause)\n    (:lib/expression-name (lib.options/options clause))))\n\n(defn top-level-expression-clause\n  \"Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value.\"\n  [clause a-name]\n  (-> (if (clause? clause)\n        clause\n        [:value {:lib/uuid (str (random-uuid))\n                 :effective-type (lib.schema.expression/type-of clause)}\n         clause])\n      (lib.options/update-options (fn [opts]\n                                    (-> opts\n                                        (assoc :lib/expression-name a-name)\n                                        (dissoc :name :display-name))))))\n\n(defmulti custom-name-method\n  \"Implementation for [[custom-name]].\"\n  {:arglists '([x])}\n  lib.dispatch/dispatch-value\n  :hierarchy lib.hierarchy/hierarchy)\n\n(defn custom-name\n  \"Return the user supplied name of `x`, if any.\"\n  [x]\n  (custom-name-method x))\n\n(defmethod custom-name-method :default\n  [x]\n  ;; We assume that clauses only get a :display-name option if the user explicitly specifies it.\n  ;; Expressions from the :expressions clause of pMBQL queries have custom names by default.\n  (when (clause? x)\n    ((some-fn :display-name :lib/expression-name) (lib.options/options x))))\n\n(defn replace-clause\n  \"Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens.\"\n  [stage location target-clause new-clause]\n  {:pre [((some-fn clause? #(= (:lib/type %) :mbql/join)) target-clause)]}\n  (let [new-clause (if (= :expressions (first location))\n                     (top-level-expression-clause new-clause (or (custom-name new-clause)\n                                                                 (expression-name target-clause)))\n                     new-clause)]\n    (m/update-existing-in\n     stage\n     location\n     (fn [clause-or-clauses]\n       (->> (for [clause clause-or-clauses]\n              (if (= (lib.options/uuid clause) (lib.options/uuid target-clause))\n                new-clause\n                clause))\n            vec)))))\n\n(defn remove-clause\n  \"Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage.\"\n  [stage location target-clause stage-number]\n  {:pre [(clause? target-clause)]}\n  (if-let [target (get-in stage location)]\n    (let [target-uuid (lib.options/uuid target-clause)\n          [first-loc last-loc] [(first location) (last location)]\n          result (into [] (remove (comp #{target-uuid} lib.options/uuid)) target)\n          result (when-not (and (= location [:fields])\n                                (every? #(clause-of-type? % :expression) result))\n                   result)]\n      (cond\n        (seq result)\n        (assoc-in stage location result)\n\n        (= [:joins :conditions] [first-loc last-loc])\n        (throw (ex-info (i18n/tru \"Cannot remove the final join condition\")\n                        {:error ::cannot-remove-final-join-condition\n                         :conditions (get-in stage location)\n                         :join (get-in stage (pop location))\n                         :stage-number stage-number\n                         :stage stage}))\n\n        (= [:joins :fields] [first-loc last-loc])\n        (update-in stage (pop location) dissoc last-loc)\n\n        :else\n        (m/dissoc-in stage location)))\n    stage))\n\n;;; TODO -- all of this `->pipeline` stuff should probably be merged into [[metabase.lib.convert]] at some point in\n;;; the near future.\n\n(defn- native-query->pipeline\n  \"Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n          ;; readability in the REPL.\n          :stages   [(merge {:lib/type :mbql.stage/native}\n                            (set/rename-keys (:native query) {:query :native}))]}\n         (dissoc query :type :native)))\n\n(declare inner-query->stages)\n\n(defn- update-legacy-boolean-expression->list\n  \"Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`\"\n  [m legacy-key pMBQL-key]\n  (cond-> m\n    (contains? m legacy-key) (update legacy-key #(if (and (vector? %)\n                                                       (= (first %) :and))\n                                                   (vec (drop 1 %))\n                                                   [%]))\n    (contains? m legacy-key) (set/rename-keys {legacy-key pMBQL-key})))\n\n(defn- join->pipeline [join]\n  (let [source (select-keys join [:source-table :source-query])\n        stages (inner-query->stages source)]\n    (-> join\n        (dissoc :source-table :source-query)\n        (update-legacy-boolean-expression->list :condition :conditions)\n        (assoc :lib/type :mbql/join\n               :stages stages)\n        lib.options/ensure-uuid)))\n\n(defn- joins->pipeline [joins]\n  (mapv join->pipeline joins))\n\n(defn ->stage-metadata\n  \"Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]].\"\n  [source-metadata]\n  (when source-metadata\n    (-> (if (seqable? source-metadata)\n          {:columns source-metadata}\n          source-metadata)\n        (update :columns (fn [columns]\n                           (mapv (fn [column]\n                                   (-> column\n                                       (update-keys u/->kebab-case-en)\n                                       (assoc :lib/type :metadata/column)))\n                                 columns)))\n        (assoc :lib/type :metadata/results))))\n\n(defn- inner-query->stages [{:keys [source-query source-metadata], :as inner-query}]\n  (let [previous-stages (if source-query\n                          (inner-query->stages source-query)\n                          [])\n        source-metadata (->stage-metadata source-metadata)\n        previous-stage  (dec (count previous-stages))\n        previous-stages (cond-> previous-stages\n                          (and source-metadata\n                               (not (neg? previous-stage))) (assoc-in [previous-stage :lib/stage-metadata] source-metadata))\n        stage-type      (if (:native inner-query)\n                          :mbql.stage/native\n                          :mbql.stage/mbql)\n        ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n        ;; readability in the REPL.\n        this-stage      (merge {:lib/type stage-type}\n                               (dissoc inner-query :source-query :source-metadata))\n        this-stage      (cond-> this-stage\n                          (seq (:joins this-stage)) (update :joins joins->pipeline)\n                          :always (update-legacy-boolean-expression->list :filter :filters))]\n    (conj previous-stages this-stage)))\n\n(defn- mbql-query->pipeline\n  \"Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          :stages   (inner-query->stages (:query query))}\n         (dissoc query :type :query)))\n\n(def LegacyOrPMBQLQuery\n  \"Schema for a map that is either a legacy query OR a pMBQL query.\"\n  [:or\n   [:map\n    {:error/message \"legacy query\"}\n    [:type [:enum :native :query]]]\n   [:map\n    {:error/message \"pMBQL query\"}\n    [:lib/type [:= :mbql/query]]]])\n\n(mu/defn pipeline\n  \"Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)\"\n  [query :- LegacyOrPMBQLQuery]\n  (if (= (:lib/type query) :mbql/query)\n    query\n    (case (:type query)\n      :native (native-query->pipeline query)\n      :query  (mbql-query->pipeline query))))\n\n(mu/defn canonical-stage-index :- [:int {:min 0}]\n  \"If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc.\"\n  [{:keys [stages], :as _query} :- :map\n   stage-number                 :- :int]\n  (let [stage-number' (if (neg? stage-number)\n                        (+ (count stages) stage-number)\n                        stage-number)]\n    (when (or (>= stage-number' (count stages))\n              (neg? stage-number'))\n      (throw (ex-info (i18n/tru \"Stage {0} does not exist\" stage-number)\n                      {:num-stages (count stages)})))\n    stage-number'))\n\n(mu/defn previous-stage-number :- [:maybe [:int {:min 0}]]\n  \"The index of the previous stage, if there is one. `nil` if there is no previous stage.\"\n  [query        :- :map\n   stage-number :- :int]\n  (let [stage-number (canonical-stage-index query stage-number)]\n    (when (pos? stage-number)\n      (dec stage-number))))\n\n(defn first-stage?\n  \"Whether a `stage-number` is referring to the first stage of a query or not.\"\n  [query stage-number]\n  (not (previous-stage-number query stage-number)))\n\n(mu/defn next-stage-number :- [:maybe :int]\n  \"The index of the next stage, if there is one. `nil` if there is no next stage.\"\n  [{:keys [stages], :as _query} :- :map\n   stage-number                 :- :int]\n  (let [stage-number (if (neg? stage-number)\n                       (+ (count stages) stage-number)\n                       stage-number)]\n    (when (< (inc stage-number) (count stages))\n      (inc stage-number))))\n\n(mu/defn query-stage :- [:maybe ::lib.schema/stage]\n  \"Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int]\n  (let [{:keys [stages], :as query} (pipeline query)]\n    (get (vec stages) (canonical-stage-index query stage-number))))\n\n(mu/defn previous-stage :- [:maybe ::lib.schema/stage]\n  \"Return the previous stage of the query, if there is one; otherwise return `nil`.\"\n  [query stage-number :- :int]\n  (when-let [stage-num (previous-stage-number query stage-number)]\n    (query-stage query stage-num)))\n\n(mu/defn update-query-stage :- ::lib.schema/query\n  \"Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int\n   f & args]\n  (let [{:keys [stages], :as query} (pipeline query)\n        stage-number'               (canonical-stage-index query stage-number)\n        stages'                     (apply update (vec stages) stage-number' f args)]\n    (assoc query :stages stages')))\n\n(mu/defn ensure-mbql-final-stage :- ::lib.schema/query\n  \"Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one.\"\n  [query]\n  (let [query (pipeline query)]\n    (cond-> query\n      (= (:lib/type (query-stage query -1)) :mbql.stage/native)\n      (update :stages conj {:lib/type :mbql.stage/mbql}))))\n\n(defn join-strings-with-conjunction\n  \"This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \\\"and\\\" [\\\"X\\\" \\\"Y\\\" \\\"Z\\\"])\n  ;; => \\\"X, Y, and Z\\\"\"\n  [conjunction coll]\n  (when (seq coll)\n    (if (= (count coll) 1)\n      (first coll)\n      (let [conjunction (str \\space (str/trim conjunction) \\space)]\n        (if (= (count coll) 2)\n          ;; exactly 2 args: X and Y\n          (str (first coll) conjunction (second coll))\n          ;; > 2 args: X, Y, and Z\n          (str\n           (str/join \", \" (butlast coll))\n           \",\"\n           conjunction\n           (last coll)))))))\n\n(def ^:private truncate-alias-max-length-bytes\n  \"Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n  reasoning.\"\n  60)\n\n(def ^:private truncated-alias-hash-suffix-length\n  \"Length of the hash suffixed to truncated strings by [[truncate-alias]].\"\n  ;; 8 bytes for the CRC32 plus one for the underscore\n  9)\n\n(mu/defn ^:private crc32-checksum :- [:string {:min 8, :max 8}]\n  \"Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string.\"\n  [s :- :string]\n  (let [s #?(:clj (Long/toHexString (.getValue (doto (java.util.zip.CRC32.)\n                                                 (.update (.getBytes ^String s \"UTF-8\")))))\n             :cljs (-> (CRC32/str s 0)\n                       (unsigned-bit-shift-right 0) ; see https://github.com/SheetJS/js-crc32#signed-integers\n                       (.toString 16)))]\n    ;; pad to 8 characters if needed. Might come out as less than 8 if the first byte is `00` or `0x` or something.\n    (loop [s s]\n      (if (< (count s) 8)\n        (recur (str \\0 s))\n        s))))\n\n(mu/defn truncate-alias :- [:string {:min 1, :max 60}]\n  \"Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \\\"some_really_long_string\\\" 15) ;   -> \\\"some_r_8e0f9bc2\\\"\n    (truncate-alias \\\"some_really_long_string_2\\\" 15) ; -> \\\"some_r_2a3c73eb\\\"\"\n  ([s]\n   (truncate-alias s truncate-alias-max-length-bytes))\n\n  ([s         :- ::lib.schema.common/non-blank-string\n    max-bytes :- [:int {:min 0}]]\n   (if (<= (u/string-byte-count s) max-bytes)\n     s\n     (let [checksum  (crc32-checksum s)\n           truncated (u/truncate-string-to-byte-count s (- max-bytes truncated-alias-hash-suffix-length))]\n       (str truncated \\_ checksum)))))\n\n(mu/defn legacy-string-table-id->card-id :- [:maybe ::lib.schema.id/card]\n  \"If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`.\"\n  [table-id]\n  (when (string? table-id)\n    (when-let [[_match card-id-str] (re-find #\"^card__(\\d+)$\" table-id)]\n      (parse-long card-id-str))))\n\n(mu/defn source-table-id :- [:maybe ::lib.schema.id/table]\n  \"If this query has a `:source-table` ID, return it.\"\n  [query]\n  (-> query :stages first :source-table))\n\n(mu/defn source-card-id :- [:maybe ::lib.schema.id/card]\n  \"If this query has a `:source-card` ID, return it.\"\n  [query]\n  (-> query :stages first :source-card))\n\n(mu/defn first-stage-type :- [:maybe [:enum :mbql.stage/mbql :mbql.stage/native]]\n  \"Type of the first query stage.\"\n  [query :- :map]\n  (:lib/type (query-stage query 0)))\n\n(mu/defn first-stage-is-native? :- :boolean\n  \"Whether the first stage of the query is a native query stage.\"\n  [query :- :map]\n  (= (first-stage-type query) :mbql.stage/native))\n\n(mu/defn ^:private escape-and-truncate :- :string\n  [database :- [:maybe ::lib.schema.metadata/database]\n   s        :- :string]\n  (->> s\n       (lib.database.methods/escape-alias database)\n       ;; truncate alias to 60 characters (actually 51 characters plus a hash).\n       truncate-alias))\n\n(mu/defn ^:private unique-alias :- :string\n  [database :- [:maybe ::lib.schema.metadata/database]\n   original :- :string\n   suffix   :- :string]\n  (->> (str original \\_ suffix)\n       (escape-and-truncate database)))\n\n(mu/defn unique-name-generator :- [:function\n                                   ;; (f str) => unique-str\n                                   [:=>\n                                    [:cat :string]\n                                    ::lib.schema.common/non-blank-string]\n                                   ;; (f id str) => unique-str\n                                   [:=>\n                                    [:cat :any :string]\n                                    ::lib.schema.common/non-blank-string]]\n  \"Create a new function with the signature\n\n    (f str) => str\n\n  or\n\n   (f id str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash).\n\n  Optionally takes a list of names which are already defined, \\\"priming\\\" the generator with eg. all the column names\n  that currently exist on a stage of the query.\n\n  The two-arity version of the returned function can be used for idempotence. See docstring\n  for [[metabase.legacy-mbql.util/unique-name-generator]] for more information.\"\n  ([metadata-provider :- [:maybe ::lib.schema.metadata/metadata-provider]]\n   (let [database     (some-> metadata-provider lib.metadata.protocols/database)\n         uniqify      (mbql.u/unique-name-generator\n                       ;; unique by lower-case name, e.g. `NAME` and `name` => `NAME` and `name_2`\n                       ;;\n                       ;; some databases treat aliases as case-insensitive so make sure the generated aliases are\n                       ;; unique regardless of case\n                       :name-key-fn     u/lower-case-en\n                       :unique-alias-fn (partial unique-alias database))]\n     ;; I know we could just use `comp` here but it gets really hard to figure out where it's coming from when you're\n     ;; debugging things; a named function like this makes it clear where this function came from\n     (fn unique-name-generator-fn\n       ([s]\n        (->> s\n             (escape-and-truncate database)\n             uniqify\n             truncate-alias))\n       ([id s]\n        (->> s\n             (escape-and-truncate database)\n             (uniqify id)\n             truncate-alias)))))\n\n  ([metadata-provider :- [:maybe ::lib.schema.metadata/metadata-provider]\n    existing-names    :- [:sequential :string]]\n   (let [f (unique-name-generator metadata-provider)]\n     (doseq [existing existing-names]\n       (f existing))\n     f)))\n\n(def ^:private strip-id-regex\n  #?(:cljs (js/RegExp. \" id$\" \"i\")\n     ;; `(?i)` is JVM-specific magic to turn on the `i` case-insensitive flag.\n     :clj  #\"(?i) id$\"))\n\n(mu/defn strip-id :- :string\n  \"Given a display name string like \\\"Product ID\\\", this will drop the trailing \\\"ID\\\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining.\"\n  [display-name :- :string]\n  (-> display-name\n      (str/replace strip-id-regex \"\")\n      str/trim))\n\n(mu/defn add-summary-clause :- ::lib.schema/query\n  \"If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages.\"\n  [query :- ::lib.schema/query\n   stage-number :- :int\n   location :- [:enum :breakout :aggregation]\n   a-summary-clause]\n  (let [query (pipeline query)\n        stage-number (or stage-number -1)\n        stage (query-stage query stage-number)\n        new-summary? (not (or (seq (:aggregation stage)) (seq (:breakout stage))))\n        new-query (update-query-stage\n                    query stage-number\n                    update location\n                    (fn [summary-clauses]\n                      (conj (vec summary-clauses) (lib.common/->op-arg a-summary-clause))))]\n    (if new-summary?\n      (-> new-query\n          (update-query-stage\n            stage-number\n            (fn [stage]\n              (-> stage\n                  (dissoc :order-by :fields)\n                  (m/update-existing :joins (fn [joins] (mapv #(dissoc % :fields) joins))))))\n          ;; subvec holds onto references, so create a new vector\n          (update :stages (comp #(into [] %) subvec) 0 (inc (canonical-stage-index query stage-number))))\n      new-query)))\n\n(defn fresh-uuids\n  \"Recursively replace all the :lib/uuids in `x` with fresh ones. Useful if you need to attach something to a query more\n  than once.\"\n  ([x]\n   (fresh-uuids x (constantly nil)))\n  ([x register-fn]\n   (cond\n     (sequential? x)\n     (into (empty x) (map #(fresh-uuids % register-fn)) x)\n\n     (map? x)\n     (into\n      (empty x)\n      (map (fn [[k v]]\n             [k (if (= k :lib/uuid)\n                  (let [new-id (str (random-uuid))]\n                    (register-fn v new-id)\n                    new-id)\n                  (fresh-uuids v register-fn))]))\n      x)\n\n     :else\n     x)))\n\n(defn- replace-uuid-references\n  [x replacement-map]\n  (let [replacement (find replacement-map x)]\n    (cond\n      replacement\n      (val replacement)\n\n      (sequential? x)\n      (into (empty x) (map #(replace-uuid-references % replacement-map)) x)\n\n      (map? x)\n      (into\n       (empty x)\n       (map (fn [[k v]]\n              [k (cond-> v\n                   (not= k :lib/uuid) (replace-uuid-references replacement-map))]))\n       x)\n\n      :else\n      x)))\n\n(defn fresh-query-instance\n  \"Create an copy of `query` with fresh :lib/uuid values making sure that internal\n  uuid references are kept.\"\n  [query]\n  (let [v-replacement (volatile! (transient {}))\n        almost-query (fresh-uuids query #(vswap! v-replacement assoc! %1 %2))\n        replacement (persistent! @v-replacement)]\n    (replace-uuid-references almost-query replacement)))\n\n(mu/defn normalized-query-type :- [:maybe [:enum #_MLv2 :mbql/query #_legacy :query :native #_audit :internal]]\n  \"Get the `:lib/type` or `:type` from `query`, even if it is not-yet normalized.\"\n  [query :- [:maybe :map]]\n  (when (map? query)\n    (when-let [query-type (keyword (some #(get query %)\n                                         [:lib/type :type \"lib/type\" \"type\"]))]\n      (when (#{:mbql/query :query :native :internal} query-type)\n        query-type))))\n\n(mu/defn referenced-field-ids :- [:maybe [:set ::lib.schema.id/field]]\n  \"Find all the integer field IDs in `coll`, Which can arbitrarily be anything that is part of MLv2 query schema.\"\n  [coll]\n  (not-empty\n   (into #{}\n         (comp cat (filter some?))\n         (lib.util.match/match coll [:field opts (id :guard int?)] [id (:source-field opts)]))))\n\n(defn collect-source-tables\n  \"Return sequence of source tables from `query`.\"\n  [query]\n  (let [from-joins (mapcat collect-source-tables (:joins query))]\n    (if-let [source-query (:source-query query)]\n      (concat (collect-source-tables source-query) from-joins)\n      (cond->> from-joins\n        (:source-table query) (cons (:source-table query))))))\n"]}