{"version":3,"sources":["metabase/lib/schema/expression/temporal.cljc"],"mappings":"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","names":["metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","metabase.lib.schema.expression/type-of-method","p__75143","vec__75144","cljs.core.nth","_tag","_opts","temporal","inner-type","metabase.lib.schema.expression/type-of","cljs.core/set?","temporal-set","clojure.set.intersection","cljs.core._EQ_","cljs.core/count","cljs.core/first","metabase.lib.hierarchy/derive","seq__75147","cljs.core/seq","chunk__75148","count__75149","i__75150","temp__5804__auto__","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/next","op","seq__75151","chunk__75152","count__75153","i__75154","seq__75155","chunk__75156","count__75157","i__75158","temporal-extract-op","metabase.util.malli.registry/register!","metabase.lib.schema.common/normalize-keyword","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","cljs.core.into","p__75159","map__75160","cljs.core/--destructure-map","cljs.core.get","value","_","cljs.core.pr_str","cljs.core.sort","js/shadow.js.shim.module$moment","base-type","p1__75161#","cljs.core/some","cljs.core.isa_QMARK_","metabase.lib.schema.mbql_clause.define_mbql_clause","p__75163","vec__75164","unit","or__5002__auto__","metabase.util.malli.registry/validate","cljs.core/re-matches","metabase.shared.util.internal.time-common/year-month-regex","metabase.shared.util.internal.time-common/year-regex","value-type","p1__75162#","cljs.core.filter","cljs.core.some_fn","cljs.core/keyword?","cljs.core/string?"],"sourcesContent":["(ns metabase.lib.schema.expression.temporal\n  (:require\n   [clojure.set :as set]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.literal :as literal]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.shared.util.internal.time-common :as shared.ut.common]\n   [metabase.util.malli.registry :as mr])\n  #?@\n  (:clj\n   [(:import\n     (java.time ZoneId))]\n   :cljs\n   [(:require\n     [\"moment\" :as moment]\n     [\"moment-timezone\" :as mtz])]))\n\n#?(:cljs\n   ;; so the moment-timezone stuff gets loaded\n   (comment mtz/keep-me))\n\n(mbql-clause/define-tuple-mbql-clause :interval :- :type/Interval\n  :int\n  ::temporal-bucketing/unit.date-time.interval)\n\n(defmethod expression/type-of-method :lib.type-of/type-is-temporal-type-of-first-arg [[_tag _opts temporal]]\n  ;; For datetime-add, datetime-subtract, etc. the first arg is a temporal value. However, some valid values are\n  ;; formatted strings for which type-of returns eg. #{:type/String :type/DateTime}. Since we're doing date arithmetic,\n  ;; we know for sure it's the temporal type.\n  (let [inner-type (expression/type-of temporal)]\n    (if (set? inner-type)\n      (let [temporal-set (set/intersection inner-type #{:type/Date :type/DateTime})]\n        (if (= (count temporal-set) 1)\n          (first temporal-set)\n          temporal-set))\n      inner-type)))\n\n;; For most purposes, `:lib.type-of/type-is-temporal-type-of-first-arg` is the same as\n;; `:lib.type-of/type-is-type-of-first-arg`. In particular, for the unambiguous `lib.metadata.calculation/type-of`, they\n;; are identical. They only differ when there's a set of possibilities in `lib.schema.expression/type-of`.\n(lib.hierarchy/derive :lib.type-of/type-is-temporal-type-of-first-arg :lib.type-of/type-is-type-of-first-arg)\n\n;;; TODO -- we should constrain this so that you can only use a Date unit if expr is a date, etc.\n(doseq [op [:datetime-add :datetime-subtract]]\n  (mbql-clause/define-tuple-mbql-clause op\n    #_expr   [:ref ::expression/temporal]\n    #_amount :int\n    #_unit   [:ref ::temporal-bucketing/unit.date-time.interval])\n  (lib.hierarchy/derive op :lib.type-of/type-is-temporal-type-of-first-arg))\n\n(doseq [op [:get-year :get-month :get-day :get-hour :get-minute :get-second :get-quarter]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Integer\n    [:schema [:ref ::expression/temporal]]))\n\n(mbql-clause/define-tuple-mbql-clause :datetime-diff :- :type/Integer\n  #_:datetime1 [:schema [:ref ::expression/temporal]]\n  #_:datetime2 [:schema [:ref ::expression/temporal]]\n  #_:unit [:ref ::temporal-bucketing/unit.date-time.truncate])\n\n(doseq [temporal-extract-op #{:get-second :get-minute :get-hour\n                              :get-day :get-day-of-week\n                              :get-month :get-quarter :get-year}]\n  (mbql-clause/define-tuple-mbql-clause temporal-extract-op :- :type/Integer\n    #_:datetime [:schema [:ref ::expression/temporal]]))\n\n(mr/def ::week-mode\n  [:enum {:decode/normalize common/normalize-keyword} :iso :us :instance])\n\n(mbql-clause/define-catn-mbql-clause :get-week :- :type/Integer\n  [:datetime [:schema [:ref ::expression/temporal]]]\n  ;; TODO : the mode should probably go in the options map in modern MBQL rather than have it be a separate positional\n  ;; argument. But we can't refactor everything in one go, so that will have to be a future refactor.\n  [:mode     [:? [:schema [:ref ::week-mode]]]])\n\n(mr/def ::timezone-id\n  [:and\n   ::common/non-blank-string\n   [:or\n    (into [:enum\n           {:error/message \"valid timezone ID\"\n            :error/fn      (fn [{:keys [value]} _]\n                             (str \"invalid timezone ID: \" (pr-str value)))}]\n          (sort\n           #?( ;; 600 timezones on java 17\n              :clj (ZoneId/getAvailableZoneIds)\n              ;; 596 timezones on moment-timezone 0.5.38\n              :cljs (.names (.-tz moment)))))\n    ::literal/string.zone-offset]])\n\n(mbql-clause/define-catn-mbql-clause :convert-timezone\n  [:datetime [:schema [:ref ::expression/temporal]]]\n  [:target   [:schema [:ref ::timezone-id]]]\n  [:source   [:? [:schema [:ref ::timezone-id]]]])\n\n(lib.hierarchy/derive :convert-timezone :lib.type-of/type-is-temporal-type-of-first-arg)\n\n(mbql-clause/define-tuple-mbql-clause :now :- :type/DateTimeWithTZ)\n\n;;; if `:absolute-datetime` has `:base-type` in options, it must either derive from `:type/Date` or `:type/DateTime`.\n;;; TODO -- we should do additional validation here and make sure the unit/value agree with base-type when it's\n;;; present.\n(mr/def ::absolute-datetime.base-type\n  [:and\n   [:ref ::common/base-type]\n   [:fn\n    {:error/message \":absolute-datetime base-type must derive from :type/Date or :type/DateTime\"}\n    (fn [base-type]\n      (some #(isa? base-type %)\n            [:type/Date\n             :type/DateTime]))]])\n\n(mr/def ::absolute-datetime.options\n  [:merge\n   [:ref ::common/options]\n   [:map\n    [:base-type {:optional true} [:ref ::absolute-datetime.base-type]]]])\n\n(mbql-clause/define-mbql-clause :absolute-datetime\n  [:cat\n   {:error/message \"valid :absolute-datetime clause\"}\n   [:= {:decode/normalize common/normalize-keyword} :absolute-datetime]\n   [:schema [:ref ::absolute-datetime.options]]\n   [:alt\n    [:cat\n     {:error/message \":absolute-datetime literal and unit for :type/Date\"}\n     [:schema [:or\n               [:ref ::literal/date]\n               ;; absolute datetime also allows `year-month` and `year` literals.\n               [:ref ::literal/string.year-month]\n               [:ref ::literal/string.year]]]\n     [:schema [:or\n               [:= {:decode/normalize common/normalize-keyword} :default]\n               [:ref ::temporal-bucketing/unit.date]]]]\n    [:cat\n     {:error/message \":absolute-datetime literal and unit for :type/DateTime\"}\n     [:schema [:or\n               [:= {:decode/normalize common/normalize-keyword} :current]\n               [:ref ::literal/datetime]]]\n     [:schema [:or\n               [:= {:decode/normalize common/normalize-keyword} :default]\n               [:ref ::temporal-bucketing/unit.date-time]]]]]])\n\n(defmethod expression/type-of-method :absolute-datetime\n  [[_tag _opts value unit]]\n  (or\n   ;; if value is `:current`, then infer the type based on the unit. Date unit = `:type/Date`. Anything else =\n   ;; `:type/DateTime`.\n   (when (= value :current)\n     (cond\n       (= unit :default)                                 :type/DateTime\n       (mr/validate ::temporal-bucketing/unit.date unit) :type/Date\n       :else                                             :type/DateTime))\n   ;; handle year-month and year string regexes, which are not allowed as date literals unless wrapped in\n   ;; `:absolute-datetime`.\n   (when (string? value)\n     (cond\n       (re-matches shared.ut.common/year-month-regex value) :type/Date\n       (re-matches shared.ut.common/year-regex value)       :type/Date))\n   ;; for things that return a union of types like string literals, only the temporal types make sense, so filter out\n   ;; everything else.\n   (let [value-type (expression/type-of value)\n         value-type (if (set? value-type)\n                      (into #{} (filter #(isa? % :type/Temporal)) value-type)\n                      value-type)]\n     (if (and (set? value-type)\n              (= (count value-type) 1))\n       (first value-type)\n       value-type))))\n\n(mr/def ::relative-datetime.amount\n  [:multi {:dispatch (some-fn keyword? string?)}\n   [true  [:= {:decode/normalize common/normalize-keyword} :current]]\n   [false :int]])\n\n(mbql-clause/define-catn-mbql-clause :relative-datetime :- :type/DateTime\n  [:n    [:schema [:ref ::relative-datetime.amount]]]\n  [:unit [:? [:schema [:ref ::temporal-bucketing/unit.date-time.interval]]]])\n\n(mbql-clause/define-tuple-mbql-clause :time :- :type/Time\n  #_:timestr [:schema [:ref ::expression/string]]\n  #_:unit [:ref ::temporal-bucketing/unit.time.interval])\n\n;;; this has some stuff that's missing from [[::temporal-bucketing/unit.date-time.extract]], like `:week-of-year-iso`\n(mr/def ::temporal-extract.unit\n  [:enum\n   {:decode/normalize common/normalize-keyword}\n   :year-of-era\n   :quarter-of-year\n   :month-of-year\n   :week-of-year-iso\n   :week-of-year-us\n   :week-of-year-instance\n   :day-of-month\n   :day-of-week\n   :hour-of-day\n   :minute-of-hour\n   :second-of-minute])\n\n;;; TODO -- this should make sure unit agrees with the type of expression we're extracting from.\n(mbql-clause/define-catn-mbql-clause :temporal-extract :- :type/Integer\n  [:datetime [:schema [:ref ::expression/temporal]]]\n  [:unit     [:schema [:ref ::temporal-extract.unit]]]\n  [:mode     [:? [:schema [:ref ::week-mode]]]])\n"]}