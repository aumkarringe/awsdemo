{"version":3,"sources":["metabase/lib/schema/util.cljc"],"mappings":"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","names":["metabase.lib.schema.util/collect-uuids-in-map","m","cljs.core.into","temp__5802__auto__","our-uuid","or__5002__auto__","metabase.lib.options/options","cljs.core.comp","cljs.core.remove","p__75852","vec__75853","cljs.core.nth","k","_v","cljs.core/qualified-keyword?","cljs.core.mapcat","p__75856","vec__75857","_k","v","metabase.lib.schema.util/collect-uuids","metabase.lib.schema.util/collect-uuids-in-sequence","xs","x","cljs.core/map?","cljs.core/sequential?","metabase.lib.schema.util/find-duplicate-uuid","cljs.core.transduce","cljs.core/identity","result","seen","a-uuid","cljs.core/contains?","cljs.core/reduced","cljs.core.conj","metabase.lib.schema.util/unique-uuids?","cljs.core/not","metabase.util.malli.registry/register!","p__75860","map__75861","cljs.core/--destructure-map","cljs.core.get","value","_","cljs.core.pr_str","metabase.lib.schema.util/remove-namespaced-keys","p__75862","vec__75863","metabase.lib.schema.util/distinct-refs?","refs","cljs.core/count","cljs.core.apply","cljs.core/distinct?","iter__5480__auto__","s__75867","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","b__75869","cljs.core/chunk-buffer","i__75868","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__75866","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","ref","metabase.lib.options/update-options","options","cljs.core.dissoc","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.lib.schema.util\n  (:refer-clojure :exclude [ref])\n  (:require\n   [metabase.lib.options :as lib.options]\n   [metabase.util.malli.registry :as mr]))\n\n(declare collect-uuids)\n\n(defn- collect-uuids-in-map [m]\n  (into (if-let [our-uuid (or (:lib/uuid (lib.options/options m))\n                              (:lib/uuid m))]\n          [our-uuid]\n          [])\n        (comp (remove (fn [[k _v]]\n                        (qualified-keyword? k)))\n              (mapcat (fn [[_k v]]\n                        (collect-uuids v))))\n        m))\n\n(defn- collect-uuids-in-sequence [xs]\n  (into [] (mapcat collect-uuids) xs))\n\n(defn collect-uuids\n  \"Return all the `:lib/uuid`s in a part of an MBQL query (a clause or map) as a sequence. This will be used to ensure\n  there are no duplicates.\"\n  [x]\n  (cond\n    (map? x)        (collect-uuids-in-map x)\n    (sequential? x) (collect-uuids-in-sequence x)\n    :else           nil))\n\n(defn- find-duplicate-uuid [x]\n  (transduce\n   identity\n   (fn\n     ([]\n      #{})\n     ([result]\n      (when (string? result)\n        result))\n     ([seen a-uuid]\n      (if (contains? seen a-uuid)\n        (reduced a-uuid)\n        (conj seen a-uuid))))\n   (collect-uuids x)))\n\n(defn unique-uuids?\n  \"True if all the `:lib/uuid`s in something are unique.\"\n  [x]\n  (not (find-duplicate-uuid x)))\n\n;;; Malli schema for to ensure that all `:lib/uuid`s are unique.\n(mr/def ::unique-uuids\n  [:fn\n   {:error/message \"all :lib/uuids must be unique\"\n    :error/fn      (fn [{:keys [value]} _]\n                     (str \"Duplicate :lib/uuid \" (pr-str (find-duplicate-uuid value))))}\n   #'unique-uuids?])\n\n(defn remove-namespaced-keys\n  \"Remove all the namespaced keys from a map.\"\n  [m]\n  (into {} (remove (fn [[k _v]] (qualified-keyword? k))) m))\n\n(defn distinct-refs?\n  \"Is a sequence of `refs` distinct for the purposes of appearing in `:fields` or `:breakouts` (ignoring keys that\n  aren't important such as namespaced keys and type info)?\"\n  [refs]\n  (or\n   (< (count refs) 2)\n   (apply\n    distinct?\n    (for [ref refs]\n      (lib.options/update-options ref (fn [options]\n                                        (-> options\n                                            remove-namespaced-keys\n                                            (dissoc :base-type :effective-type))))))))\n"]}