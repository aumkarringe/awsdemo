{"version":3,"sources":["metabase/lib/drill_thru/sort.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;;uDAAA,vDAAOA,sHAEJC,MAAMC,aAAaC;AAFtB,AAGE,OAACC,yEAAkCH,MACAC,aACAC,WACA,AAACE,sEAA+BJ,MAAMC;;AAE3E;;;;wDAAA,xDAAmBI,wHAChBL,MAAMC,aAAaK;AADtB,AAEE,OAACC,qDAAa,WAAAC;AAAA,AAAA,IAAAC,aAAAD;iBAAA,AAAAE,4CAAAD,WAAA,IAAA,xEAAME;YAAN,AAAAD,4CAAAD,WAAA,IAAA,nEAAiBG;WAAjB,AAAAF,4CAAAD,WAAA,IAAA,lEAAuBI;0BAAvBJ,tBAAiCK;AAAjC,AACE,wGAAA,jGAACX,yEAAkCH,MAAMC,aAAaY,wFAAMP;GAC9D,AAACS,8DAAuBf,MAAMC;;AAE9C;;;;2DAAA,3DAAmBe,8HAChBhB,MAAMC,aAAaK;AADtB,AAEE,IAAAW,qBAAmC,AAACZ,sDAAyBL,MAAMC,aAAaK;AAAhF,AAAA,oBAAAW;AAAA,AAAA,IAAAC,aAAAD;gBAAA,AAAAP,4CAAAQ,WAAA,IAAA,vEAAYC;YAAZ,AAAAT,4CAAAQ,WAAA,IAAA,nEAAsBN;YAAtB,AAAAF,4CAAAQ,WAAA,IAAA,nEAA4BE;AAA5B,AACED;;AADF;;;AAGF;;;;;;;0CAAA,qEAAAE,/GAASI,4FAENzB,MACAC;AAHH,AAAA,IAAAqB,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;eAAAA,XAIyCK;aAJzC,AAAAH,4CAAAF,eAAA,pEAIWhB;iBAJX,AAAAkB,4CAAAF,eAAA,xEAIkBpB;YAJlB,AAAAsB,4CAAAF,eAAA,nEAI6BI;AAJ7B,AAME,oBAAM,iBAAAE,oBAAK,AAACC,iDAAkC7B,MAAMC;AAA9C,AAAA,GAAA2B;AAAA,IAAAA,wBACKtB;AADL,AAAA,oBAAAsB;AAAA,SAEK,UAAA,TAAMF,oBACN,GAAK,AAACI,yCAA0BxB;;AAHrCsB;;;AAAAA;;;AAAN,AAKE,oBAAM,AAAC7B,qDAAkBC,MAAMC,aAAaC;AAA5C,AAIE,IAAM6B,qBAAmB,AAACf,yDAA4BhB,MAAMC,aAAaK;AAAzE,AAAA,kDAAA,0DAAA,6GAAA,qDAAA,uEAAA,gEAAA,PAGoBA,iFACA,iBAAA0B,WAAMD;IAANC,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,0FAAA;;;KAAA;AAAA,0FAAA;;;;AAAA,0FAAA,kDAAA;;;;;AARtB;;;AALF;;;AAkBF,AAAAE,6FAAA,uEAAA;;6BACIlC,MAAMC,aAAaoC;AADvB,AAEG,+GAAA,xGAACH,+EAAwClC,MAAMC,aAAaoC;;gDAF/DF,nBAIInC,MACAC,sBAEAkB;AAPJ,AAAA,IAAAiB,aAAAD;IAAAC,iBAAA,AAAAb,4BAAAa;aAAAA,TAMyBE;aANzB,AAAAd,4CAAAY,eAAA,pEAMY9B;AANZ,6IAQON,zEAEA,AAACuC,+EAAkCtC,nJACnC,OAACuC,0JAAsBvC,aAAaK,OAAO,AAACmC,gDAAQtB;;uCAX3DgB,nBAIInC,MACAC,sBAEAkB;;;gDAPJgB,nBAIInC,MACAC;;gDALJkC,nBAIInC,MACAC,sBAEAkB;;;;;;;;;AAMJ,AAAAuB,kGAAA,uEAAA,gCAAAC,rBACGE,OAAOC;AADV,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAArB,4BAAAqB;iBAAA,AAAApB,4CAAAoB,eAAA,xEACyBG;AADzB,AAAA,kDAAA,qDAAA,uEAAA,kEAGeA","names":["metabase.lib.drill-thru.sort/orderable-column?","query","stage-number","column-ref","metabase.lib.equality.find_matching_column","metabase.lib.order_by.orderable_columns","metabase.lib.drill-thru.sort/existing-order-by-clause","column","medley.core.find_first","p__79433","vec__79434","cljs.core.nth","_direction","_opts","expr","_asc-or-desc-clause","metabase.lib.order_by.order_bys","metabase.lib.drill-thru.sort/existing-order-by-direction","temp__5804__auto__","vec__79437","direction","_expr","p__79441","map__79443","cljs.core/--destructure-map","cljs.core.get","metabase.lib.drill-thru.sort/sort-drill","value","_context","and__5000__auto__","metabase.lib.drill-thru.common/mbql-stage?","metabase.lib.types.isa/structured?","existing-direction","G__79447","cljs.core/Keyword","metabase.lib.drill-thru.common/drill-thru-method","p__79448","map__79449","drill","_drill","metabase.lib.order_by.remove_all_order_bys","metabase.lib.order_by.order_by","cljs.core.keyword","metabase.lib.drill-thru.common/drill-thru-info-method","p__79450","map__79451","_query","_stage-number","directions"],"sourcesContent":["(ns metabase.lib.drill-thru.sort\n  \"Adds an order by clause on the selected column.\n\n  Entry points:\n\n  - Column header\n\n  Requirements:\n\n  - Column not `type/Structured`\n\n  - If the column is already sorted, allow only the opposite direction to be applied\n\n  Query transformation:\n\n  - Add a sort clause with the selection direction\n\n  Question transformation:\n\n  - None\"\n  (:require\n   [medley.core :as m]\n   [metabase.lib.drill-thru.common :as lib.drill-thru.common]\n   [metabase.lib.equality :as lib.equality]\n   [metabase.lib.order-by :as lib.order-by]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.drill-thru :as lib.schema.drill-thru]\n   [metabase.lib.schema.order-by :as lib.schema.order-by]\n   [metabase.lib.types.isa :as lib.types.isa]\n   [metabase.util.malli :as mu]))\n\n(defn- orderable-column?\n  \"Is `column-ref` orderable? (Does it appear in [[lib.order-by/orderable-columns]]?)\"\n  [query stage-number column-ref]\n  (lib.equality/find-matching-column query\n                                     stage-number\n                                     column-ref\n                                     (lib.order-by/orderable-columns query stage-number)))\n\n(mu/defn ^:private existing-order-by-clause :- [:maybe ::lib.schema.order-by/order-by]\n  [query stage-number column]\n  (m/find-first (fn [[_direction _opts expr, :as _asc-or-desc-clause]]\n                  (lib.equality/find-matching-column query stage-number expr [column]))\n                (lib.order-by/order-bys query stage-number)))\n\n(mu/defn ^:private existing-order-by-direction :- [:maybe ::lib.schema.order-by/direction]\n  [query stage-number column]\n  (when-let [[direction _opts _expr] (existing-order-by-clause query stage-number column)]\n    direction))\n\n(mu/defn sort-drill :- [:maybe ::lib.schema.drill-thru/drill-thru.sort]\n  \"Sorting on a clicked column.\"\n  [query                                           :- ::lib.schema/query\n   stage-number                                    :- :int\n   {:keys [column column-ref value], :as _context} :- ::lib.schema.drill-thru/context]\n  ;; if we have a context with a `:column`, but no `:value`...\n  (when (and (lib.drill-thru.common/mbql-stage? query stage-number)\n             column\n             (nil? value)\n             (not (lib.types.isa/structured? column)))\n    ;; ...and the column is orderable, we can return a sort drill-thru.\n    (when (orderable-column? query stage-number column-ref)\n      ;; check and see if there is already a sort on this column. If there is, we should only suggest flipping the\n      ;; direction to the opposite of what it is now. If there is no existing sort, then return both directions as\n      ;; options.\n      (let [existing-direction (existing-order-by-direction query stage-number column)]\n        {:lib/type        :metabase.lib.drill-thru/drill-thru\n         :type            :drill-thru/sort\n         :column          column\n         :sort-directions (case existing-direction\n                            :asc  [:desc]\n                            :desc [:asc]\n                            [:asc :desc])}))))\n\n(mu/defmethod lib.drill-thru.common/drill-thru-method :drill-thru/sort\n  ([query stage-number drill]\n   (lib.drill-thru.common/drill-thru-method query stage-number drill :asc))\n\n  ([query                        :- ::lib.schema/query\n    stage-number                 :- :int\n    {:keys [column], :as _drill} :- ::lib.schema.drill-thru/drill-thru.sort\n    direction                    :- ::lib.schema.order-by/direction]\n   (-> query\n       ;; remove all existing order bys (see #37633), then add the new one.\n       (lib.order-by/remove-all-order-bys stage-number)\n       (lib.order-by/order-by stage-number column (keyword direction)))))\n\n(defmethod lib.drill-thru.common/drill-thru-info-method :drill-thru/sort\n  [_query _stage-number {directions :sort-directions}]\n  {:type       :drill-thru/sort\n   :directions directions})\n"]}