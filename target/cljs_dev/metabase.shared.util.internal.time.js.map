{"version":3,"sources":["metabase/shared/util/internal/time.cljs"],"mappings":"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","names":["metabase.shared.util.internal.time/now","js/shadow.js.shim.module$moment","metabase.shared.util.internal.time/datetime?","value","and__5000__auto__","js/shadow.js.shim.module$moment.isMoment","metabase.shared.util.internal.time/time?","metabase.shared.util.internal.time/valid?","metabase.shared.util.internal.time/normalize","metabase.shared.util.internal.time/same-day?","d1","d2","metabase.shared.util.internal.time/same-month?","metabase.shared.util.internal.time/same-year?","metabase.shared.util.internal.time/first-day-of-week","cljs.core.nth","js/shadow.js.shim.module$moment.localeData","metabase.shared.util.internal.time/default-options","metabase.shared.util.internal.time/apply-offset","offset-n","offset-unit","cljs.core/name","metabase.shared.util.internal.time-common/to-range","p__75292","map__75293","cljs.core/--destructure-map","cljs.core.get","n","unit","c1","c2","adjusted","metabase.shared.util.internal.time-common/string->timestamp","_","js/shadow.js.shim.module$moment.utc","js/shadow.js.shim.module$moment.ISO_8601","options","as-default","e75294","fexpr__75295","cljs.core/get-method","js/Error","metabase.shared.util.internal.time/magic-base-date","metabase.shared.util.internal.time-common/number->timestamp","metabase.shared.util.internal.time/parse-with-zone","js/shadow.js.shim.module$moment.parseZone","metabase.shared.util.internal.time/localize","metabase.shared.util.internal.time/parse-time-formats","metabase.shared.util.internal.time/parse-time-string","metabase.shared.util.internal.time/day-diff","before","after","metabase.shared.util.internal.time/unit-diff","metabase.shared.util.internal.time/coerce-local-date-time","input","metabase.shared.util.internal.time-common/drop-trailing-time-zone","metabase.shared.util.internal.time/format-extraction-unit","t","G__75302","cljs.core/Keyword","var_args","G__75304","metabase.shared.util.internal.time/format-unit","_locale","metabase.shared.util.internal.time.format_unit","time?","metabase.shared.util.internal.time-common/matches-time?","date?","metabase.shared.util.internal.time-common/matches-date?","date-time?","metabase.shared.util.internal.time-common/matches-date-time?","or__5002__auto__","cljs.core._EQ_","metabase.shared.util.internal.time/format-diff","temporal-value-1","temporal-value-2","default-format","cljs.core/some","cljs.core/complement","cljs.core/string?","vec__75309","lhs","rhs","year-matches?","month-matches?","day-matches?","hour-matches?","lhs-fmt","rhs-fmt","vec__75312","G__75317","metabase.shared.util.internal.time/format-relative-date-range","p__75322","map__75323","opts","metabase.shared.util.internal.time.format_relative_date_range","include-current","offset-now","G__75324","cljs.core/not","pos-n","G__75330","cljs.core/abs","date-ranges","p1__75315#","cljs.core.map","fexpr__75332","cljs.core.apply","metabase.shared.util.internal.time/temporal-formats","metabase.shared.util.internal.time-common/offset-datetime-regex","metabase.shared.util.internal.time-common/local-datetime-regex","metabase.shared.util.internal.time-common/local-date-regex","metabase.shared.util.internal.time-common/offset-time-regex","metabase.shared.util.internal.time-common/local-time-regex","metabase.shared.util.internal.time/iso-8601->moment+type","s","p__75337","vec__75338","map__75341","value-type","regex","formats","cljs.core/re-matches","parsed","js/metabase","js/metabase.shared","js/metabase.shared.util","js/metabase.shared.util.internal","js/metabase.shared.util.internal.time","js/metabase.shared.util.internal.time.moment+type->iso-8601","method-table__5599__auto__","cljs.core.atom","prefer-table__5600__auto__","method-cache__5601__auto__","cached-hierarchy__5602__auto__","hierarchy__5603__auto__","fexpr__75347","cljs.core/MultiFn","cljs.core.symbol","metabase.shared.util.internal.time/moment+type->iso-8601","p__75349","vec__75350","_t","p__75354","vec__75356","_value-type","format-string","p__75360","vec__75361","p__75755","vec__75756","p__75759","vec__75760","p__75763","vec__75764","metabase.shared.util.internal.time/->moment","js/Date","cljs.core/first","metabase.shared.util.internal.time/truncate","vec__75767","metabase.shared.util.internal.time/add","amount","vec__75770","metabase.shared.util.internal.time/format-for-base-type","base-type","pred__75781","p1__75780#","p2__75779#","expr__75782","cljs.core.isa_QMARK_"],"sourcesContent":["(ns metabase.shared.util.internal.time\n  \"CLJS implementation of the time utilities on top of Moment.js.\n  See [[metabase.shared.util.time]] for the public interface.\"\n  (:require\n   [\"moment\" :as moment]\n   [metabase.shared.util.internal.time-common :as common]))\n\n(defn- now [] (moment))\n\n;;; ----------------------------------------------- predicates -------------------------------------------------------\n(defn datetime?\n  \"Given any value, check if it's a (possibly invalid) Moment.\"\n  [value]\n  (and value (moment/isMoment value)))\n\n(defn time?\n  \"checks if the provided value is a local time value.\"\n  [value]\n  (moment/isMoment value))\n\n(defn valid?\n  \"Given a Moment, check that it's valid.\"\n  [value]\n  (and (datetime? value) (.isValid ^moment/Moment value)))\n\n(defn normalize\n  \"Does nothing. Just a placeholder in CLJS; the JVM implementation does some real work.\"\n  [value]\n  value)\n\n(defn same-day?\n  \"Given two platform-specific datetimes, checks if they fall within the same day.\"\n  [^moment/Moment d1 ^moment/Moment d2]\n  (.isSame d1 d2 \"day\"))\n\n(defn same-month?\n  \"True if these two datetimes fall in the same (year and) month.\"\n  [^moment/Moment d1 ^moment/Moment d2]\n  (.isSame d1 d2 \"month\"))\n\n(defn same-year?\n  \"True if these two datetimes fall in the same year.\"\n  [^moment/Moment d1 ^moment/Moment d2]\n  (.isSame d1 d2 \"year\"))\n\n;;; ---------------------------------------------- information -------------------------------------------------------\n(defn first-day-of-week\n  \"The first day of the week varies by locale, but Metabase has a setting that overrides it.\n  In CLJS, Moment is already configured with that setting.\"\n  []\n  (nth [:sunday :monday :tuesday :wednesday :thursday :friday :saturday]\n       (.firstDayOfWeek (moment/localeData))))\n\n(def default-options\n  \"The default map of options - empty in CLJS.\"\n  {})\n\n;;; ------------------------------------------------ to-range --------------------------------------------------------\n(defn- apply-offset\n  [^moment/Moment value offset-n offset-unit]\n  (.add\n   (moment value)\n   offset-n\n   (name offset-unit)))\n\n(defmethod common/to-range :default [^moment/Moment value {:keys [n unit]}]\n  (let [^moment/Moment c1       (.clone value)\n        ^moment/Moment c2       (.clone value)\n        ^moment/Moment adjusted (if (> n 1)\n                                  (.add c2 (dec n) (name unit))\n                                  c2)]\n    [(.startOf c1       (name unit))\n     (.endOf   adjusted (name unit))]))\n\n;; NB: Only the :default for to-range is needed in CLJS, since Moment's startOf and endOf methods are doing the work.\n\n;;; -------------------------------------------- string->timestamp ---------------------------------------------------\n(defmethod common/string->timestamp :default [value _]\n  ;; Best effort to parse this unknown string format, as a local zoneless datetime, then treating it as UTC.\n  (moment/utc value moment/ISO_8601))\n\n(defmethod common/string->timestamp :day-of-week [value options]\n  ;; Try to parse as a regular timestamp; if that fails then try to treat it as a weekday name and adjust from\n  ;; the current time.\n  (let [as-default (try ((get-method common/string->timestamp :default) value options)\n                        (catch js/Error _ nil))]\n    (if (valid? as-default)\n      as-default\n      (-> (now)\n          (.isoWeekday value)\n          (.startOf \"day\")))))\n\n;;; -------------------------------------------- number->timestamp ---------------------------------------------------\n(defn- magic-base-date\n  \"Some of the date coercions are relative, and not directly involved with any particular month.\n  To avoid errors we need to use a reference date that is (a) in a month with 31 days,(b) in a leap year.\n  This uses 2016-01-01 for the purpose.\n  This is a function that returns fresh values, since Moments are mutable.\"\n  []\n  (moment \"2016-01-01\"))\n\n(defmethod common/number->timestamp :default [value _]\n  ;; If no unit is given, or the unit is not recognized, try to parse the number as year number, returning the timestamp\n  ;; for midnight UTC on January 1.\n  (moment/utc value moment/ISO_8601))\n\n(defmethod common/number->timestamp :minute-of-hour [value _]\n  (.. (now) (minute value) (startOf \"minute\")))\n\n(defmethod common/number->timestamp :hour-of-day [value _]\n  (.. (now) (hour value) (startOf \"hour\")))\n\n(defmethod common/number->timestamp :day-of-week [value _]\n  ;; Metabase uses 1 to mean the start of the week, based on the Metabase setting for the first day of the week.\n  ;; Moment uses 0 as the first day of the week in its configured locale.\n  (.. (now) (weekday (dec value)) (startOf \"day\")))\n\n(defmethod common/number->timestamp :day-of-month [value _]\n  ;; We force the initial date to be in a month with 31 days.\n  (.. (magic-base-date) (date value) (startOf \"day\")))\n\n(defmethod common/number->timestamp :day-of-year [value _]\n  ;; We force the initial date to be in a leap year (2016).\n  (.. (magic-base-date) (dayOfYear value) (startOf \"day\")))\n\n(defmethod common/number->timestamp :week-of-year [value _]\n  (.. (now) (week value) (startOf \"week\")))\n\n(defmethod common/number->timestamp :month-of-year [value _]\n  (.. (now) (month (dec value)) (startOf \"month\")))\n\n(defmethod common/number->timestamp :quarter-of-year [value _]\n  (.. (now) (quarter value) (startOf \"quarter\")))\n\n(defmethod common/number->timestamp :year [value _]\n  (.. (now) (year value) (startOf \"year\")))\n\n;;; ---------------------------------------------- parsing helpers ---------------------------------------------------\n(defn parse-with-zone\n  \"Parses a timestamp with Z or a timezone offset at the end.\n  This requires a different API call from timestamps without time zones in CLJS.\"\n  [value]\n  (moment/parseZone value))\n\n(defn localize\n  \"Given a freshly parsed absolute Moment, convert it to a local one.\"\n  [value]\n  (.local value))\n\n(def ^:private parse-time-formats\n  #js [\"HH:mm:ss.SSS[Z]\"\n       \"HH:mm:ss.SSS\"\n       \"HH:mm:ss\"\n       \"HH:mm\"])\n\n(defn parse-time-string\n  \"Parses a time string that has been stripped of any time zone.\"\n  [value]\n  (moment value parse-time-formats))\n\n;;; ------------------------------------------------ arithmetic ------------------------------------------------------\n\n(declare unit-diff)\n\n(defn day-diff\n  \"Returns the time elapsed between `before` and `after` in days.\"\n  [before after]\n  (unit-diff :day before after))\n\n(defn- coerce-local-date-time [input]\n  (-> input\n      common/drop-trailing-time-zone\n      (moment/utc moment/ISO_8601)))\n\n(defn ^:private format-extraction-unit\n  \"Formats a date-time value given the temporal extraction unit.\n  If unit is not supported, returns nil.\"\n  [t unit]\n  (case unit\n    :day-of-week     (.format t \"dddd\")\n    :month-of-year   (.format t \"MMM\")\n    :minute-of-hour  (.format t \"m\")\n    :hour-of-day     (.format t \"h A\")\n    :day-of-month    (.format t \"D\")\n    :day-of-year     (.format t \"DDD\")\n    :week-of-year    (.format t \"w\")\n    :quarter-of-year (.format t \"[Q]Q\")\n    nil))\n\n(defn format-unit\n  \"Formats a temporal-value (iso date/time string, int for extraction units) given the temporal-bucketing unit.\n   If unit is nil, formats the full date/time.\n   Time input formatting is only defined with time units.\"\n  ;; This third argument is needed for the JVM side; it can be ignored here.\n  ([input unit _locale] (format-unit input unit))\n  ([input unit]\n   (if (string? input)\n     (let [time? (common/matches-time? input)\n           date? (common/matches-date? input)\n           date-time? (common/matches-date-time? input)\n           t (cond\n               ;; Anchor to an arbitrary date since time inputs are only defined for\n               ;; :hour-of-day and :minute-of-hour.\n               time? (moment/utc (str \"2023-01-01T\" input) moment/ISO_8601)\n               (or date? date-time?) (coerce-local-date-time input))]\n       (if (and t (.isValid t))\n         (or\n           (format-extraction-unit t unit)\n           (cond\n             time? (.format t \"h:mm A\")\n             date? (.format t \"MMM D, YYYY\")\n             date-time? (.format t \"MMM D, YYYY, h:mm A\")))\n         input))\n     (if (= unit :hour-of-day)\n       (str (cond (zero? input) \"12\" (<= input 12) input :else (- input 12)) \" \" (if (<= input 11) \"AM\" \"PM\"))\n       (or\n         (format-extraction-unit (common/number->timestamp input {:unit unit}) unit)\n         (str input))))))\n\n(defn format-diff\n  \"Formats a time difference between two temporal values.\n   Drops redundant information.\"\n  [temporal-value-1 temporal-value-2]\n  (let [default-format #(str (format-unit temporal-value-1 nil)\n                             \" \u2013 \"\n                             (format-unit temporal-value-2 nil))]\n    (cond\n      (some (complement string?) [temporal-value-1 temporal-value-2])\n      (default-format)\n\n      (= temporal-value-1 temporal-value-2)\n      (format-unit temporal-value-1 nil)\n\n      (and (common/matches-time? temporal-value-1)\n           (common/matches-time? temporal-value-2))\n      (default-format)\n\n      (and (common/matches-date-time? temporal-value-1)\n           (common/matches-date-time? temporal-value-2))\n      (let [lhs (coerce-local-date-time temporal-value-1)\n            rhs (coerce-local-date-time temporal-value-2)\n            year-matches? (= (.format lhs \"YYYY\") (.format rhs \"YYYY\"))\n            month-matches? (= (.format lhs \"MMM\") (.format rhs \"MMM\"))\n            day-matches? (= (.format lhs \"D\") (.format rhs \"D\"))\n            hour-matches? (= (.format lhs \"HH\") (.format rhs \"HH\"))\n            [lhs-fmt rhs-fmt] (cond\n                                (and year-matches? month-matches? day-matches? hour-matches?)\n                                [\"MMM D, YYYY, h:mm A \" \" h:mm A\"]\n\n                                (and year-matches? month-matches? day-matches?)\n                                [\"MMM D, YYYY, h:mm A \" \" h:mm A\"]\n\n                                year-matches?\n                                [\"MMM D, h:mm A \" \" MMM D, YYYY, h:mm A\"])]\n\n        (if lhs-fmt\n          (str (.format lhs lhs-fmt) \"\u2013\" (.format rhs rhs-fmt))\n          (default-format)))\n\n      (and (common/matches-date? temporal-value-1)\n           (common/matches-date? temporal-value-2))\n      (let [lhs (moment/utc temporal-value-1 moment/ISO_8601)\n            rhs (moment/utc temporal-value-2 moment/ISO_8601)\n            year-matches? (= (.format lhs \"YYYY\") (.format rhs \"YYYY\"))\n            month-matches? (= (.format lhs \"MMM\") (.format rhs \"MMM\"))\n            [lhs-fmt rhs-fmt] (cond\n                                (and year-matches? month-matches?)\n                                [\"MMM D\" \"D, YYYY\"]\n\n                                year-matches?\n                                [\"MMM D \" \" MMM D, YYYY\"])]\n        (if lhs-fmt\n          (str (.format lhs lhs-fmt) \"\u2013\" (.format rhs rhs-fmt))\n          (default-format)))\n\n      :else\n      (default-format))))\n\n(defn format-relative-date-range\n  \"Given a `n` `unit` time interval and the current date, return a string representing the date-time range.\n   Provide an `offset-n` and `offset-unit` time interval to change the date used relative to the current date.\n   `options` is a map and supports `:include-current` to include the current given unit of time in the range.\"\n  ([n unit offset-n offset-unit opts]\n   (format-relative-date-range (now) n unit offset-n offset-unit opts))\n  ([t n unit offset-n offset-unit {:keys [include-current]}]\n   (let [offset-now (cond-> t\n                      (neg? n) (apply-offset n unit)\n                      (and (pos? n) (not include-current)) (apply-offset 1 unit)\n                      (and offset-n offset-unit) (apply-offset offset-n offset-unit))\n         pos-n (cond-> (abs n)\n                 include-current inc)\n         date-ranges (map #(.format % (if (#{:hour :minute} unit) \"YYYY-MM-DDTHH:mm\" \"YYYY-MM-DD\"))\n                          (common/to-range offset-now\n                                           {:unit unit\n                                            :n pos-n\n                                            :offset-n offset-n\n                                            :offset-unit offset-unit}))]\n     (apply format-diff date-ranges))))\n\n(def ^:private temporal-formats\n  {:offset-date-time {:regex   common/offset-datetime-regex\n                      :formats #js [\"yyyy-MM-DDTHH:mm:ss.SSS[Z]\"\n                                    \"yyyy-MM-DDTHH:mm:ss[Z]\"\n                                    \"yyyy-MM-DDTHH:mm[Z]\"\n                                    \"yyyy-MM-DDTHH[Z]\"]}\n   :local-date-time  {:regex   common/local-datetime-regex\n                      :formats #js [\"yyyy-MM-DDTHH:mm:ss.SSS\"\n                                    \"yyyy-MM-DDTHH:mm:ss\"\n                                    \"yyyy-MM-DDTHH:mm\"\n                                    \"yyyy-MM-DDTHH\"]}\n   :local-date       {:regex   common/local-date-regex\n                      :formats #js [\"yyyy-MM-DD\"\n                                    \"yyyy-MM\"\n                                    \"yyyy\"]}\n   :offset-time      {:regex   common/offset-time-regex\n                      :formats #js [\"HH:mm:ss.SSS[Z]\"\n                                    \"HH:mm:ss[Z]\"\n                                    \"HH:mm[Z]\"\n                                    \"HH[Z]\"]}\n   :local-time       {:regex   common/local-time-regex\n                      :formats #js [\"HH:mm:ss.SSS\"\n                                    \"HH:mm:ss\"\n                                    \"HH:mm\"\n                                    \"HH\"]}})\n\n(defn- iso-8601->moment+type\n  [s]\n  (some (fn [[value-type {:keys [regex formats]}]]\n          (when (re-matches regex s)\n            (let [parsed (moment/parseZone s formats #_strict? true)]\n              (when (.isValid parsed)\n                [parsed value-type]))))\n        temporal-formats))\n\n(defmulti ^:private moment+type->iso-8601\n  {:arglists '([moment+type])}\n  (fn [[_t value-type]]\n    value-type))\n\n(defmethod moment+type->iso-8601 :offset-date-time\n  [[^moment/Moment t _value-type]]\n  (let [format-string (cond\n                        (pos? (.milliseconds t)) \"yyyy-MM-DDTHH:mm:ss.SSS[Z]\"\n                        (pos? (.seconds t))      \"yyyy-MM-DDTHH:mm:ss[Z]\"\n                        :else                    \"yyyy-MM-DDTHH:mm[Z]\")]\n    (.format t format-string)))\n\n(defmethod moment+type->iso-8601 :local-date-time\n  [[^moment/Moment t _value-type]]\n  (let [format-string (cond\n                        (pos? (.milliseconds t)) \"yyyy-MM-DDTHH:mm:ss.SSS\"\n                        (pos? (.seconds t))      \"yyyy-MM-DDTHH:mm:ss\"\n                        :else                    \"yyyy-MM-DDTHH:mm\")]\n    (.format t format-string)))\n\n(defmethod moment+type->iso-8601 :local-date\n  [[^moment/Moment t _value-type]]\n  (.format t \"yyyy-MM-DD\"))\n\n(defmethod moment+type->iso-8601 :offset-time\n  [[^moment/Moment t _value-type]]\n  (let [format-string (cond\n                        (pos? (.milliseconds t)) \"HH:mm:ss.SSS[Z]\"\n                        (pos? (.seconds t))      \"HH:mm:ss[Z]\"\n                        :else                    \"HH:mm[Z]\")]\n    (.format t format-string)))\n\n(defmethod moment+type->iso-8601 :local-time\n  [[^moment/Moment t _value-type]]\n  (let [format-string (cond\n                        (pos? (.milliseconds t)) \"HH:mm:ss.SSS\"\n                        (pos? (.seconds t))      \"HH:mm:ss\"\n                        :else                    \"HH:mm\")]\n    (.format t format-string)))\n\n(defn- ->moment ^moment/Moment [t]\n  (if (instance? js/Date t)\n    (moment/utc t)\n    t))\n\n(defn unit-diff\n  \"Return the number of `unit`s between two temporal values `before` and `after`, e.g. maybe there are 32 `:day`s\n  between Jan 1st and Feb 2nd.\"\n  [unit before after]\n  (let [^moment/Moment before (if (string? before)\n                                (first (iso-8601->moment+type before))\n                                (->moment before))\n        ^moment/Moment after  (if (string? after)\n                                (first (iso-8601->moment+type after))\n                                (->moment after))]\n    (.diff after before (name unit))))\n\n(defn truncate\n  \"ClojureScript implementation of [[metabase.shared.util.time/truncate]]; supports both Moment.js instances and ISO-8601\n  strings.\"\n  [t unit]\n  (if (string? t)\n    (let [[t value-type] (iso-8601->moment+type t)\n          t              (truncate t unit)]\n      (moment+type->iso-8601 [t value-type]))\n    (let [^moment/Moment t (->moment t)]\n      (.startOf t (name unit)))))\n\n(defn add\n  \"ClojureScript implementation of [[metabase.shared.util.time/add]]; supports both Moment.js instances and ISO-8601 strings.\"\n  [t unit amount]\n  (if (string? t)\n    (let [[t value-type] (iso-8601->moment+type t)\n          t              (add t unit amount)]\n      (moment+type->iso-8601 [t value-type]))\n    (let [^moment/Moment t (->moment t)]\n      (.add t amount (name unit)))))\n\n(defn format-for-base-type\n  \"ClojureScript implementation of [[metabase.shared.util.time/format-for-base-type]]; format a temporal value as an\n  ISO-8601 string appropriate for a value of the given `base-type`, e.g. a `:type/Time` gets formatted as a\n  `HH:mm:ss.SSS` string.\"\n  [t base-type]\n  (if (string? t)\n    t\n    (let [t          (->moment t)\n          value-type (condp #(isa? %2 %1) base-type\n                       :type/TimeWithTZ     :offset-time\n                       :type/Time           :local-time\n                       :type/DateTimeWithTZ :offset-date-time\n                       :type/DateTime       :local-date-time\n                       :type/Date           :local-date)]\n      (moment+type->iso-8601 [t value-type]))))\n"]}