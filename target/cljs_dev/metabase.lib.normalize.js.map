{"version":3,"sources":["metabase/lib/normalize.cljc"],"mappings":"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","names":["metabase.lib.normalize/lib-type","x","cljs.core/map?","cljs.core.keyword","p1__76445#","cljs.core/some","cljs.core.get","metabase.lib.normalize/lib-type->schema","metabase.lib.normalize/infer-schema","or__5002__auto__","G__76447","and__5000__auto__","cljs.core/vector?","cljs.core.some_fn","cljs.core/simple-keyword?","cljs.core/string?","cljs.core/first","metabase.lib.schema.mbql-clause/tag->registered-schema-name","metabase.lib.normalize/default-error-fn","error","level__73199__auto__","metabase.util.log/glogi-level","logger__73200__auto__","metabase.util.log/is-loggable?","x__73201__auto__","js/Error","lambdaisland.glogi.log","metabase.util.log/format-msg","metabase.util.log.format_msg","metabase.util.pprint_to_str","metabase.lib.normalize/*error-fn*","metabase.lib.normalize/coercer","schema","metabase.util.malli.registry/cached","respond","cljs.core/identity","raise","malli.core.coercer","malli.transform.transformer","var_args","G__76472","metabase.lib.normalize/normalize","p__76482","map__76483","cljs.core/--destructure-map","metabase.lib.normalize.normalize","throw?","_options","thunk","fexpr__76487","*error-fn*-orig-val__76488","*error-fn*-temp-val__76489","cljs.core.ex_info","metabase.shared.util.i18n/js-i18n"],"sourcesContent":["(ns metabase.lib.normalize\n  (:require\n   [malli.core :as mc]\n   [malli.transform :as mtx]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.mbql-clause :as lib.schema.mbql-clause]\n   [metabase.lib.schema.metadata :as lib.schema.metadata]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.log :as log]\n   [metabase.util.malli.registry :as mr]))\n\n(defn- lib-type [x]\n  (when (map? x)\n    (keyword (some #(get x %) [:lib/type \"lib/type\"]))))\n\n;;; TODO -- we are missing some stuff for sure.\n(def ^:private lib-type->schema\n  {:mbql/query        ::lib.schema/query\n   :mbql.stage/mbql   ::lib.schema/stage.mbql\n   :mbql.stage/native ::lib.schema/stage.native\n   :metadata/database ::lib.schema.metadata/database\n   :metadata/table    ::lib.schema.metadata/table\n   :metadata/column   ::lib.schema.metadata/column\n   :metadata/card     ::lib.schema.metadata/card\n   :metadata/segment  ::lib.schema.metadata/segment\n   :metadata/metric   ::lib.schema.metadata/metric})\n\n(defn- infer-schema [x]\n  (cond\n    (map? x)\n    (or (-> x lib-type lib-type->schema)\n        :map)\n\n    (and (vector? x)\n         ((some-fn simple-keyword? string?) (first x)))\n    (lib.schema.mbql-clause/tag->registered-schema-name (first x))\n\n    :else\n    :any))\n\n(defn- default-error-fn\n  \"If normalization errors somewhere, just log the error and return the partially-normalized result. Easier to debug\n  this way.\"\n  [error]\n  (log/warnf \"Error normalizing pMBQL:\\n%s\" (u/pprint-to-str error))\n  (:value error))\n\n(def ^:private ^:dynamic *error-fn*\n  default-error-fn)\n\n(defn- coercer [schema]\n  (mr/cached ::coercer\n             schema\n             (fn []\n               (let [respond identity\n                     raise   #'*error-fn*] ; capture var rather than the bound value at the time this is eval'ed\n                 (mc/coercer schema (mtx/transformer {:name :normalize}) respond raise)))))\n\n(defn normalize\n  \"Ensure some part of an MBQL query `x`, e.g. a clause or map, is in the right shape after coming in from JavaScript or\n  deserialized JSON (from the app DB or a REST API request). This is intended for things that are already in a\n  generally correct pMBQL; to 'normalize' things from legacy MBQL, use [[metabase.lib.convert]].\n\n  Normalization logic is defined in various schemas; grep for `:decode/normalize` in the `metabase.lib.schema*`\n  namespaces.\n\n  The default implementation will keywordize keys for maps, and convert some known keys\n  using [[default-map-value-fns]]; for MBQL clauses, it will convert the clause name to a keyword and recursively\n  normalize its options and arguments. Implement this method if you need custom behavior for something.\n\n  Pass in a `nil` schema to automatically attempt to infer the schema based on `x` itself.\n\n  By default, does not throw Exceptions -- just logs them and returns what it was able to normalize, but you can pass\n  in the option `{:throw? true}` to have it throw exceptions when normalization fails.\"\n  ([x]\n   (normalize nil x))\n\n  ([schema x]\n   (normalize schema x nil))\n\n  ([schema x {:keys [throw?], :or {throw? false}, :as _options}]\n   (let [schema (or schema (infer-schema x))\n         thunk  (^:once fn* []\n                 ((coercer schema) x))]\n     (if throw?\n       (binding [*error-fn* (fn [error]\n                              (throw (ex-info (i18n/tru \"Normalization error\")\n                                              {:schema schema, :x x, :error error})))]\n         (thunk))\n       (thunk)))))\n"]}