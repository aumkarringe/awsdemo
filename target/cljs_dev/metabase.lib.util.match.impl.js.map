{"version":3,"sources":["metabase/lib/util/match/impl.cljc"],"mappings":"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","names":["metabase.lib.util.match.impl/match-with-pred-or-class","pred-or-class","cljs.core/fn?","cljs.core.ex_info","js/Error","metabase.lib.util.match.impl/match-in-collection","match-fn","clause-parents","form","cljs.core/vector?","cljs.core/map?","cljs.core.mapcat","p__75246","vec__75247","cljs.core.nth","k","v","G__75250","G__75251","cljs.core.conj","cljs.core/sequential?","cljs.core.partial","cljs.core/Keyword","cljs.core/first","metabase.lib.util.match.impl/replace-in-collection","replace-fn","cljs.core.into","iter__5480__auto__","s__75253","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","cljs.core/count","b__75255","cljs.core/chunk-buffer","i__75254","vec__75256","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__75252","cljs.core/chunk-rest","vec__75261","cljs.core/cons","cljs.core/rest","G__75259","G__75260","G__75264","G__75265","cljs.core.mapv","var_args","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","metabase.lib.util.match.impl/update-in-unless-empty","seq75266","G__75267","cljs.core/next","G__75268","G__75269","self__5711__auto__","m","ks","f","args","cljs.core/not","cljs.core.get_in","cljs.core.apply","cljs.core/update-in","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.lib.util.match.impl\n  \"Internal implementation of the MBQL `match` and `replace` macros. Don't use these directly.\")\n\n;; have to do this at runtime because we don't know if a symbol is a class or pred or whatever when we compile the macro\n(defn match-with-pred-or-class\n  \"Return a function to use for pattern matching via `core.match`'s `:guard` functionality based on the value of a\n  `pred-or-class` passed in as a pattern to `match` or `replace`.\n\n  (Class-based matching currently only works in Clojure. For ClojureScript, only predicate function matching works.)\"\n  [pred-or-class]\n  (cond\n    ;; If this function is ever used from JS, we need to figure out how to do this\n    #?@(:clj [(class? pred-or-class)\n              (partial instance? pred-or-class)])\n\n    (fn? pred-or-class)\n    pred-or-class\n\n    :else\n    ;; this is dev-specific so we don't need to localize it\n    (throw (ex-info \"Invalid pattern: don't know how to handle symbol.\" {:symbol pred-or-class}))))\n\n(defn match-in-collection\n  \"Internal impl for `match`. If `form` is a collection, call `match-fn` to recursively look for matches in it.\"\n  [match-fn clause-parents form]\n  {:pre [(fn? match-fn) (vector? clause-parents)]}\n  (cond\n    (map? form)\n    (mapcat (fn [[k v]]\n              (match-fn (conj clause-parents k) v))\n            form)\n\n    (sequential? form)\n    (mapcat (partial match-fn (if (keyword? (first form))\n                                (conj clause-parents (first form))\n                                clause-parents))\n            form)))\n\n(defn replace-in-collection\n  \"Inernal impl for `replace`. Recursively replace values in a collection using a `replace-fn`.\"\n  [replace-fn clause-parents form]\n  (cond\n    (map? form)\n    (into form (for [[k v] form]\n                 [k (replace-fn (conj clause-parents k) v)]))\n\n    (sequential? form)\n    (mapv (partial replace-fn (if (keyword? (first form))\n                                (conj clause-parents (first form))\n                                clause-parents))\n          form)\n    :else              form))\n\n(defn update-in-unless-empty\n  \"Like `update-in`, but only updates in the existing value is non-empty.\"\n  [m ks f & args]\n  (if-not (seq (get-in m ks))\n    m\n    (apply update-in m ks f args)))\n"]}